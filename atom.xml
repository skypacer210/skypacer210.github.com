<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>skypacer的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://skypacer210.github.io/"/>
  <updated>2017-11-05T02:17:40.000Z</updated>
  <id>https://skypacer210.github.io/</id>
  
  <author>
    <name>skypacer210</name>
    <email>yangyongbupt168@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Karman滤波器</title>
    <link href="https://skypacer210.github.io/2017/11/01/little-on-karman-filter/"/>
    <id>https://skypacer210.github.io/2017/11/01/little-on-karman-filter/</id>
    <published>2017-10-31T16:00:00.000Z</published>
    <updated>2017-11-05T02:17:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对卡尔曼滤波做一个粗略总结~    </p>
<hr>
<h3 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h3><p>假定一个机器人导航，其状态用$\vec{x_k}$描述：  </p>
<p>$<br>\vec{x_k}=\left ( \vec{p},\vec{v} \right )<br>$</p>
<h3 id="2、Kalman-filter如何看待该问题"><a href="#2、Kalman-filter如何看待该问题" class="headerlink" title="2、Kalman filter如何看待该问题"></a>2、Kalman filter如何看待该问题</h3><p>采用一个向量描述状态：</p>
<p>$<br>\vec{x}=<br>\left [<br>\begin{matrix}<br>        p \<br>        v \<br>        \end{matrix}<br> \right ]<br>$</p>
<p>两个假设：</p>
<ul>
<li>p和v都符合高斯分布，数学期望为$\mu$，方差为$\sigma ^{2}$，</li>
<li>随机</li>
</ul>
<p><img src="http://www.bzarg.com/wp-content/uploads/2015/08/gauss_1.png" alt="gauss_1">  </p>
<center>Figure 1: gauss_1</center>


<p>我们考虑速度和位置是有关联的：</p>
<p><strong>矩阵描述问题</strong></p>
<p>协方差用于衡量p和v两个变量的总体误差，</p>
<p>$<br>\begin{equation} \label{eq:statevars}<br>\begin{aligned}<br>\mathbf{\hat{x}}_k &amp;= \begin{bmatrix}<br>\text{position}\<br>\text{velocity}<br>\end{bmatrix}\<br>\mathbf{P}<em>k &amp;=<br>\begin{bmatrix}<br>\Sigma</em>{pp} &amp; \Sigma<em>{pv} \<br>\Sigma</em>{vp} &amp; \Sigma_{vv} \<br>\end{bmatrix}<br>\end{aligned}<br>\end{equation}<br>$</p>
<p>状态迁移描述：</p>
<p><img src="http://www.bzarg.com/wp-content/uploads/2015/08/gauss_7.jpg" alt="状态迁移"></p>
<p>其中的预测过程用一个矩阵描述Fk：</p>
<p><img src="http://www.bzarg.com/wp-content/uploads/2015/08/gauss_8.jpg" alt="预测过程"></p>
<p>我们预测速度和位置的迁移公式：</p>
<p>$<br>\begin{split}<br>\color{deeppink}{p<em>k} &amp;= \color{royalblue}{p</em>{k-1}} + \Delta t &amp;\color{royalblue}{v_{k-1}} \<br>\color{deeppink}{v<em>k} &amp;= &amp;\color{royalblue}{v</em>{k-1}}<br>\end{split}<br>$</p>
<p>预测矩阵描述：</p>
<p>$<br>\begin{align}<br>\color{deeppink}{\mathbf{\hat{x}}<em>k} &amp;= \begin{bmatrix}<br>1 &amp; \Delta t \<br>0 &amp; 1<br>\end{bmatrix} \color{royalblue}{\mathbf{\hat{x}}</em>{k-1}} \<br>&amp;= \mathbf{F}<em>k \color{royalblue}{\mathbf{\hat{x}}</em>{k-1}} \label{statevars}<br>\end{align}<br>$</p>
<p>虽然有了预测矩阵，但是我们还不知道如何<strong>更新协方差矩阵</strong>；</p>
<p>这样我们用下面的方法更新协方差矩阵：</p>
<p>$<br>\begin{equation}<br>\begin{split}<br>\color{deeppink}{\mathbf{\hat{x}}_k} &amp;= \mathbf{F}<em>k \color{royalblue}{\mathbf{\hat{x}}</em>{k-1}} \<br>\color{deeppink}{\mathbf{P}_k} &amp;= \mathbf{F<em>k} \color{royalblue}{\mathbf{P}</em>{k-1}} \mathbf{F}_k^T<br>\end{split}<br>\end{equation}<br>$</p>
<p>注意这里是大写的P，代表概率，协方差概率；</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对卡尔曼滤波做一个粗略总结~    &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1、问题描述&quot;&gt;&lt;a href=&quot;#1、问题描述&quot; class=&quot;headerlink&quot; title=&quot;1、问题描述&quot;&gt;&lt;/a&gt;1、问题描述&lt;/h3&gt;&lt;p&gt;假定一个机器人导航，其状态用$\vec{
    
    </summary>
    
      <category term="algorithm" scheme="https://skypacer210.github.io/categories/algorithm/"/>
    
    
      <category term="karman filter" scheme="https://skypacer210.github.io/tags/karman-filter/"/>
    
      <category term="tracking" scheme="https://skypacer210.github.io/tags/tracking/"/>
    
  </entry>
  
  <entry>
    <title>API Security</title>
    <link href="https://skypacer210.github.io/2017/01/12/api-security/"/>
    <id>https://skypacer210.github.io/2017/01/12/api-security/</id>
    <published>2017-01-11T16:00:00.000Z</published>
    <updated>2017-09-19T16:34:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>该文分析了API安全相关的验证与鉴权技术特点与基本原理。     </p>
<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p><a href="https://medium.com/@him_jar/permission-based-views-in-angularjs-1edfd0fd8288" target="_blank" rel="external">前端与权限</a><br><a href="https://nordicapis.com/how-to-control-user-identity-within-microservices/" target="_blank" rel="external">微服务中的身份</a><br><a href="https://medium.com/@robert.broeckelmann/identity-propagation-in-an-api-gateway-architecture-c0f9bbe9273b" target="_blank" rel="external">API gateway</a><br><a href="https://laracasts.com/discuss/channels/general-discussion/general-advice-how-to-handle-api-authentication-and-databases?page=1" target="_blank" rel="external">如何解决前端与API消费者同时鉴权问题</a><br><a href="https://kubernetes.io/docs/admin/authorization/rbac/" target="_blank" rel="external">RDBC</a><br><a href="https://www.moesif.com/blog/technical/restful-apis/Authorization-on-RESTful-APIs/" target="_blank" rel="external">JWT1</a><br><a href="https://en.wikipedia.org/wiki/JSON_Web_Token" target="_blank" rel="external">jwt2</a><br><a href="https://support.omnigroup.com/doc-assets//OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/xhtml/03_tutorial.xhtml" target="_blank" rel="external">ominiplan_tool</a></p>
<p>线程安全是多线程程序中的编程理念，一段代码线程安全意味着在多个线程执行的时候能够运行正确。因此，它必须满足： </p>
<ul>
<li>确保你的网站能够适配所有主流的浏览器。一个最小的测试集必须包括：Firefox采用的Gecko引擎，Safari以及其他手机浏览器采用的WebKit引擎，Chrome，IE(兼容VPC图片)和Opera。同时也需考虑在不同OS上的渲染问题；</li>
<li>考虑浏览器之外的访问通道，比如蜂窝电话，Sreen Reader以及搜索引擎。这里的要点是如何在不影响用户的情况下更新功能，这里需要版本管理软件和自动化编译机制；</li>
<li>永远不要呈现给用户不友好的错误提示；</li>
<li>不要将用户的邮箱地址以明文形式呈现；</li>
<li>对于用户产生的链接加入<code>rel=&quot;nofollow&quot;</code>属性以避免受到攻击；</li>
<li>为你的网站加入深思熟虑后的限制；</li>
<li>POST成功后立即重定向，从而禁止再次提交引发刷新；</li>
<li>理解并应用渐进增强；</li>
<li>多元化用户交互，不单单依赖鼠标；</li>
<li>最后一点：别让用户思考； </li>
</ul>
<h3 id="微服务中的身份问题"><a href="#微服务中的身份问题" class="headerlink" title="微服务中的身份问题"></a>微服务中的身份问题</h3><p>OAuth2 and OpenID Connect</p>
<p>Securing each step of the request’s journey</p>
<ul>
<li>参考OWASP development guide，其覆盖了上层到底层的安全架构和知道准则；</li>
<li>理解SQL注入并知道如何防御；</li>
<li>永远不信任用户输入或者是来自用户的请求，包括cookie以及隐藏其后的属性值；</li>
<li>对密码进行”撒盐”哈希，不同列采用不同的“盐”以防御彩虹表攻击；选择计算较慢的哈希算法(比如bcrypt或者scrypt)来存储密码，NIST和FIPS建议采用PBKDF2对密码进行哈希。避免直接使用MD5和SHA；</li>
<li>不要试图开发你自己的验证系统，相比现有成熟的验证体系，你的方法更容易受到攻击；</li>
<li>对敏感数据输入相关的页面采用SSL/HTTPS保护；</li>
<li>预防 session hijacking；</li>
<li>避免 cross site scripting (XSS)；</li>
<li>避免 cross site request forgeries (CSRF)；</li>
<li>避免 Clickjacking；</li>
<li>确保你的系统及时更新最新的补丁；</li>
<li>确保你的DB连接信息是安全的；</li>
<li>及时追踪最新的攻击方法和手段；</li>
<li>阅读谷歌浏览器的安全手册；</li>
<li>阅读Web应用攻击者的手册；</li>
<li>考虑最小权限原则，尝试以非root权限运行你的应用服务器；</li>
</ul>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul>
<li>如有必要实现cache，理解并使用HTTP、HTML5的cache；</li>
<li>优化图像处理，不要在需要反复使用的场合调用20KB的照片；</li>
<li>学会如何压缩和deflate；</li>
<li>组合多个脚本文件以减少浏览器的连接数量；</li>
<li>参考Yahoo的异常性能站点，包含有多个操作指导；</li>
<li>采用CSS处理小的有相关度的图片；</li>
<li>高访问量站点需要考虑跨domain的组件拆分问题；</li>
<li>静态内容()应该放置于一个单独的域，该域不使用cookie。因为一个域及其子域中的所有cookie在每次请求发送中都会被包含。一个好的方式是采用CDN，但是必须考虑CDN失效的情形；</li>
<li>最小化渲染页面所需的HTTP请求；</li>
<li>善假于物，比如Google的Closure JavaScript编译器；</li>
<li>确保在站点的根目录下有一个<code>favicon.ico</code>文件, 比如. <code>/favicon.ico</code>。浏览器会自动请求该文件，甚至在HTML中无需提及；如果没有这样的文件<code>/favicon.ico</code>，会产生多个404错误，消耗网站带宽；</li>
</ul>
<h3 id="搜索引擎优化"><a href="#搜索引擎优化" class="headerlink" title="搜索引擎优化"></a>搜索引擎优化</h3><ul>
<li>采用搜索引擎友好的URLS，比如采用<code>example.com/pages/45-article-title</code> 而不是<code>example.com/index.php?page=45</code>；  </li>
<li>对于动态内容修改，将<code>#</code>替换诶<code>#！</code>；  </li>
<li>不要采用诸如<code>click here</code>的链接；</li>
<li>设置一个XML sitemap, 缺省位置<code>/sitemap.xml</code>；</li>
<li>对于多个URL指向同一个内容，采用<code>&lt;link rel=&quot;canonical&quot; ... /&gt;</code>；</li>
<li>善假于物，这次是Google的 Webmaster Tools 和微软Bing的 Webmaster Tools；</li>
<li>安装Google的分析器，或者是开源的Piwik；</li>
<li>知道搜索引擎爬虫的工作原理；</li>
<li>采用301做永久重定向；</li>
</ul>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><ul>
<li>理解HTTP相关原理，比如GET、POST、session、cookie以及无状态；</li>
<li>根据W3C标准编写HTML和CSS，确保准确；</li>
<li>理解浏览器中JavaScript如何工作；</li>
<li>理解JavaScript, style sheets以及其他所需资源的加载过程以及对性能的影响；</li>
<li>理解JavaScript sandbox的工作原理；</li>
<li>理解JavaScript已逐步被AJAX替代；</li>
<li>理解301和302重定向的区别；</li>
<li>尽可能多的理解网站所运行的平台；</li>
<li>考虑采用Reset Style Sheet 或者normalize.css；</li>
<li>考虑JavaScript框架；</li>
<li>综合考虑perceived performance 和 JS 框架；</li>
<li>不要重复发明轮子；</li>
<li>尽可能“轻便”；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该文分析了API安全相关的验证与鉴权技术特点与基本原理。     &lt;/p&gt;
&lt;h3 id=&quot;JWT&quot;&gt;&lt;a href=&quot;#JWT&quot; class=&quot;headerlink&quot; title=&quot;JWT&quot;&gt;&lt;/a&gt;JWT&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://medium.c
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="HTTP" scheme="https://skypacer210.github.io/tags/HTTP/"/>
    
      <category term="OWASP" scheme="https://skypacer210.github.io/tags/OWASP/"/>
    
      <category term="JWT" scheme="https://skypacer210.github.io/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>JAVA HTTP Client Configration</title>
    <link href="https://skypacer210.github.io/2016/07/30/JAVA-HTTPClient-Config/"/>
    <id>https://skypacer210.github.io/2016/07/30/JAVA-HTTPClient-Config/</id>
    <published>2016-07-29T16:00:00.000Z</published>
    <updated>2017-08-09T14:20:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JAVA-网络相关的类、接口与异常"><a href="#JAVA-网络相关的类、接口与异常" class="headerlink" title="JAVA 网络相关的类、接口与异常"></a>JAVA 网络相关的类、接口与异常</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul>
<li>ConnectionManager</li>
<li>RegistryBuilder</li>
</ul>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>我们主要关注ConnectionSocketFactory，用于创建和连接socket，</p>
<ul>
<li><p>可以实现为非加密socket:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class PlainConnectionSocketFactory implements ConnectionSocketFactory &#123;</div></pre></td></tr></table></figure>
</li>
<li><p>也可以实现为加密socket;</p>
</li>
<li><p>也可以继续扩展增加新的方法：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public interface LayeredConnectionSocketFactory extends ConnectionSocketFactory &#123;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul>
<li>ConnectException</li>
<li>ProtocolException</li>
</ul>
<h3 id="长连接修改"><a href="#长连接修改" class="headerlink" title="长连接修改"></a>长连接修改</h3><p>将基于HttpURLConnection类的HTTPClient修改为HttpClient4.3.2： </p>
<ul>
<li>重写了HttpRequest类的getHttpConnection()方法和HttpResponse类的getResponse()方法，主要将HttpURLConnection类的操作接口替换为HttpClient4.3.2；</li>
<li>增加ConnectionManager类，主要基于PoolingHttpClientConnectionManager类完成KeepAlive策略配置、连接池管理与socket超时配置，对于HTTPS服务端验证，目前缺省验证通过；</li>
<li>为Client接口增加setConnConfig()方法，客户端可以基于该接口配置如下参数：<ul>
<li>maxConnNumber：总的最大并发连接数；</li>
<li>maxConnPerRoute：每个路由的并发连接数，如果不使用代理，该限制实际上就是单个主机的连接数限制，缺省为2；</li>
<li>maxKeepAliveTimeout：设置KeepAlive超时时间，单位为秒；</li>
</ul>
</li>
</ul>
<h3 id="短连接修改"><a href="#短连接修改" class="headerlink" title="短连接修改"></a>短连接修改</h3><h4 id="1-连接重用策略"><a href="#1-连接重用策略" class="headerlink" title="1. 连接重用策略"></a>1. 连接重用策略</h4><p>在httpClient中可以自定义连接重用的策略，定义了一个接口类ConnectionReuseStrategy：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface ConnectionReuseStrategy &#123;</div><div class="line">    boolean keepAlive(HttpResponse var1, HttpContext var2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其缺省的实现类为org.apache.http.impl.DefaultConnectionReuseStrategy:   </p>
<p><img src="/assets/images/javaclient/default_reuse_impl.png" alt="DefaultConnectionReuseStrategy"></p>
<center>Figure 1: DefaultConnectionReuseStrategy </center>   

<p>其中该类似实现了接口类的对外方法keepAlive。当然我们可以自定义一个连接重用策略：</p>
<h4 id="2-调用连接重用"><a href="#2-调用连接重用" class="headerlink" title="2. 调用连接重用"></a>2. 调用连接重用</h4><p>调用者为org.apache.http.impl.execchain.MainClientExec：</p>
<p><img src="/assets/images/javaclient/call_reuse_conn.png" alt="call_reuse_conn"></p>
<center>Figure 2: 连接重用调用过程 </center>   

<ul>
<li>如果用户没有自定义重用策略，这里会调用缺省的策略，会将connHolder设置为可重用；</li>
<li>否则设置为不可重用，解析完毕response之后就会关闭该连接;</li>
</ul>
<p>连接关闭的调用条件：    </p>
<p><img src="/assets/images/javaclient/call_release_conn.png" alt="call_release_conn"></p>
<center>Figure 3: 连接释放条件 </center> 

<p>其中内部实现如下：</p>
<p><img src="/assets/images/javaclient/release_conn_impl.png" alt="release_conn_impl"></p>
<center>Figure 4: 连接释放实现 </center> 


<h3 id="SSL-Cipher-Suite配置"><a href="#SSL-Cipher-Suite配置" class="headerlink" title="SSL Cipher Suite配置"></a>SSL Cipher Suite配置</h3><p><img src="/assets/images/javaclient/SSLConnectionSocketFactory.png" alt="SSLConnectionSocketFactory">    </p>
<center>Figure 5: SSLConnectionSocketFactory结构 </center>

<p>SSLConnectionSocketFactory类可以基于SSLSocketFactory、支持的协议、支持的密码套件进行构造：</p>
<p><img src="/assets/images/javaclient/SSLConnectionSocketFactory_code.png" alt="SSLConnectionSocketFactory Flow"></p>
<center>Figure 6: SSLConnectionSocketFactory流程 </center>

<p>其中supportCipherSuites作为自定义密码套件在握手过程中检查。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JAVA-网络相关的类、接口与异常&quot;&gt;&lt;a href=&quot;#JAVA-网络相关的类、接口与异常&quot; class=&quot;headerlink&quot; title=&quot;JAVA 网络相关的类、接口与异常&quot;&gt;&lt;/a&gt;JAVA 网络相关的类、接口与异常&lt;/h3&gt;&lt;h4 id=&quot;类&quot;&gt;&lt;a
    
    </summary>
    
      <category term="JAVA" scheme="https://skypacer210.github.io/categories/JAVA/"/>
    
    
      <category term="HTTPClient" scheme="https://skypacer210.github.io/tags/HTTPClient/"/>
    
      <category term="keep-alive" scheme="https://skypacer210.github.io/tags/keep-alive/"/>
    
      <category term="SSLConnectionSocketFactory" scheme="https://skypacer210.github.io/tags/SSLConnectionSocketFactory/"/>
    
  </entry>
  
  <entry>
    <title>云服务中的cache</title>
    <link href="https://skypacer210.github.io/2016/01/02/distribute-cache/"/>
    <id>https://skypacer210.github.io/2016/01/02/distribute-cache/</id>
    <published>2016-01-01T16:00:00.000Z</published>
    <updated>2017-09-28T15:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文由<a href="http://skypacer210.github.io/">skypacer</a>译自<a href="http://www.adampetersen.se/Patterns%20in%20C%205,%20REACTOR.pdf" target="_blank" rel="external">Patterns in C REACTOR</a>，原文作者<a href="http://www.adampetersen.se/" target="_blank" rel="external">Adam Petersen</a>。</p>
<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><hr>
<p>本篇英文原文所发布的站点<a href="http://www.adampetersen.se/" target="_blank" rel="external">Adam Petersen</a>是一个个人网站，本文翻译了其中reactor C实现章节, 水平有限，欢迎指正。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><hr>
<p>1、<a href="#mutil_client">多客户端示例</a><br>2、<a href="#single_res">单一责任原则</a><br>3、<a href="#open_closed">违反Open-Closed原则</a><br>4、<a href="#performance">从性能谈起</a><br>5、<a href="#issue_sum">问题总结</a><br>6、<a href="#reactor_pattern">REACTOR模式</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.1、<a href="#6.1">事件探测</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.2、<a href="#6.2">实现机制</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.3、<a href="#6.3">Reactor注册策略</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.4、<a href="#6.4">Reactor实现</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.5、<a href="#6.5">触发Reactor</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.6、<a href="#6.6">处理注册</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.7、<a href="#6.7">事件多样性</a><br>7、<a href="#vs">REACTOR vs OBSERVER</a><br>8、<a href="#cons">结论</a><br>9、<a href="#sum">总结</a>            </p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><hr>
<p><a id="mutil_client" name="mutil_client"> </a>  </p>
<p>本文将研究一种适用于<em>event-driven</em>应用的模式。Reactor Pattern将应用的不同职责解耦，允许应用由多个潜在的client端分离并分发事件。</p>
<h3 id="1、如何评估一个系统"><a href="#1、如何评估一个系统" class="headerlink" title="1、如何评估一个系统"></a>1、如何评估一个系统</h3><p>我们可以以单位时间内的操作次数定义性能，比如每秒请求数，每秒交易数；</p>
<p>可扩展性： 指通过增加计算资源以提高处理负载的能力，分为水平扩展和垂直扩展；</p>
<p>对于垂直扩展，我们针对单一机器本身，比如用SSD替换HDD，换个更快的CPU等，往往效果有限；<br>而水平扩展则不然，我们通过增加更多服务器将性能提升至几十倍上千倍，但同时难度也更大，需要确保数据的一致性；</p>
<p>对于WEB服务，如果我们只是单纯增加服务器数量，数据库势必很快将成为瓶颈，因此我们引入cache；</p>
<p>注：这里的数据库一般指传统的关系型数据库，支持用于完成业务逻辑的SQL；</p>
<h3 id="2、Cache"><a href="#2、Cache" class="headerlink" title="2、Cache"></a>2、Cache</h3><p>Cache的几个概念：</p>
<ul>
<li>cache Size：定义了Cache可保存元素数量；</li>
<li>命中率：返回正确结构数/请求缓存次数，越高表明缓存使用率越高；</li>
<li>cache eviction算法：即清空策略，其定义了当元素超过cache本身容量时的处理方法，比如LRU算法，将最近最少用的元素清除；</li>
<li>time-to-live: 定义了cache元素何时被清除；</li>
</ul>
<p>“多久更新，如何更新”</p>
<p><a href="http://gaofulai1988.iteye.com/blog/2255997" target="_blank" rel="external">cache</a></p>
<h4 id="2-1、Cache的分类"><a href="#2-1、Cache的分类" class="headerlink" title="2.1、Cache的分类"></a>2.1、Cache的分类</h4><p>从调用者与cache的交互方式上，我们可以分为三大类：</p>
<ul>
<li>应用层cache：首先从cache取，命中则返回；如果未能命中，则直接去取数据源本身；</li>
<li>L2 Cache,所谓的中间层cache, 调用者和ache之间隔了一层proxy, 调用者意识不到cache的存在; 当cache未能命中时，由proxy访问数据源获取数据加入cache;</li>
</ul>
<p>作为用户访问云服务的重要手段，SDK往往充当了proxy的角色，其内部加入L2 cache，可有效降低对服务本身的访问压力；</p>
<ul>
<li>混合Cache: 如果proxy和L2 Cache界限不明显，很多时候合二为一，即为混合cache</li>
</ul>
<p>从架构上划分，cache可分为本地与分布式；</p>
<ul>
<li>Local Cache：</li>
</ul>
<ul>
<li>所有元素存在本地内存，对于JAVA而言其上限即为JVM的heap大小；</li>
<li>同一进程内部，响应迅速</li>
</ul>
<p>当然其缺点也很明显，首先本次缓存与程序紧耦合，多个应用程序无法共享缓存，各应用和集群节点都必须维护自己的单独缓存，也是一种浪费；另外，为了保证多个进程间的数据一致性，程序相对不易维护；</p>
<ul>
<li>常见实现：ConcurrentHashMap，ehcache， Spring Cache</li>
</ul>
<p>其中Ehcache的缓存数据有两级：内存和磁盘，与一般的本地内存缓存相比，有了磁盘的存储空间，将可以支持更大量的数据缓存需求；</p>
<p><strong>直接实现</strong></p>
<p>a. 成员变量或局部变量实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> public void UseLocalCache()&#123;</div><div class="line">     //一个本地的缓存变量</div><div class="line">     Map&lt;String, Object&gt; localCacheStoreMap = new HashMap&lt;String, Object&gt;();</div><div class="line"></div><div class="line">    List&lt;Object&gt; infosList = this.getInfoList();</div><div class="line">    for(Object item:infosList)&#123;</div><div class="line">        if(localCacheStoreMap.containsKey(item))&#123; //缓存命中 使用缓存数据</div><div class="line">            // todo</div><div class="line">        &#125; else &#123; // 缓存未命中  IO获取数据，结果存入缓存</div><div class="line">            Object valueObject = this.getInfoFromDB();</div><div class="line">            localCacheStoreMap.put(valueObject.toString(), valueObject);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//示例</div><div class="line">private List&lt;Object&gt; getInfoList()&#123;</div><div class="line">    return new ArrayList&lt;Object&gt;();</div><div class="line">&#125;</div><div class="line">//示例数据库IO获取</div><div class="line">private Object getInfoFromDB()&#123;</div><div class="line">    return new Object();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以局部变量map结构缓存部分业务数据，减少频繁的重复数据库I/O操作。缺点仅限于类的自身作用域内，类间无法共享缓存。</p>
<p>b. 静态变量实现</p>
<p>最常用的单例实现静态资源缓存，代码示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class CityUtils &#123;</div><div class="line">      private static final HttpClient httpClient = ServerHolder.createClientWithPool(); </div><div class="line">      private static Map&lt;Integer, String&gt; cityIdNameMap = new HashMap&lt;Integer, String&gt;();</div><div class="line">      private static Map&lt;Integer, String&gt; districtIdNameMap = new HashMap&lt;Integer, String&gt;();</div><div class="line"></div><div class="line">  static &#123;</div><div class="line">    HttpGet get = new HttpGet(&quot;http://gis-in.sankuai.com/api/location/city/all&quot;);</div><div class="line">    BaseAuthorizationUtils.generateAuthAndDateHeader(get,</div><div class="line">            BaseAuthorizationUtils.CLIENT_TO_REQUEST_MDC,</div><div class="line">            BaseAuthorizationUtils.SECRET_TO_REQUEST_MDC);</div><div class="line">    try &#123;</div><div class="line">        String resultStr = httpClient.execute(get, new BasicResponseHandler());</div><div class="line">        JSONObject resultJo = new JSONObject(resultStr);</div><div class="line">        JSONArray dataJa = resultJo.getJSONArray(&quot;data&quot;);</div><div class="line">        for (int i = 0; i &lt; dataJa.length(); i++) &#123;</div><div class="line">            JSONObject itemJo = dataJa.getJSONObject(i);</div><div class="line">            cityIdNameMap.put(itemJo.getInt(&quot;id&quot;), itemJo.getString(&quot;name&quot;));</div><div class="line">        &#125;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        throw new RuntimeException(&quot;Init City List Error!&quot;, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    static &#123;</div><div class="line">    HttpGet get = new HttpGet(&quot;http://gis-in.sankuai.com/api/location/district/all&quot;);</div><div class="line">    BaseAuthorizationUtils.generateAuthAndDateHeader(get,</div><div class="line">            BaseAuthorizationUtils.CLIENT_TO_REQUEST_MDC,</div><div class="line">            BaseAuthorizationUtils.SECRET_TO_REQUEST_MDC);</div><div class="line">    try &#123;</div><div class="line">        String resultStr = httpClient.execute(get, new BasicResponseHandler());</div><div class="line">        JSONObject resultJo = new JSONObject(resultStr);</div><div class="line">        JSONArray dataJa = resultJo.getJSONArray(&quot;data&quot;);</div><div class="line">        for (int i = 0; i &lt; dataJa.length(); i++) &#123;</div><div class="line">            JSONObject itemJo = dataJa.getJSONObject(i);</div><div class="line">            districtIdNameMap.put(itemJo.getInt(&quot;id&quot;), itemJo.getString(&quot;name&quot;));</div><div class="line">        &#125;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        throw new RuntimeException(&quot;Init District List Error!&quot;, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    public static String getCityName(int cityId) &#123;</div><div class="line">      String name = cityIdNameMap.get(cityId);</div><div class="line">      if (name == null) &#123;</div><div class="line">        name = &quot;未知&quot;;</div><div class="line">      &#125;</div><div class="line">       return name;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">    public static String getDistrictName(int districtId) &#123;</div><div class="line">      String name = districtIdNameMap.get(districtId);</div><div class="line">       if (name == null) &#123;</div><div class="line">         name = &quot;未知&quot;;</div><div class="line">        &#125;</div><div class="line">       return name;</div><div class="line">     &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>O2O业务中常用的城市基础基本信息判断，通过静态变量一次获取缓存内存中，减少频繁的I/O读取，静态变量实现类间可共享，进程内可共享，缓存的实时性稍差。为了解决本地缓存数据的实时性问题，目前大量使用的是结合ZooKeeper的自动发现机制，实时变更本地静态变量缓存：</p>
<p>TODO:实际项目：相对静态数据，比如元数据可以基于本次cache加速，</p>
<p>美团点评内部的基础配置组件MtConfig，采用的就是类似原理，使用静态变量缓存，结合ZooKeeper的统一管理，做到自动动态更新缓存，如图2所示。<br><a href="https://tech.meituan.com/cache_about.html" target="_blank" rel="external">美团</a></p>
<p>TODO1：根据期望到货时间排序通知，需要考虑加入本地cache, <a href="https://redislabs.com/ebook/part-2-core-concepts/chapter-8-building-a-simple-social-network/8-1-users-and-statuses/8-1-2-status-messages/" target="_blank" rel="external">EBOOK – REDIS IN ACTION
</a></p>
<p>TODO2: Pub/Sub：在更新中保持用户对数据的映射是系统中的一个普遍任务。Redis的pub/sub功能使用了SUBSCRIBE、UNSUBSCRIBE和PUBLISH命令，让这个变得更加容易。到货通知</p>
<p><a href="https://cruftex.net/2016/03/16/Java-Caching-Benchmarks-2016-Part-1.html" target="_blank" rel="external">Java Cache Benchmark</a><br><a href="http://www.jianshu.com/p/49fc4065201a" target="_blank" rel="external">sping cache</a></p>
<ul>
<li>分布式cache特点：</li>
</ul>
<ul>
<li>cache元素分布在集群的不同的服务器中；</li>
<li>Cache size为每个cache分片之和，可以远远大于单台JVM可保存的cache数量；</li>
<li>cache可水平扩展</li>
</ul>
<p>目前的实现memcached、redis和tair;</p>
<p><a href="http://blog.sina.com.cn/s/blog_6145ed810102vefe.html" target="_blank" rel="external">分布式cache性能对比</a><br><a href="https://github.com/JamzyWang/awesome-redis" target="_blank" rel="external">redis</a><br><a href="https://www.ibm.com/developerworks/library/j-ts1/index.html" target="_blank" rel="external">Understanding transaction pitfalls</a><br><a href="https://gitee.com/shentong_012/YayCrawler/tree/master" target="_blank" rel="external">网络爬虫</a><br><a href="https://nickcraver.com/blog/2016/02/17/stack-overflow-the-architecture-2016-edition/" target="_blank" rel="external">stakcoveflow架构</a></p>
<h4 id="2-2、供应链的Cache"><a href="#2-2、供应链的Cache" class="headerlink" title="2.2、供应链的Cache"></a>2.2、供应链的Cache</h4><p><strong>Global Cache</strong>      </p>
<p><img src="/assets/images/global_cache_2.png" alt="图片">  </p>
<center>Figure 1: eternal loop to scan for different events</center>

<p>网络拓扑同步用到了global cache，流程：</p>
<ul>
<li>sync服务</li>
</ul>
<p><a id="mutil_client" name="mutil_client"> </a>    </p>
<h3 id="2、SDL流程"><a href="#2、SDL流程" class="headerlink" title="2、SDL流程"></a>2、SDL流程</h3><p><a id="single_res" name="single_res"> </a></p>
<p>Secure Software and Secure Development Tools</p>
<p><img src="/assets/images/sdl_flow.png" alt="SDL"></p>
<ul>
<li>安全本身就是设计需求：尽可能早的考虑安全和合规；</li>
<li>攻击面分析：基于最小权限和分层防护；</li>
<li>利用威胁模型：面对威胁场景，利用结构化的方法帮助团队更有效的识别安全薄弱环节、以及应对策略，建立合适的迁移方案；</li>
</ul>
<p>手段：</p>
<p><a href="http://findbugs.sourceforge.net/" target="_blank" rel="external">findbugs</a><br><a href="https://www.klocwork.com/" target="_blank" rel="external">kclowork</a></p>
<ul>
<li>静态扫描工具： C版本的Klocwork，静态代码分析，内存泄露等，开源审计；JAVA的findbugs</li>
</ul>
<p>其中JAVA的静态扫描示例：</p>
<p><img src="/assets/images/findbug_java.png" alt="findbug"></p>
<h3 id="3、Redis"><a href="#3、Redis" class="headerlink" title="3、Redis"></a>3、Redis</h3><p><a id="open_closed" name="open_closed"> </a>  </p>
<p>Redis基于TCL编写测试框架；</p>
<h3 id="4、mybatis支持缓存"><a href="#4、mybatis支持缓存" class="headerlink" title="4、mybatis支持缓存"></a>4、mybatis支持缓存</h3><p><a id="performance" name="performance"> </a>  </p>
<p><a href="https://www.zhihu.com/question/22696632/answer/136316871" target="_blank" rel="external">碎片化阅读</a>  </p>
<p><a href="https://my.oschina.net/KingPan/blog/277424" target="_blank" rel="external">mybatis错误</a></p>
<ul>
<li>二八原则为知识体系构建；</li>
<li>看书做笔记，零碎记录，再加工为文章；</li>
<li>讲给别人听，熟练到改变了大脑，你才不会遗忘。</li>
</ul>
<h3 id="5、数据库缓存支持"><a href="#5、数据库缓存支持" class="headerlink" title="5、数据库缓存支持"></a>5、数据库缓存支持</h3><p><a id="issue_sum" name="issue_sum"> </a>  </p>
<h4 id="5-1-spring支持缓存"><a href="#5-1-spring支持缓存" class="headerlink" title="5.1 spring支持缓存"></a>5.1 spring支持缓存</h4><p><a href="http://blog.didispace.com/springbootcache1/" target="_blank" rel="external">Spring Boot中的缓存支持（一）注解配置与EhCache使用</a></p>
<h4 id="5-2-mybatis支持缓存"><a href="#5-2-mybatis支持缓存" class="headerlink" title="5.2 mybatis支持缓存"></a>5.2 mybatis支持缓存</h4><ol>
<li>前提</li>
</ol>
<p>多数 ide 会提示声明一个静态常量 serialVersionUID(版本标识), 类已经序列化，serialVersionUID是JAVA的序列化过程中用于标识和识别序列化类的；</p>
<p>Serializable 则是应用于Java 对象序列化/反序列化, 作用：</p>
<ul>
<li>用于网络传输；</li>
<li>用于本地磁盘保存；</li>
</ul>
<p><a href="https://github.com/giantray/stackoverflow-java-top-qa/blob/master/contents/what-is-a-serialversionuid-and-why-should-i-use-it.md" target="_blank" rel="external">序列化</a></p>
<ol>
<li>MyBatis配置：二级缓存</li>
</ol>
<ul>
<li>全局配置变量参数   cacheEnabled=true</li>
<li>该select语句所在的Mapper，配置了<cache> 或<cached-ref>节点，并且有效</cached-ref></cache></li>
<li>该select语句的参数 useCache=true</li>
</ul>
<ol>
<li>MyBatis配置：第三方缓存</li>
</ol>
<ul>
<li>Ehcache</li>
</ul>
<p>框架实现：</p>
<p><img src="/assets/images/distribute_cache/mybatis_cache_whole.jpg" alt="mybatis_cache_whole"></p>
<p><a href="http://blog.csdn.net/luanlouis/article/details/41408341" target="_blank" rel="external">framwork</a></p>
<p>调用过程分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">&quot;pool-7-thread-29@12768&quot; prio=5 tid=0x88 nid=NA runnable</div><div class="line">  java.lang.Thread.State: RUNNABLE</div><div class="line">	  at java.net.SocketInputStream.socketRead0(SocketInputStream.java:-1)</div><div class="line">	  at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</div><div class="line">	  at java.net.SocketInputStream.read(SocketInputStream.java:170)</div><div class="line">	  at java.net.SocketInputStream.read(SocketInputStream.java:141)</div><div class="line">	  at com.mysql.jdbc.util.ReadAheadInputStream.fill(ReadAheadInputStream.java:112)</div><div class="line">	  at com.mysql.jdbc.util.ReadAheadInputStream.readFromUnderlyingStreamIfNecessary(ReadAheadInputStream.java:159)</div><div class="line">	  at com.mysql.jdbc.util.ReadAheadInputStream.read(ReadAheadInputStream.java:187)</div><div class="line">	  - locked &lt;0x4125&gt; (a com.mysql.jdbc.util.ReadAheadInputStream)</div><div class="line">	  at com.mysql.jdbc.MysqlIO.readFully(MysqlIO.java:3158)</div><div class="line">	  at com.mysql.jdbc.MysqlIO.reuseAndReadPacket(MysqlIO.java:3615)</div><div class="line">	  at com.mysql.jdbc.MysqlIO.reuseAndReadPacket(MysqlIO.java:3604)</div><div class="line">	  at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:4155)</div><div class="line">	  at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:2615)</div><div class="line">	  at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2776)</div><div class="line">	  at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2838)</div><div class="line">	  - locked &lt;0x4126&gt; (a com.mysql.jdbc.JDBC4Connection)</div><div class="line">	  at com.mysql.jdbc.PreparedStatement.executeInternal(PreparedStatement.java:2082)</div><div class="line">	  at com.mysql.jdbc.PreparedStatement.execute(PreparedStatement.java:1307)</div><div class="line">	  at com.alibaba.druid.filter.FilterChainImpl.preparedStatement_execute(FilterChainImpl.java:2931)</div><div class="line">	  at com.alibaba.druid.filter.FilterEventAdapter.preparedStatement_execute(FilterEventAdapter.java:440)</div><div class="line">	  at com.alibaba.druid.filter.FilterChainImpl.preparedStatement_execute(FilterChainImpl.java:2929)</div><div class="line">	  at com.alibaba.druid.wall.WallFilter.preparedStatement_execute(WallFilter.java:600)</div><div class="line">	  at com.alibaba.druid.filter.FilterChainImpl.preparedStatement_execute(FilterChainImpl.java:2929)</div><div class="line">	  at com.alibaba.druid.filter.FilterEventAdapter.preparedStatement_execute(FilterEventAdapter.java:440)</div><div class="line">	  at com.alibaba.druid.filter.FilterChainImpl.preparedStatement_execute(FilterChainImpl.java:2929)</div><div class="line">	  at com.alibaba.druid.proxy.jdbc.PreparedStatementProxyImpl.execute(PreparedStatementProxyImpl.java:131)</div><div class="line">	  at com.alibaba.druid.pool.DruidPooledPreparedStatement.execute(DruidPooledPreparedStatement.java:493)</div><div class="line">	  at sun.reflect.GeneratedMethodAccessor81.invoke(Unknown Source:-1)</div><div class="line">	  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">	  at java.lang.reflect.Method.invoke(Method.java:497)</div><div class="line">	  at org.apache.ibatis.logging.jdbc.PreparedStatementLogger.invoke(PreparedStatementLogger.java:59)</div><div class="line">	  at com.sun.proxy.$Proxy189.execute(Unknown Source:-1)</div><div class="line">	  at org.apache.ibatis.executor.statement.PreparedStatementHandler.query(PreparedStatementHandler.java:63)</div><div class="line">	  at org.apache.ibatis.executor.statement.RoutingStatementHandler.query(RoutingStatementHandler.java:79)</div><div class="line">	  at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:63)</div><div class="line">	  at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:324)</div><div class="line">	  at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156)</div><div class="line">	  at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109)</div><div class="line">	  at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83)</div><div class="line">	  at sun.reflect.GeneratedMethodAccessor79.invoke(Unknown Source:-1)</div><div class="line">	  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">	  at java.lang.reflect.Method.invoke(Method.java:497)</div><div class="line">	  at org.apache.ibatis.plugin.Invocation.proceed(Invocation.java:49)</div><div class="line">	  at com.github.pagehelper.SqlUtil._processPage(SqlUtil.java:401)</div><div class="line">	  at com.github.pagehelper.SqlUtil.processPage(SqlUtil.java:374)</div><div class="line">	  at com.github.pagehelper.PageHelper.intercept(PageHelper.java:255)</div><div class="line">	  at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:61)</div><div class="line">	  at com.sun.proxy.$Proxy187.query(Unknown Source:-1)</div><div class="line">	  at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148)</div><div class="line">	  at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141)</div><div class="line">	  at sun.reflect.GeneratedMethodAccessor300.invoke(Unknown Source:-1)</div><div class="line">	  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">	  at java.lang.reflect.Method.invoke(Method.java:497)</div><div class="line">	  at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:434)</div><div class="line">	  at com.sun.proxy.$Proxy101.selectList(Unknown Source:-1)</div><div class="line">	  at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:231)</div><div class="line">	  at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:137)</div><div class="line">	  at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:75)</div><div class="line">	  at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:53)</div><div class="line">	  at com.sun.proxy.$Proxy164.queryPlanClusterCodeByCondition(Unknown Source:-1)</div><div class="line">	  at com.aliyun.supplychain.services.impl.SyncDataUtil.queryPlanClusterCode(SyncDataUtil.java:759)</div><div class="line">	  at com.aliyun.supplychain.services.impl.SyncDataUtil$$FastClassBySpringCGLIB$$1788316e.invoke(&lt;generated&gt;:-1)</div><div class="line">	  at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)</div><div class="line">	  at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:720)</div><div class="line">	  at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)</div><div class="line">	  at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:85)</div><div class="line">	  at com.aliyun.supplychain.filter.LogRecordAspect.methodAround(LogRecordAspect.java:124)</div><div class="line">	  at sun.reflect.GeneratedMethodAccessor77.invoke(Unknown Source:-1)</div><div class="line">	  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">	  at java.lang.reflect.Method.invoke(Method.java:497)</div><div class="line">	  at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:621)</div><div class="line">	  at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:610)</div><div class="line">	  at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:68)</div><div class="line">	  at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</div><div class="line">	  at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)</div><div class="line">	  at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</div><div class="line">	  at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:655)</div><div class="line">	  at com.aliyun.supplychain.services.impl.SyncDataUtil$$EnhancerBySpringCGLIB$$b746d32b.queryPlanClusterCode(&lt;generated&gt;:-1)</div><div class="line">	  at com.aliyun.supplychain.synchroizerV3.RDSSynchroizer.buildResourceInventoryList(RDSSynchroizer.java:130)</div><div class="line">	  at</div></pre></td></tr></table></figure>
<p><img src="/assets/images/distribute_cache/mybatis_cache_1.png" alt="distribute_cache"></p>
<p>其中cache执行器CacheingExecutor, 如果配置了使用cache的标志(在mapper.xml中)，直接从cache中获取;</p>
<h4 id="5-3-Spring-Boot-整合-Redis-实现缓存操作"><a href="#5-3-Spring-Boot-整合-Redis-实现缓存操作" class="headerlink" title="5.3 Spring Boot 整合 Redis 实现缓存操作"></a>5.3 Spring Boot 整合 Redis 实现缓存操作</h4><p><a href="http://www.bysocket.com/?p=1756" target="_blank" rel="external">redis</a></p>
<h3 id="6、消息队列"><a href="#6、消息队列" class="headerlink" title="6、消息队列"></a>6、消息队列</h3><p><a id="reactor_pattern" name="reactor_pattern"> </a>  </p>
<p>用途：解耦调用方和被调用方</p>
<p>TODO：</p>
<ul>
<li>定时任务修改为通知，你完了通知为，我继续</li>
<li>从</li>
</ul>
<p><img src="/assets/images/reactor_figure_2.png" alt="图片"></p>
<center>Figure 2: Structure of the REACTOR pattern</center>   


<h4 id="6-1、事件探测"><a href="#6-1、事件探测" class="headerlink" title="6.1、事件探测"></a>6.1、事件探测</h4><p><a id="6.1" name="6.1"> </a>  </p>
<p>在一些文献中关于 <strong>reactor</strong> 的描述中，定义了一个工具，即 <strong>synchronous Event Demultiplexer </strong>， 该分离器由 <strong>reactor</strong> 调用等待已经注册的 <strong>Handles</strong> 的事件。 </p>
<p>该事件分离器一般由操作系统提供，比如 <em>poll()</em> ，<em>select()</em> 和 <em>WaitForMutipleObjects()</em> 。</p>
<h4 id="6-2、实现机制"><a href="#6-2、实现机制" class="headerlink" title="6.2、实现机制"></a>6.2、实现机制</h4><p><a id="6.2" name="6.2"> </a>    </p>
<p><strong>EventHandler</strong> 和 <strong>Reactor</strong> 之间的合作关系类似OBSERVER模式中的observer和它的对象。    </p>
<p>为了将Reactor和它的事件处理器解耦，同时Reactor仍能够通知到他们，每个具体的事件处理器必须关联一个唯一的instance。这里的C实现中，采用void <em>作为通用类型以描述 <em>*EventHandler</em></em> 接口。  </p>
<ul>
<li>事件处理接口：EventHandler.h  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">14 #ifndef EVENT_HANDLER_H</div><div class="line">15 #define EVENT_HANDLER_H</div><div class="line">16 </div><div class="line">17 #include &quot;Handle.h&quot;</div><div class="line">18 </div><div class="line">19 /* All interaction from Reactor to an event handler goes </div><div class="line">20 through function pointers with the following signatures: */</div><div class="line">21 typedef Handle (*getHandleFunc)(void *instance);</div><div class="line">22 typedef void (*handleEventFunc)(void *instance);</div><div class="line">23 </div><div class="line">24 typedef struct &#123;</div><div class="line">25 .       void *instance;</div><div class="line">26 .       getHandleFunc getHandle;</div><div class="line">27 .       handleEventFunc handleEvent;</div><div class="line">28 &#125; EventHandler;</div><div class="line">29 </div><div class="line">30 #endif</div></pre></td></tr></table></figure>
<h3 id="8、MVC测试与cookie"><a href="#8、MVC测试与cookie" class="headerlink" title="8、MVC测试与cookie"></a>8、MVC测试与cookie</h3><p><a id="cons" name="cons"> </a>  </p>
<p><a href="https://stackoverflow.com/questions/36600817/spring-mvc-testing-security-integration-test-jsessionid-is-not-present" target="_blank" rel="external">Cookie</a><br><a href="https://stackoverflow.com/questions/26142631/why-does-spring-mockmvc-result-not-contain-a-cookie/26281932#26281932" target="_blank" rel="external">cookie2</a></p>
<p>应用REACTOR模式的主要结论如下：  </p>
<ul>
<li>遵循single-responsibility原则的好处：采用REACTOR模式，每种责任被封装并相互之间解耦，导致高内聚，因此简化了后续维护。比如在事件探测中平台相关的代码可以从应用中解耦，极大的方便了单元测试。  </li>
<li>遵循open-closed原则的好处：新的责任只需创建新的事件处理器，无需影响现有代码。  </li>
<li>统一了事件处理：尽管REACTOR模式集中于句柄，但其可以扩展至其他任务。Reactor加入timer支持（平台相关，比如基于信号或者线程），当同步事件分离器触发后可以设定一个超时，以避免重入问题和竞争条件。  </li>
<li>提供了一种并行读的方案：采用REACTOR方案可以有效避免并行读事件处理中的阻塞现象，其本质是一个非抢占式的多任务模型，每个具体的事件处理器必须确保其不能执行可能导致其余事件处理器饥饿的操作。  </li>
<li>类型安全的折中：由于所有的事件处理器抽象为void *，当由void指针转化为具体的事件处理指针时，编译器并没有相应的机制处理转化错误。同样的问题在OBSERVER模式中也存在，解决方法都是一致的：为不同类型的事件处理器定义单独的通知函数，利用EventHandler绑定事件处理器和其他函数。  </li>
</ul>
<h3 id="8、前台后台分离"><a href="#8、前台后台分离" class="headerlink" title="8、前台后台分离"></a>8、前台后台分离</h3><p>对于类似订单中心的多Key类业务，在数据量较大，需要对数据库进行水平切分时，对于后台需求，采用“前台后台分离”的架构设计方法：</p>
<ul>
<li>前台、后台系统web/serveive/db分离解耦，避免后台低效查询引发前台查询抖动；</li>
<li>采用前台与后台数据冗余的设计，分别满足两侧需求，比如在tboss_data中增加了产品等；</li>
<li>采用外置索引(例如ES搜索系统)或者大数据处理(例如HIVE)来满足后台变态的查询需求；</li>
</ul>
<h3 id="9-ereka-loadbanlacner"><a href="#9-ereka-loadbanlacner" class="headerlink" title="9. ereka loadbanlacner"></a>9. ereka loadbanlacner</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2017-09-01 23:25:38.281  INFO 32439 --- [nio-8001-exec-7] c.n.l.DynamicServerListLoadBalancer      : DynamicServerListLoadBalancer for client supplychain-purchase initialized: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=supplychain-purchase,current list of Servers=[10.125.31.73:7001, 10.125.30.240:7001],Load balancer stats=Zone stats: &#123;defaultzone=[Zone:defaultzone;	Instance count:2;	Active connections count: 0;	Circuit breaker tripped count: 0;	Active connections per server: 0.0;]</div><div class="line">&#125;,Server stats: [[Server:10.125.31.73:7001;	Zone:defaultZone;	Total Requests:0;	Successive connection failure:0;	Total blackout seconds:0;	Last connection made:Thu Jan 01 08:00:00 CST 1970;	First connection made: Thu Jan 01 08:00:00 CST 1970;	Active Connections:0;	total failure count in last (1000) msecs:0;	average resp time:0.0;	90 percentile resp time:0.0;	95 percentile resp time:0.0;	min resp time:0.0;	max resp time:0.0;	stddev resp time:0.0]</div><div class="line">, [Server:10.125.30.240:7001;	Zone:defaultZone;	Total Requests:0;	Successive connection failure:0;	Total blackout seconds:0;	Last connection made:Thu Jan 01 08:00:00 CST 1970;	First connection made: Thu Jan 01 08:00:00 CST 1970;	Active Connections:0;	total failure count in last (1000) msecs:0;	average resp time:0.0;	90 percentile resp time:0.0;	95 percentile resp time:0.0;	min resp time:0.0;	max resp time:0.0;	stddev resp time:0.0]</div><div class="line">]&#125;ServerList:org.springframework.cloud.netflix.ribbon.eureka.DomainExtractingServerList@d60df1</div></pre></td></tr></table></figure>
<h3 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h3><p><a id="sum" name="sum"> </a>  </p>
<p>Reactor模式通过对不同责任的解耦和不同模块的封装简化了事件驱动型应用的设计。关于该模式更多的讨论可以参考面向对象的软件模式卷2。      </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文由&lt;a href=&quot;http://skypacer210.github.io/&quot;&gt;skypacer&lt;/a&gt;译自&lt;a href=&quot;http://www.adampetersen.se/Patterns%20in%20C%205,%20REACTOR.pdf&quot; target
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="design pattern" scheme="https://skypacer210.github.io/tags/design-pattern/"/>
    
      <category term="reactor" scheme="https://skypacer210.github.io/tags/reactor/"/>
    
  </entry>
  
  <entry>
    <title>Go Concurrency Part1: Producer and Consumer</title>
    <link href="https://skypacer210.github.io/2015/08/25/Go-Concurrency-Part1/"/>
    <id>https://skypacer210.github.io/2015/08/25/Go-Concurrency-Part1/</id>
    <published>2015-08-24T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><div style="text-align:center" markdown="1"><br><img src="/assets/images/Mexican_Standoff.jpg" alt="三个火枪手"></div></p>
<p>生产者-消费者模式即所谓的Fan-in设计模式，这里建立两个channel，一个由多个生产者将生产的数据写入；另外一个由一个消费者读出。</p>
<p>线程同步由主线程借助两个channel完成，其本质是利用了阻塞实现同步。</p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>一个大loop将每个新的i值循环写入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> 8 func producer(ch chan int, d time.Duration) &#123;</div><div class="line"> 9     var i int</div><div class="line">10</div><div class="line">11     for &#123;</div><div class="line">12         ch &lt;- i</div><div class="line">13         i++</div><div class="line">14         fmt.Printf(&quot;Producer(GID:%v) i:%v\n&quot;, GetGID(), i)</div><div class="line">15         time.Sleep(d)</div><div class="line">16     &#125;</div><div class="line">17 &#125;</div></pre></td></tr></table></figure>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">19 func reader(out chan int) &#123;</div><div class="line">20     for x := range out &#123;</div><div class="line">21         fmt.Printf(&quot;Reader(GID:%v) i:%v\n&quot;, GetGID(), x)</div><div class="line">22     &#125;</div><div class="line">23 &#125;</div></pre></td></tr></table></figure>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>从写入channel rang loop的读取，塞入输出channel。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">34     //multiplex by main thread range loop</div><div class="line">35     for i := range ch &#123;</div><div class="line">36         out &lt;- i</div><div class="line">37     &#125;</div></pre></td></tr></table></figure>
<p>这里利用了阻塞channel的特性：如果读取不到则阻塞，可以加入超时。</p>
<h2 id="死锁的产生"><a href="#死锁的产生" class="headerlink" title="死锁的产生"></a>死锁的产生</h2><p>现象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fatal error: all goroutines are asleep - deadlock!</div></pre></td></tr></table></figure>
<h3 id="死锁原因1：线程都在接收导致的死锁"><a href="#死锁原因1：线程都在接收导致的死锁" class="headerlink" title="死锁原因1：线程都在接收导致的死锁"></a>死锁原因1：线程都在接收导致的死锁</h3><p>将生产者的loop变成有限次执行后退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> 8 func producerReceiveDeadLock(ch chan int, d time.Duration) &#123;</div><div class="line"> 9     var i int</div><div class="line">10</div><div class="line">11     for i &lt; 10 &#123;</div><div class="line">12         ch &lt;- i</div><div class="line">13         i++</div><div class="line">14         fmt.Printf(&quot;Producer(GID:%v) i:%v\n&quot;, GetGID(), i)</div><div class="line">15         time.Sleep(d)</div><div class="line">16     &#125;</div><div class="line">17 &#125;</div></pre></td></tr></table></figure>
<p>将会导致main线程和reader线程阻塞:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Producer(GID:18) i:10</div><div class="line">Producer(GID:19) i:10</div><div class="line">Reader(GID:17) i:9</div><div class="line">Reader(GID:17) i:9</div><div class="line">fatal error: all goroutines are asleep - deadlock!</div><div class="line"></div><div class="line">goroutine 1 [chan receive]:</div><div class="line">main.main()</div><div class="line">	/Users/fyang/work/concurrency_example/LeakDetect/fanin.go:35 +0xfe</div><div class="line"></div><div class="line">goroutine 17 [chan receive]:</div><div class="line">main.reader(0x82026c060)</div><div class="line">	/Users/fyang/work/concurrency_example/LeakDetect/fanin.go:20 +0x72</div><div class="line">created by main.main</div><div class="line">	/Users/fyang/work/concurrency_example/LeakDetect/fanin.go:29 +0x7a</div><div class="line">exit status 2</div></pre></td></tr></table></figure>
<ul>
<li>Step1: 由于producer线程退出，ch没有人给写入数据，此时为空；</li>
<li>Step2: 此时线程<strong>goroutine 1</strong>从ch中尝试读取数据，发现读不到，因此阻塞在该channel上,该线程ID为1，即main线程,导致out中无法写入数据，此时为0：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">35     for i := range ch &#123;</div></pre></td></tr></table></figure>
<ul>
<li>Step3：而读线程<strong>goroutine 17</strong>不知情(该线程由main创建，ID为17)，仍从out读取数据，导致reader最终也处于了阻塞状态。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">20     for x := range out &#123;</div></pre></td></tr></table></figure>
<h3 id="死锁原因2：线程都在发送导致的死锁"><a href="#死锁原因2：线程都在发送导致的死锁" class="headerlink" title="死锁原因2：线程都在发送导致的死锁"></a>死锁原因2：线程都在发送导致的死锁</h3><p>将消费者行为改为对数据不做消费：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">38 //When reader donothing, out channel keep blocking</div><div class="line">39 func readerSendDeadLock(out chan int) &#123;</div><div class="line">40 &#125;</div></pre></td></tr></table></figure>
<p>导致多个线程都往channel中写数据，这里channel是不一致的（可以一致）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Producer(GID:6) i:1</div><div class="line">fatal error: all goroutines are asleep - deadlock!</div><div class="line"></div><div class="line">goroutine 1 [chan send]:</div><div class="line">main.main()</div><div class="line">	/Users/fyang/work/concurrency_example/LeakDetect/fanin.go:54 +0x1ed</div><div class="line"></div><div class="line">goroutine 5 [chan send]:</div><div class="line">main.producer(0x82020e0c0, 0x5f5e100)</div><div class="line">	/Users/fyang/work/concurrency_example/LeakDetect/fanin.go:13 +0x7b</div><div class="line">created by main.main</div><div class="line">	/Users/fyang/work/concurrency_example/LeakDetect/fanin.go:49 +0x15a</div><div class="line"></div><div class="line">goroutine 6 [chan send]:</div><div class="line">main.producer(0x82020e0c0, 0x5f5e100)</div><div class="line">	/Users/fyang/work/concurrency_example/LeakDetect/fanin.go:13 +0x7b</div><div class="line">created by main.main</div><div class="line">	/Users/fyang/work/concurrency_example/LeakDetect/fanin.go:50 +0x185</div><div class="line">exit status 2</div></pre></td></tr></table></figure>
<ul>
<li>Step1: producer生产一个数据，塞入ch；</li>
<li>Step2：线程<strong>goroutine 1</strong>为main线程， 从ch中拿走一个，往out中写数据：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">54         out &lt;- i</div></pre></td></tr></table></figure>
<p>out无人消费，导致写了一个就已经满了，因此阻塞。</p>
<ul>
<li>Step3：线程<strong>goroutine 5</strong>为producer1和线程<strong>goroutine 6</strong>此时仍在往ch中写数据：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">13         ch &lt;- i</div></pre></td></tr></table></figure>
<p>发现ch数据没有被消费，写不进去而阻塞。</p>
<h2 id="如何通知退出循环"><a href="#如何通知退出循环" class="headerlink" title="如何通知退出循环"></a>如何通知退出循环</h2><p>Close行为与loop之间通过s.closing</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type sub struct &#123;</div><div class="line">	closing chan chan error	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>服务的Loop循环监听该channel的请求</li>
<li>client往channel发送一个请求：退出和响应该error</li>
<li>差点</li>
</ul>
<p>通过一个channel发送消息给待关闭的thread，将channel类型设置为channel，这样loop可以将错误的原因发送过来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">func (s *sub) Close() error &#123;</div><div class="line">	errc := make(chan error)	//创建一个无缓冲channel，开始是空的</div><div class="line">	s.closing &lt;- errc //向s.closing这个channel发送一个errc(该channel的类型为chanel error)</div><div class="line">	return &lt;-errc	//如果没有收到消息，此时close的调用者阻塞在这里，等待从errc中取出该错误类型并返回。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Loop的处理：取走error并退出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var err error //获取失败的时候，设置该error</div><div class="line"></div><div class="line">for &#123;</div><div class="line">	select &#123;</div><div class="line">	case errc := &lt;-s.closing：	//从中取出一个消息</div><div class="line">		errc &lt;- err	//将错误消息塞入该通知性质的channel</div><div class="line">		close(s.updates) //告诉receviver我们done</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="select-和-nil-channel"><a href="#select-和-nil-channel" class="headerlink" title="select 和 nil channel"></a>select 和 nil channel</h3><p>对于nil channel，无论发送与接收操作都会阻塞；<br>select永远不会选择一个阻塞的case.</p>
<p>nil channel与空channle的区别：？</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> 1 package main</div><div class="line">  2</div><div class="line">  3 import (</div><div class="line">  4     &quot;fmt&quot;</div><div class="line">  5     &quot;runtime&quot;</div><div class="line">  6     &quot;time&quot;</div><div class="line">  7 )</div><div class="line">  8</div><div class="line">  9 func producer(ch chan int, d time.Duration) &#123;</div><div class="line"> 10     var i int</div><div class="line"> 11</div><div class="line"> 12     for &#123;</div><div class="line"> 13         ch &lt;- i</div><div class="line"> 14         i++</div><div class="line"> 15         fmt.Printf(&quot;Producer(GID:%v) i:%v\n&quot;, GetGID(), i)</div><div class="line"> 16         time.Sleep(d)</div><div class="line"> 17     &#125;</div><div class="line"> 18 &#125;</div><div class="line"> 19</div><div class="line"> 20 //When producer thread quit, ch empty and block readers(reader and main)</div><div class="line"> 21 func producerReceiveDeadLock(ch chan int, d time.Duration) &#123;</div><div class="line"> 22     var i int</div><div class="line"> 23</div><div class="line"> 24     for i &lt; 10 &#123;</div><div class="line"> 25         ch &lt;- i</div><div class="line"> 26         i++</div><div class="line"> 27         fmt.Printf(&quot;Producer(GID:%v) i:%v\n&quot;, GetGID(), i)</div><div class="line"> 28         time.Sleep(d)</div><div class="line"> 29     &#125;</div><div class="line"> 30 &#125;</div><div class="line"> 31</div><div class="line"> 32 func reader(out chan int) &#123;</div><div class="line"> 33     for x := range out &#123;</div><div class="line"> 34         fmt.Printf(&quot;Reader(GID:%v) i:%v\n&quot;, GetGID(), x)</div><div class="line"> 35     &#125;</div><div class="line"> 36 &#125;</div><div class="line"> 37</div><div class="line">38 //When reader donothing, out channel keep blocking</div><div class="line"> 39 func readerSendDeadLock(out chan int) &#123;</div><div class="line"> 40 &#125;</div><div class="line"> 41</div><div class="line"> 42 //TODO: add timeout for reader</div><div class="line"> 43 func readerTimeout(out chan int) &#123;</div><div class="line"> 44     for &#123;</div><div class="line"> 45         select &#123;</div><div class="line"> 46         case x := &lt;-out:</div><div class="line"> 47             fmt.Printf(&quot;Reader(GID:%v) i:%v\n&quot;, GetGID(), x)</div><div class="line"> 48         case &lt;-time.After(2 * time.Second):</div><div class="line"> 49             fmt.Printf(&quot;Reader(GID:%v) timeout\n&quot;, GetGID())</div><div class="line"> 50             break</div><div class="line"> 51         &#125;</div><div class="line"> 52         fmt.Printf(&quot;Reader(GID:%v) will sleep %s and retry\n&quot;, GetGID(), 1*time.Second)</div><div class="line"> 53         time.Sleep(1 * time.Second)</div><div class="line"> 54     &#125;</div><div class="line"> 55 &#125;</div><div class="line"> 56</div><div class="line"> 57 func main() &#123;</div><div class="line"> 58     fmt.Println(runtime.NumGoroutine())</div><div class="line"> 59     ch := make(chan int)</div><div class="line"> 60     out := make(chan int)</div><div class="line"> 61     fmt.Printf(&quot;InLen:%v OutLen:%v\n&quot;, len(ch), len(out))</div><div class="line"> 62</div><div class="line"> 63     go reader(out)</div><div class="line"> 64     //go readerSendDeadLock(out)</div><div class="line"> 65     //go readerTimeout(out)</div><div class="line"> 66</div><div class="line"> 67     go producer(ch, 100*time.Millisecond)</div><div class="line"> 68     go producer(ch, 100*time.Millisecond)</div><div class="line"> 69     //go producerReceiveDeadLock(ch, 100*time.Millisecond)</div><div class="line"> 70     //go producerReceiveDeadLock(ch, 100*time.Millisecond)</div><div class="line"> 71</div><div class="line"> 72     //multiplex by main thread range loop</div><div class="line"> 73     for i := range ch &#123;</div><div class="line"> 74         out &lt;- i</div><div class="line"> 75     &#125;</div><div class="line"> 76</div><div class="line"> 77     fmt.Println(runtime.NumGoroutine())</div><div class="line"> 78 &#125;</div></pre></td></tr></table></figure>
<p>获取goroutine的GID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> 1 package main</div><div class="line"> 2</div><div class="line"> 3 import (</div><div class="line"> 4     &quot;bytes&quot;</div><div class="line"> 5     &quot;runtime&quot;</div><div class="line"> 6     &quot;strconv&quot;</div><div class="line"> 7 )</div><div class="line"> 8</div><div class="line"> 9 func GetGID() uint64 &#123;</div><div class="line">10     b := make([]byte, 64)</div><div class="line">11     b = b[:runtime.Stack(b, false)]</div><div class="line">12     b = bytes.TrimPrefix(b, []byte(&quot;goroutine &quot;))</div><div class="line">13     b = b[:bytes.IndexByte(b, &apos; &apos;)]</div><div class="line">14     n, _ := strconv.ParseUint(string(b), 10, 64)</div><div class="line">15     return n</div><div class="line">16 &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div style=&quot;text-align:center&quot; markdown=&quot;1&quot;&gt;&lt;br&gt;&lt;img src=&quot;/assets/images/Mexican_Standoff.jpg&quot; alt=&quot;三个火枪手&quot;&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;生产者-消费者模式即所谓的Fan
    
    </summary>
    
      <category term="Golang" scheme="https://skypacer210.github.io/categories/Golang/"/>
    
    
      <category term="Concurrency" scheme="https://skypacer210.github.io/tags/Concurrency/"/>
    
      <category term="Producer" scheme="https://skypacer210.github.io/tags/Producer/"/>
    
      <category term="Consumer" scheme="https://skypacer210.github.io/tags/Consumer/"/>
    
  </entry>
  
  <entry>
    <title>C++11可调用对象模板类初窥</title>
    <link href="https://skypacer210.github.io/2015/06/25/C++-feature-callable-obj/"/>
    <id>https://skypacer210.github.io/2015/06/25/C++-feature-callable-obj/</id>
    <published>2015-06-24T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初识可调用对象模板类"><a href="#初识可调用对象模板类" class="headerlink" title="初识可调用对象模板类"></a>初识可调用对象模板类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">79 typedef boost::function&lt;bool (const TcpConnectionPtr&amp;,</div><div class="line">80 									StringPiece,</div><div class="line">81                         		Timestamp)&gt; RawMessageCallback;</div><div class="line">82                  </div><div class="line">83 typedef boost::function&lt;void (const TcpConnectionPtr&amp;,</div><div class="line">84                         		const MessagePtr&amp;,</div><div class="line">85                         		Timestamp)&gt; ProtobufMessageCallback;</div><div class="line">86                  </div><div class="line">87 typedef boost::function&lt;void (const TcpConnectionPtr&amp;,</div><div class="line">88                         		Buffer*,</div><div class="line">89                         		Timestamp,</div><div class="line">90                         		ErrorCode)&gt; ErrorCallback;</div></pre></td></tr></table></figure>
<p>这里用到了C++11的新特性——<strong>可调用对象模板类</strong>，可调用对象理解为函数，该特性可以用于定义函数指针，相当于是把函数本身做进一步抽象。这里利用该特性定义了三个回调函数，以第一个<code>typedef boost::function&lt;bool (const TcpConnectionPtr&amp;, StringPiece，Timestamp)&gt; RawMessageCallback</code>为例：</p>
<ul>
<li>其中<code>function&lt;bool (const TcpConnectionPtr&amp;, StringPiece，Timestamp)&gt;</code>意思是定义了一个可调用对象（函数指针），参数是三个<code>const TcpConnectionPtr&amp;, StringPiece，Timestamp</code>。</li>
<li>再利用typedef，定义了一个函数指针<code>RawMessageCallback</code>，或者说是一个可调用对象。</li>
</ul>
<p>该上下文的调用如下：     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">134		private:</div><div class="line">135   		const ::google::protobuf::Message* prototype_;</div><div class="line">136       const string tag_;</div><div class="line">137       ProtobufMessageCallback messageCallback_;</div><div class="line">138       RawMessageCallback rawCb_;</div><div class="line">139       ErrorCallback errorCallback_;</div></pre></td></tr></table></figure>
<h3 id="用法实例"><a href="#用法实例" class="headerlink" title="用法实例"></a>用法实例</h3><p>可以结合<code>map</code>容器和该特性定义一张函数表，如下示例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"> 1 #include &lt;string&gt;                                                                                                                                                                               </div><div class="line"> 2 #include &lt;vector&gt;</div><div class="line"> 3 #include &lt;map&gt;   </div><div class="line"> 4 #include &lt;functional&gt;</div><div class="line"> 5 #include &lt;set&gt;      </div><div class="line"> 6 #include &lt;iostream&gt; </div><div class="line"> 7 #include &lt;sstream&gt;  </div><div class="line"> 8 #include &lt;fstream&gt;  </div><div class="line"> 9 #include &lt;cstring&gt;  </div><div class="line">10 #include &lt;cctype&gt;   </div><div class="line">11 #include &lt;stdexcept&gt;</div><div class="line">12                     </div><div class="line">13 #include &lt;typeinfo&gt; </div><div class="line">14                     </div><div class="line">15                     </div><div class="line">16 using namespace std;</div><div class="line">17                     </div><div class="line">18 int add(int i, int j)</div><div class="line">19 &#123;                   </div><div class="line">20     return i + j;   </div><div class="line">21 &#125;                   </div><div class="line">22 auto mod = [ ](int i, int j)</div><div class="line">23 &#123;                   </div><div class="line">24     return i % j;   </div><div class="line">25 &#125;;                  </div><div class="line">26                     </div><div class="line">27                     </div><div class="line">28 struct divide       </div><div class="line">29 &#123;                   </div><div class="line">30     int operator() (int denom, int diveisor)</div><div class="line">31     &#123;               </div><div class="line">32         return denom * diveisor;           </div><div class="line">33     &#125;               </div><div class="line">34 &#125;;                  </div><div class="line">35                     </div><div class="line">36                     </div><div class="line">37 int main(int argc, char *argv[])           </div><div class="line">38 &#123;                   </div><div class="line">39     map&lt;char, int(*)(int, int)&gt; binops_limit;</div><div class="line">40     binops_limit.insert( &#123;&apos;+&apos;, add&#125; );     </div><div class="line">41     binops_limit.insert( &#123;&apos;%&apos;, mod&#125; );     </div><div class="line">42                     </div><div class="line">43     map&lt;char, function&lt;int(int, int)&gt; &gt; binops = </div><div class="line">44     &#123;               </div><div class="line">45         &#123; &apos;+&apos;, add &#125;,      </div><div class="line">46         &#123; &apos;-&apos;, minus&lt;int&gt;() &#125;,             </div><div class="line">47         &#123; &apos;*&apos;, [](int i, int j) &#123; return i - j; &#125; &#125;,</div><div class="line">48         &#123; &apos;/&apos;, divide() &#125;, </div><div class="line">49         &#123; &apos;%&apos;, mod &#125;,      </div><div class="line">50     &#125;; </div><div class="line">51             </div><div class="line">52     map&lt;char, int(*)(int, int)&gt;::const_iterator iter =  </div><div class="line">53                                         binops_limit.begin();      </div><div class="line">54             </div><div class="line">55     for (; iter != binops_limit.end(); ++iter)          </div><div class="line">56     &#123;       </div><div class="line">57         cout &lt;&lt; &quot;Type of iterator: &quot; &lt;&lt; typeid(iter).name() &lt;&lt; endl;</div><div class="line">58         cout &lt;&lt; &quot;Type of iterator-&gt;first : &quot; &lt;&lt; typeid(iter-&gt;firstea.name() &lt;&lt; &quot; &quot; &lt;&lt; &quot;value: &quot; &lt;&lt; iter-&gt;first  &lt;&lt; endl;</div><div class="line">59         cout &lt;&lt; &quot;Type of iterator-&gt;second: &quot; &lt;&lt; typeid(iter-&gt;second).name() &lt;&lt; &quot; &quot; &lt;&lt; &quot;value: &quot; &lt;&lt; iter-&gt;second  &lt;&lt; endl;</div><div class="line">60     &#125;       </div><div class="line">61             </div><div class="line">62     cout &lt;&lt; &quot;FuncTable: + &quot;&lt;&lt; binops[&apos;+&apos;](10, 5) &lt;&lt;endl;</div><div class="line">63     cout &lt;&lt; &quot;FuncTable: - &quot;&lt;&lt; binops[&apos;-&apos;](10, 5) &lt;&lt; endl;</div><div class="line">64     cout &lt;&lt; &quot;FuncTable: * &quot;&lt;&lt; binops[&apos;*&apos;](10, 5) &lt;&lt; endl;</div><div class="line">65     cout &lt;&lt; &quot;FuncTable: / &quot;&lt;&lt; binops[&apos;/&apos;](10, 5) &lt;&lt; endl;</div><div class="line">66     cout &lt;&lt; &quot;FuncTable: % &quot;&lt;&lt; binops[&apos;%&apos;](10, 5) &lt;&lt; endl;</div><div class="line">67             </div><div class="line">68     return 0;</div><div class="line">69 &#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Type of iterator: NSt3__120__map_const_iteratorINS_21__tree_const_iteratorINS_12__value_typeIcPFiiiEEEPNS_11__tree_nodeIS5_PvEElEEEE</div><div class="line">Type of iterator-&gt;first : c value: %</div><div class="line">Type of iterator-&gt;second: PFiiiE value: 1</div><div class="line">Type of iterator: NSt3__120__map_const_iteratorINS_21__tree_const_iteratorINS_12__value_typeIcPFiiiEEEPNS_11__tree_nodeIS5_PvEElEEEE</div><div class="line">Type of iterator-&gt;first : c value: +</div><div class="line">Type of iterator-&gt;second: PFiiiE value: 1</div><div class="line">FuncTable: + 15</div><div class="line">FuncTable: - 5</div><div class="line">FuncTable: * 5</div><div class="line">FuncTable: / 50</div><div class="line">FuncTable: % 0</div></pre></td></tr></table></figure>
<p>这里面有几个坑要注意： </p>
<ul>
<li><code>auto mod = [ ](int i, int j)</code>定义了一个lamba表达式，即没有函数名的函数，这是什么鬼？注意函数实现最后有分号<code>；</code></li>
<li>头文件一定包含全面，否则出来一堆错误，特别是<code>#include &lt;stdexcept&gt;</code>；</li>
<li>如果想打印类型名怎么办？就像gdb中的命令ptype，C++也有类似的方法，首先包含头文件<code>#include &lt;typeinfo&gt;</code>，然后直接<code>typeid(var)</code>即可。从运行结果可以看到迭代器本身的类型和迭代器成员的类型区别。</li>
<li>迭代器本身为指针，因此访问其成员用<code>-&gt;</code>操作符。</li>
</ul>
<p>TODO: 容器遍历与访问的两种方法：迭代器和容器内部方法之区别。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;初识可调用对象模板类&quot;&gt;&lt;a href=&quot;#初识可调用对象模板类&quot; class=&quot;headerlink&quot; title=&quot;初识可调用对象模板类&quot;&gt;&lt;/a&gt;初识可调用对象模板类&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
    
    </summary>
    
      <category term="C++" scheme="https://skypacer210.github.io/categories/C/"/>
    
    
      <category term="可调用对象" scheme="https://skypacer210.github.io/tags/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="迭代器" scheme="https://skypacer210.github.io/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web App Security Consideration</title>
    <link href="https://skypacer210.github.io/2015/06/18/web-security-guide/"/>
    <id>https://skypacer210.github.io/2015/06/18/web-security-guide/</id>
    <published>2015-06-17T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>该文摘自<a href="http://programmers.stackexchange.com/questions/46716/what-technical-details-should-a-programmer-of-a-web-application-consider-before" target="_blank" rel="external">What technical details should a programmer of a web application consider before making the site public?</a>，实际上列出了Web安全的知识体系，也包括了工程开发当中的指导准则。     </p>
<h3 id="接口与用户体验"><a href="#接口与用户体验" class="headerlink" title="接口与用户体验"></a>接口与用户体验</h3><p>线程安全是多线程程序中的编程理念，一段代码线程安全意味着在多个线程执行的时候能够运行正确。因此，它必须满足： </p>
<ul>
<li>确保你的网站能够适配所有主流的浏览器。一个最小的测试集必须包括：Firefox采用的Gecko引擎，Safari以及其他手机浏览器采用的WebKit引擎，Chrome，IE(兼容VPC图片)和Opera。同时也需考虑在不同OS上的渲染问题；</li>
<li>考虑浏览器之外的访问通道，比如蜂窝电话，Sreen Reader以及搜索引擎。这里的要点是如何在不影响用户的情况下更新功能，这里需要版本管理软件和自动化编译机制；</li>
<li>永远不要呈现给用户不友好的错误提示；</li>
<li>不要将用户的邮箱地址以明文形式呈现；</li>
<li>对于用户产生的链接加入<code>rel=&quot;nofollow&quot;</code>属性以避免受到攻击；</li>
<li>为你的网站加入深思熟虑后的限制；</li>
<li>POST成功后立即重定向，从而禁止再次提交引发刷新；</li>
<li>理解并应用渐进增强；</li>
<li>多元化用户交互，不单单依赖鼠标；</li>
<li>最后一点：别让用户思考； </li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul>
<li>参考OWASP development guide，其覆盖了上层到底层的安全架构和知道准则；</li>
<li>理解SQL注入并知道如何防御；</li>
<li>永远不信任用户输入或者是来自用户的请求，包括cookie以及隐藏其后的属性值；</li>
<li>对密码进行”撒盐”哈希，不同列采用不同的“盐”以防御彩虹表攻击；选择计算较慢的哈希算法(比如bcrypt或者scrypt)来存储密码，NIST和FIPS建议采用PBKDF2对密码进行哈希。避免直接使用MD5和SHA；</li>
<li>不要试图开发你自己的验证系统，相比现有成熟的验证体系，你的方法更容易受到攻击；</li>
<li>对敏感数据输入相关的页面采用SSL/HTTPS保护；</li>
<li>预防 session hijacking；</li>
<li>避免 cross site scripting (XSS)；</li>
<li>避免 cross site request forgeries (CSRF)；</li>
<li>避免 Clickjacking；</li>
<li>确保你的系统及时更新最新的补丁；</li>
<li>确保你的DB连接信息是安全的；</li>
<li>及时追踪最新的攻击方法和手段；</li>
<li>阅读谷歌浏览器的安全手册；</li>
<li>阅读Web应用攻击者的手册；</li>
<li>考虑最小权限原则，尝试以非root权限运行你的应用服务器；</li>
</ul>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul>
<li>如有必要实现cache，理解并使用HTTP、HTML5的cache；</li>
<li>优化图像处理，不要在需要反复使用的场合调用20KB的照片；</li>
<li>学会如何压缩和deflate；</li>
<li>组合多个脚本文件以减少浏览器的连接数量；</li>
<li>参考Yahoo的异常性能站点，包含有多个操作指导；</li>
<li>采用CSS处理小的有相关度的图片；</li>
<li>高访问量站点需要考虑跨domain的组件拆分问题；</li>
<li>静态内容()应该放置于一个单独的域，该域不使用cookie。因为一个域及其子域中的所有cookie在每次请求发送中都会被包含。一个好的方式是采用CDN，但是必须考虑CDN失效的情形；</li>
<li>最小化渲染页面所需的HTTP请求；</li>
<li>善假于物，比如Google的Closure JavaScript编译器；</li>
<li>确保在站点的根目录下有一个<code>favicon.ico</code>文件, 比如. <code>/favicon.ico</code>。浏览器会自动请求该文件，甚至在HTML中无需提及；如果没有这样的文件<code>/favicon.ico</code>，会产生多个404错误，消耗网站带宽；</li>
</ul>
<h3 id="搜索引擎优化"><a href="#搜索引擎优化" class="headerlink" title="搜索引擎优化"></a>搜索引擎优化</h3><ul>
<li>采用搜索引擎友好的URLS，比如采用<code>example.com/pages/45-article-title</code> 而不是<code>example.com/index.php?page=45</code>；  </li>
<li>对于动态内容修改，将<code>#</code>替换诶<code>#！</code>；  </li>
<li>不要采用诸如<code>click here</code>的链接；</li>
<li>设置一个XML sitemap, 缺省位置<code>/sitemap.xml</code>；</li>
<li>对于多个URL指向同一个内容，采用<code>&lt;link rel=&quot;canonical&quot; ... /&gt;</code>；</li>
<li>善假于物，这次是Google的 Webmaster Tools 和微软Bing的 Webmaster Tools；</li>
<li>安装Google的分析器，或者是开源的Piwik；</li>
<li>知道搜索引擎爬虫的工作原理；</li>
<li>采用301做永久重定向；</li>
</ul>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><ul>
<li>理解HTTP相关原理，比如GET、POST、session、cookie以及无状态；</li>
<li>根据W3C标准编写HTML和CSS，确保准确；</li>
<li>理解浏览器中JavaScript如何工作；</li>
<li>理解JavaScript, style sheets以及其他所需资源的加载过程以及对性能的影响；</li>
<li>理解JavaScript sandbox的工作原理；</li>
<li>理解JavaScript已逐步被AJAX替代；</li>
<li>理解301和302重定向的区别；</li>
<li>尽可能多的理解网站所运行的平台；</li>
<li>考虑采用Reset Style Sheet 或者normalize.css；</li>
<li>考虑JavaScript框架；</li>
<li>综合考虑perceived performance 和 JS 框架；</li>
<li>不要重复发明轮子；</li>
<li>尽可能“轻便”；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该文摘自&lt;a href=&quot;http://programmers.stackexchange.com/questions/46716/what-technical-details-should-a-programmer-of-a-web-application-conside
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="WEB" scheme="https://skypacer210.github.io/tags/WEB/"/>
    
      <category term="HTTP" scheme="https://skypacer210.github.io/tags/HTTP/"/>
    
      <category term="OWASP" scheme="https://skypacer210.github.io/tags/OWASP/"/>
    
  </entry>
  
  <entry>
    <title>线程安全函数与可重入函数</title>
    <link href="https://skypacer210.github.io/2015/06/01/thread-safe/"/>
    <id>https://skypacer210.github.io/2015/06/01/thread-safe/</id>
    <published>2015-05-31T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全是多线程程序中的编程理念，一段代码线程安全意味着在多个线程执行的时候能够运行正确。因此，它必须满足：</p>
<ul>
<li>多线程访问共享数据；</li>
<li>在任一时刻只能被一个线程访问。</li>
</ul>
<p>保证的手段如下：  </p>
<ul>
<li>编写可重入代码</li>
</ul>
<p>一个任务执行该代码的一部分，此时另外一个任务进来，最后再恢复到原先任务。这就需要保存每一个任务的本地局部变量，一般保证在自己的栈当中，而不是static或者全局变量。  </p>
<ul>
<li>Mutual exclusion  </li>
</ul>
<p>如果采用某种机制使得序列化访问共享数据，保证在任意时刻只有一个线程读写数据。由此引发条件竞争、死锁、活锁、饥饿等问题。</p>
<p>使用静态数据或任何其他共享资源的函数（比如文件或终端）必须通过锁使得对这些资源的访问串行化，以便函数变为线程安全。例如，以下函数是线程不安全的：     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* thread-unsafe function */</div><div class="line">int increment_counter()</div><div class="line">&#123;</div><div class="line">	static int counter = 0;</div><div class="line"></div><div class="line">	counter++;</div><div class="line">    return counter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要使其变为线程安全的，那么必须通过静态锁将静态变量 counter 保护起来，如以下例子所示：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/* pseudo-code threadsafe function */</div><div class="line">int increment_counter();</div><div class="line">&#123;</div><div class="line">	static int counter = 0;</div><div class="line">    static lock_type counter_lock = LOCK_INITIALIZER;</div><div class="line"></div><div class="line">    pthread_mutex_lock(counter_lock);</div><div class="line">    counter++;</div><div class="line">    pthread_mutex_unlock(counter_lock);</div><div class="line">    return counter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在使用线程库的多线程应用程序中，应使用 mutex 来对共享资源进行串行化。独立的库可能需要在线程的上下文以外工作，因此，请使用其他种类的锁。  </p>
<ul>
<li>采用TLS(Thread-local storage)  </li>
</ul>
<p>其实就是变量本地化，即确保每个thread拥有自己的私有拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">thread_t &#123;</div><div class="line">	int	tls;</div><div class="line">	void	*t_tls_data;</div><div class="line">	…</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>原子操作  </li>
</ul>
<p>采用原子操作保证其他thread无法中断当前操作，通常通过特殊的机器指令，比如xchag和TSL。原子操作构成了多线程锁机制的基础。  </p>
<p><strong>线程安全函数</strong></p>
<p>线程安全函数通过锁来保护并发访问中的共享资源。线程安全只与函数的实现有关，并不会影响它的外部接口。</p>
<p>在C语言中，局部变量是在堆栈中动态分配的。因此，任何不使用静态数据或其他共享资源的函数一般都是线程安全的。  </p>
<p>全局数据的使用是线程不安全的。全局数据应针对每个线程保存或被封装起来，这样可以使它的访问串行化。线程可以读取对应于由另一个线程引起的错误的错误代码。</p>
<p>在多线程程序中，所有被多个线程调用的函数必须是线程安全的。但是，对于在多线程程序中使用线程不安全子例程有一个变通方法。虽然非重入函数通常都是线程不安全的，但是将它们变为重入常常也使它们变为线程安全。</p>
<p><strong>使函数成为重入函数</strong>  </p>
<p>在多数情况下，必须用带有已修改的将要重入的函数来替代非重入函数。非重入函数不能由多个线程使用。此外，可能也无法使非重入函数变为线程安全。  </p>
<p>许多非重入函数会返回一个指向静态数据的指针。可以用以下方法来避免这种情况：  </p>
<ul>
<li>返回动态分配的数据。在这种情况下，调用程序将负责释放存储量。好处在于无需对接口进行修改。但是，向后兼容性就无法保证了；现有的使用已修改函数的单线程程序在不更改的情况下不会释放存储量，这将导致内存泄漏。</li>
<li>使用调用程序提供的存储量。虽然必须修改接口，但是推荐使用这种方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* non-reentrant function */</div><div class="line">char *strtoupper(char *string)</div><div class="line">&#123;</div><div class="line">    static char buffer[MAX_STRING_SIZE];</div><div class="line">    int index;</div><div class="line"></div><div class="line">    for (index = 0; string[index]; index++)</div><div class="line">        buffer[index] = toupper(string[index]);</div><div class="line">        buffer[index] = 0</div><div class="line"></div><div class="line">    return buffer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数不是重入函数（也不是线程安全的函数）。要通过返回动态分配的数据来使该函数重入，那么该函数应类似于以下代码段：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* reentrant function (a poor solution) */</div><div class="line">char *strtoupper(char *string)</div><div class="line">&#123;</div><div class="line">    char *buffer;</div><div class="line">    int index;</div><div class="line"></div><div class="line">    /* error-checking should be performed! */</div><div class="line">    buffer = malloc(MAX_STRING_SIZE);</div><div class="line">    </div><div class="line">    for (index = 0; string[index]; index++)</div><div class="line">        buffer[index] = toupper(string[index]);  </div><div class="line">	buffer[index] = 0</div><div class="line"></div><div class="line">    return buffer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>较好的解决方案是修改接口。调用程序必须为输入和输出字符串提供存储量，如以下代码段所示：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* reentrant function (a better solution) */</div><div class="line">char *strtoupper_r(char *in_str, char *out_str)</div><div class="line">&#123;</div><div class="line">	int index;</div><div class="line"></div><div class="line">    for (index = 0; in_str[index]; index++)</div><div class="line">    	out_str[index] = toupper(in_str[index]);</div><div class="line">   </div><div class="line">	out_str[index] = 0</div><div class="line"></div><div class="line">	return out_str;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用调用程序提供的存储量使非重入标准 C 库子例程重入。</p>
<p><strong>在连续调用中保存数据</strong>  </p>
<p>在连续调用中将不保存任何数据，因为不同的线程可能连续地调用该函数。如果函数必须在连续调用中保存某些数据，比如工作缓存或指针，那么调用程序应提供该数据。  </p>
<p>如下示例，函数返回了字符串中连续的小写字符。该字符串只在第一次调用时提供，就像strtok子例程。函数在到达字符串的结尾处时返回 0。该函数可通过以下代码段来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/* non-reentrant function */</div><div class="line">char lowercase_c(char *string)</div><div class="line">&#123;</div><div class="line">	static char *buffer;</div><div class="line">    static int index;</div><div class="line">	char c = 0;</div><div class="line"></div><div class="line">    /* stores the string on first call */</div><div class="line">    if (string != NULL) &#123;</div><div class="line">    	buffer = string;</div><div class="line">        index = 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    /* searches a lowercase character */</div><div class="line">    for (; c = buffer[index]; index++) &#123;</div><div class="line">    	if (islower(c)) &#123;</div><div class="line">        	index++;</div><div class="line">        break;</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line">    return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数不是重入函数。要使其变为重入函数，那么调用程序必须保存静态数据和变量 index。该函数的重入版本可通过以下代码段来实现：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* reentrant function */</div><div class="line">char reentrant_lowercase_c(char *string, int *p_index)</div><div class="line">&#123;</div><div class="line">	char c = 0;</div><div class="line">    /* no initialization - the caller should have done it */</div><div class="line"></div><div class="line">    /* searches a lowercase character */</div><div class="line">    for (; c = string[*p_index]; (*p_index)++) &#123;</div><div class="line">    	if (islower(c)) &#123;</div><div class="line">			(*p_index)++;</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">    return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数的接口和用法都发生了改变。调用程序必须向每次调用提供该字符串，且在首次调用前，必须将索引初始化为 0，如以下代码所示：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">char *my_string;</div><div class="line">char my_char;</div><div class="line">int my_index;</div><div class="line">...</div><div class="line">my_index = 0;</div><div class="line">while (my_char = reentrant_lowercase_c(my_string, &amp;my_index)) &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>TLS库的线程安全</strong></p>
<p>在TLS实现中，常见的需要保证线程安全的场景主要有：</p>
<ul>
<li>SSL收发缓冲区；</li>
<li>SSL Session Cache context</li>
<li>CTR-DRBG context</li>
<li>Entropy context</li>
<li>RSA key context</li>
</ul>
<p>目前的TLS线程安全由pthread_mutex互斥锁保证。 </p>
<p><strong>编写重入和线程安全代码</strong>  </p>
<p>在单线程进程中，只存在一个控制流。因此，这些进程所执行的代码无需重入或是线程安全的。在多线程程序中，相同的功能和资源可以通过多个控制流并发访问。  </p>
<p>要保护资源的完整性，编写的多线程程序代码必须能重入并是线程安全的。重入和线程安全都与函数处理资源的方式相关。重入和线程安全是不同的概念：函数可以重入和/或线程安全化，或者两者都不可行。  </p>
<p>此部分提供了有关编写重入和线程安全程序的信息。其中不涉及有关编写高效线程程序的主题。高效线程程序是高效率的并行化程序。您必须在设计程序的时候考虑到线程的效率。现有的单线程程序可以成为高效线程程序，但是这需要将这些程序完全重新设计和重新编写。</p>
<p>除了上述方法，可以有变通方法编写：  </p>
<p>该变通方法很有用，尤其是在使用多线程程序中的线程不安全库进行测试时，或者同时在等待线程安全的库变成可用时。该变通方法会导致一些开销，因为它是通过对整个函数，甚至一组函数进行串行化来实现的。以下是可能的变通方法：  </p>
<ul>
<li>对库使用全局锁定，并在每次使用该库的时候锁定它（通过调用一个库例程或使用一个库全局变量）。该解决方案可以会产生性能瓶颈，由于在任意给定的时间内只有一个线程能够对库的所有部分进行访问。以下伪码的解决方案只有在库很少被访问，或是作为一个初始的、快捷的实现变通方法时才是可接受的。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* this is pseudo code! */</div><div class="line">	</div><div class="line">	lock(library_lock);</div><div class="line">	library_call();</div><div class="line">	unlock(library_lock);</div><div class="line">	</div><div class="line">	lock(library_lock);</div><div class="line">	x = library_var;</div><div class="line">	unlock(library_lock);</div></pre></td></tr></table></figure>
<ul>
<li>对每个库组件或组件组使用锁（例程或全局变量）。此种解决方案实现起来比上面的例子略微复杂一些，但是它可以改善性能。因为该变通方法只能在应用程序中使用，而不能在库中使用，所以可以使用 mutex 来锁定库。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* this is pseudo-code! */</div><div class="line"></div><div class="line">lock(library_moduleA_lock);</div><div class="line">library_moduleA_call();</div><div class="line">unlock(library_moduleA_lock);</div><div class="line"></div><div class="line">lock(library_moduleB_lock);</div><div class="line">x = library_moduleB_var;</div><div class="line">unlock(library_moduleB_lock);</div></pre></td></tr></table></figure>
<h3 id="重入和线程安全库"><a href="#重入和线程安全库" class="headerlink" title="重入和线程安全库"></a>重入和线程安全库</h3><p>重入函数不在连续的调用中保存静态数据，也不返回指向静态数据的指针。所有的数据都是由函数的调用程序提供的。重入函数不得调用非重入函数。  </p>
<p>一般情况下，非重入函数是由其外部接口和用法标识的，但也并不总是这样。例如，strtok 子例程不是一个重入函数，因为它保存了将分割为多个标记的字符串。ctime 子例程同样不是重入函数；它返回了被每个调用所覆盖的静态数据的指针。  </p>
<p>重入库和线程安全库并不仅仅在线程中有用，而且在大范围的并行（和异步）编程环境中也很有用。一直使用和编写重入函数和线程安全函数是很好的编程实践。  </p>
<p><strong>使用库</strong>  </p>
<p>标准C库 (libc.a)和Berkeley兼容性库(libbsd.a)以下库是线程安全的，有些标准 C 子例程是非重入的，比如 ctime 和 strtok 子例程。  </p>
<p>在编写多线程程序的时候，请使用子例程的重入版本来替代原来的版本。例如，以下代码段：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">token[0] = strtok(string, separators);</div><div class="line">i = 0;</div><div class="line">do &#123;</div><div class="line">	i++;</div><div class="line">    token[i] = strtok(NULL, separators);</div><div class="line">&#125; while (token[i] != NULL);</div></pre></td></tr></table></figure>
<p>在多线程程序中应使用以下代码段来代替：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">char *pointer;</div><div class="line">...</div><div class="line">token[0] = strtok_r(string, separators, &amp;pointer);</div><div class="line">i = 0;</div><div class="line">do &#123;</div><div class="line">	i++;</div><div class="line">    token[i] = strtok_r(NULL, separators, &amp;pointer);</div><div class="line">&#125; while (token[i] != NULL);</div></pre></td></tr></table></figure>
<p>在一个程序中，线程不安全的库可能只由一个线程使用。请确保使用该库的线程的唯一性；否则，程序可出现意外的行为，甚至可能停止。</p>
<p><strong>转换库</strong>  </p>
<p>在将一个现有的库转换为重入库和线程安全库的时候，请考虑以下问题。此信息只适用于 C 语言库。  </p>
<ul>
<li>确定已导出的全局变量。那些变量通常是用 export 关键字在头文件中定义的。应将已导出的全局变量封装起来。变量应设为专用变量（使用 static 关键字在库源代码中定义），然后应创建访问（读和写）子例程。</li>
<li>确定静态变量和其他的共享资源。静态变量通常是用 static 关键字定义的。锁应该与任意的共享资源关联。锁定的详细程度，这样对锁数目的选择将影响到库的性能。可使用一次性初始化工具来初始化这些锁。</li>
<li>确定非重入函数并使之变为重入函数。有关更多信息，请参阅使函数成为重入函数。</li>
<li>确定线程不安全函数并使之成为线程安全函数。有关更多信息，请参阅使函数成为线程安全函数。   </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h3&gt;&lt;p&gt;线程安全是多线程程序中的编程理念，一段代码线程安全意味着在多个线程执行的时候能够运行正确。因此，它必须满足：&lt;/p&gt;
&lt;ul
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="thread" scheme="https://skypacer210.github.io/tags/thread/"/>
    
      <category term="reentrance" scheme="https://skypacer210.github.io/tags/reentrance/"/>
    
      <category term="mutex" scheme="https://skypacer210.github.io/tags/mutex/"/>
    
  </entry>
  
  <entry>
    <title>从SSL会话中出现TCP超时说起</title>
    <link href="https://skypacer210.github.io/2015/05/12/issue-about-tcp-read-timeout-in-ssl-session/"/>
    <id>https://skypacer210.github.io/2015/05/12/issue-about-tcp-read-timeout-in-ssl-session/</id>
    <published>2015-05-11T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近将工作中碰到的一个问题记录下，以备查找。该问题的现象是程序在连接某一个APP时失败，日志显示TCP读超时，但是连接其他APP都成功。    </p>
<p>初步调试发现，此时client与server已经建立SSL连接，但是在读取APP数据时select超时，但为什么单单在连接这个APP的时候出现超时呢？ </p>
<p>首先看SSL连接的建立过程，如图1所示：    </p>
<p><div style="text-align:center" markdown="1"><br><img src="/assets/images/SSL/SSL_exchange.png" alt="图片"></div></p>
<ol>
<li>第一步服务器端创建监听socket等待客户端连接。</li>
<li>第二步客户端创建SSL上下文数据结构，包括支持的cipher种类，证书以及SSL版本等。</li>
<li>第三步完成TCP端口的建立。客户端调用connect()发起TCP握手，即SYN，SYN/ACK和ACK这三次握手）。服务器端调用accept()响应客户端的请求。</li>
<li>第四步客户端和服务器端都会创建一个session，该对象基于SSL上下文，并绑定其至socket。具体实现就是以socket为索引建一张表，该表维护当前所有的SSL session。既然是session，那就是有状态的，一般是CONNECT_DISABLED、CONNECT_CLOSED、CONNECT_NEGOTIATE和CONNECT_OPEN。</li>
<li>第五步完成SSL层的握手。该过程由客户端发起，主要是负责建立一个安全通道，协商出一个共享秘钥以供后续使用。</li>
<li>在第六步中数据经由前面建好的加密隧道收发。该过程是密文交互。</li>
<li>第七步完成SSL连接关闭，客户端和服务器端都可以通过alert类型的记录报文发起关闭请求。</li>
<li>在正常情况下，TCP关闭由四次握手完成，即FIN/ACK，ACK，FIN/ACK和ACK完成，该过程是明文交互。</li>
<li>客户端和服务器端释放SSL session资源。</li>
<li>服务器返回第三步接受另外的socket。  </li>
</ol>
<p>注：  </p>
<ol>
<li>第一、第三和第八步是标准的TCP握手和终止流程，与是否进行SSL连接无关。  </li>
<li>第二、第四、第五、第七和第八步仅仅在SSL连接建立的情况下发生的流程，SSL开启前后的对比见图3。  </li>
<li>第六和第九步则SSL相关。   </li>
</ol>
<p><div style="text-align:center" markdown="1"><br><img src="/assets/images/SSL/SSL_layer_compare.png" alt="图片">   </div></p>
<p>而SSL本身的数据处理如图2所示：  </p>
<p><div style="text-align:center" markdown="1"><br><img src="/assets/images/SSL/SSL_data_enc.png" alt="图片">   </div></p>
<ol>
<li>如果需要将应用数据进行分片和组合，每个分片包封装至SSL的记录协议单元（Record Protocol Unit）；</li>
<li>如果需要压缩则封装至压缩单元；</li>
<li>对整个报文进行MAC计算，附在原始报文之后，然后进行加密；</li>
<li>封装至TCP报文。</li>
</ol>
<p>让我们回到数据读取，这里需要说明的是程序采用的事件处理框架。作为SSL客户端，为了能够处理多个SSL连接建立后对多个socket的并发事件处理，引入了select机制，事实上最多支持32个SSL连接。Select作为一种非阻塞IO接口，在这里用于轮询建立的TCP socket (SSL连接基于TCP socket，当然例外情况是DTLS基于UDP) 事件，结果发现没有数据可读。  </p>
<p>数据读取在非阻塞模式下遵从能读多少就读多少的原则，同理数据写入在非阻塞模式下也遵从能输出多少就输出多少的原则,其中输出缓冲区如下图所示：  </p>
<p><div style="text-align:center" markdown="1"><br><img src="/assets/images/SSL/SSL_write.jpg" alt="图片">  </div></p>
<p>进一步查看已经建立的SSL连接表，结构如图2所示。SSL连接表本身由一个数组存储，为了加快SSL连接的查找又引入了一张哈希表，该哈希表采用数组作为散列的桶，每个桶是一个单向链表以解决哈希冲突。      </p>
<p><div style="text-align:center" markdown="1"><br><img src="/assets/images/SSL/SSL_data.png" alt="图片"></div></p>
<p>当前的SSL连接表显示多个SSL连接都挂在了一个桶的链表上，看起来是发生了哈希冲突，但细想这概率似乎有点高，那就看看为啥这几个SSL连接都搞出来一个key， 注意到这里的hash key是TCP socket的抽象数据结构指针，再看代码直接把当前进程中的文件描述作为查找键，增加一行代码就好了，即利用getsock拿到真正的socket数据结构指针。</p>
<p>为了搞清楚错误是怎么发生的，有必要来个情景再现。让我们看看在哈希表插入的时候发生什么。哈希表的插入发生在新建一个SSL连接的时候（每一个SSL连接对应一个TCP socket），当TCP连接建立之后，SSL就以socket作为key插入哈希表当中。由于APP在SSL建立时候打开的一个文件描述符和隧道建立时候打开的文件描述符一些情况下是一样的，这样新旧两个SSL连接描述符产生相同的key,都插入同一个桶，对应依次插入链表尾部，当进行数据读写时根据文件描述符查找到的是旧的SSL连接描述符，此时该连接符已无数据可读写，导致超时。    </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近将工作中碰到的一个问题记录下，以备查找。该问题的现象是程序在连接某一个APP时失败，日志显示TCP读超时，但是连接其他APP都成功。    &lt;/p&gt;
&lt;p&gt;初步调试发现，此时client与server已经建立SSL连接，但是在读取APP数据时select超时，但为什么单
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="SSL/TLS" scheme="https://skypacer210.github.io/tags/SSL-TLS/"/>
    
      <category term="select" scheme="https://skypacer210.github.io/tags/select/"/>
    
      <category term="HashTable" scheme="https://skypacer210.github.io/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>客户端证书与服务端证书</title>
    <link href="https://skypacer210.github.io/2015/04/08/client-certificate-vs-server-certificate/"/>
    <id>https://skypacer210.github.io/2015/04/08/client-certificate-vs-server-certificate/</id>
    <published>2015-04-07T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Server-Certificate"><a href="#Server-Certificate" class="headerlink" title="Server Certificate"></a>Server Certificate</h2><p>服务器端证书用于标识一个Server，典型地被签发给主机名，比如机器名或者host-header(www.baidu.com)。对Server证书而言，”Issued to”域意味着选择哪个签发的hostname。  </p>
<p><div style="text-align:center" markdown="1"><br><img src="/assets/images/server_certificate.png" alt="图片">    </div></p>
<ol>
<li>目的：加密和解密内容</li>
<li>真实世界里只有ROOT CA有自签名证书</li>
<li>存储：对于window IIS，Server certificates are stored in the Personal store of the “Local Computer” account</li>
<li>证书可以存储在用户账户对应的个人存储目录下，也是IIS缺省的搜索路径</li>
</ol>
<h2 id="Client-Certificate"><a href="#Client-Certificate" class="headerlink" title="Client Certificate"></a>Client Certificate</h2><p>服务器端证书用于标识一个Client或者user，意味着向Server验证Client，”Issued to”域采用用户的名字。  </p>
<p><div style="text-align:center" markdown="1"><br><img src="/assets/images/client_certificate.png" alt="图片">      </div></p>
<ol>
<li>目的：仅用于标识身份</li>
<li>真实世界里只有ROOT CA有自签名证书</li>
<li>Client certificate and private key的角色：</li>
</ol>
<ul>
<li>Client证书的证书和私钥作用就是为了在Client authentication中提供Client的数字签名。</li>
<li>crt后缀名文件仅仅包含证书，证书和私钥一般包含在.p12或者.pfx文件中(PKCS12格式)。</li>
<li>私钥如果单独存放，一般为.pem后缀名。</li>
<li>Server端需要client端的数字签名，然后发送至Server，Server利用client的证书（即公钥）解密，以确认client端的身份。其中Client端的数字签名生成过程如下：首先对SSL交互中的随机值进行HASH，然后用client的私钥进行加密。  </li>
</ul>
<h2 id="HTTPS下虚拟主机"><a href="#HTTPS下虚拟主机" class="headerlink" title="HTTPS下虚拟主机"></a>HTTPS下虚拟主机</h2><p>在HTTP下有虚拟主机这一概念，其目的是为了在服务端用单个IP支持多个主机名；对应到HTTPS，客户端验证服务器为不同主机配置多个证书，但是客户端需要检查服务器证书的common name,当客户端请求服务器证书的时候，服务器需要决定提供哪个证书，SNI应用而生，其原理如下图：  </p>
<p><div style="text-align:center" markdown="1"><br><img src="/assets/images/SNI.jpg" alt="图片">  </div></p>
<h2 id="中间人攻击与证书"><a href="#中间人攻击与证书" class="headerlink" title="中间人攻击与证书"></a>中间人攻击与证书</h2><p>SSL中间人攻击的形式主要有三种：SSL downgrading，SSL stripping和fake of SSL certs。<br>在SSL协议中，证书是用来进行身份验证的，这里有两个关键的检查点：  </p>
<ul>
<li>第一个是CA验证，对于客户端而言，验证服务器端证书依赖与本地的trust store，如果本地的trust  store被人篡改，那么避免中间人攻击则无从谈起，事实上这也正是PKI体系的弱点所在。  </li>
<li>第二个是hostname检查，用来确保所连接的服务器就是其声称的，如果有人劫持了DNS服务器，即利用DNS cache poisoning攻击让你的地址栏看起来很正常，这个时候劫持者就可以让此项检查通过。  </li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="http://www.windowsecurity.com/articles-tutorials/authentication_and_encryption/Understanding-Man-in-the-Middle-Attacks-ARP-Part4.html" target="_blank" rel="external">Understanding Man-In-The-Middle Attacks - Part 4: SSL Hijacking</a></li>
<li><a href="https://blog.cloudflare.com/introducing-strict-ssl-protecting-against-a-man-in-the-middle-attack-on-origin-traffic/" target="_blank" rel="external">Introducing Strict SSL</a></li>
<li><a href="https://devcentral.f5.com/articles/ssl-profiles-part-7-server-name-indication" target="_blank" rel="external">SNI for TLS</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Server-Certificate&quot;&gt;&lt;a href=&quot;#Server-Certificate&quot; class=&quot;headerlink&quot; title=&quot;Server Certificate&quot;&gt;&lt;/a&gt;Server Certificate&lt;/h2&gt;&lt;p&gt;服务器端证书
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="Certificate" scheme="https://skypacer210.github.io/tags/Certificate/"/>
    
  </entry>
  
  <entry>
    <title>关于timer实现的优化</title>
    <link href="https://skypacer210.github.io/2015/03/01/tune-timer-implmentation/"/>
    <id>https://skypacer210.github.io/2015/03/01/tune-timer-implmentation/</id>
    <published>2015-02-28T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Timer"><a href="#1-Timer" class="headerlink" title="1. Timer"></a>1. Timer</h2><p>Timer是底层库实现中重要的一部分，其作用主要是实现超时处理，应用的场景有：  </p>
<ul>
<li>EAP状态机实现</li>
<li>事件驱动型模型实现</li>
<li>SSL握手超时处理</li>
</ul>
<p>为了支持实时处理，将Timer的内部实现由原来的单向链表变为红黑树。  </p>
<h3 id="2-为什么是红黑树"><a href="#2-为什么是红黑树" class="headerlink" title="2. 为什么是红黑树"></a>2. 为什么是红黑树</h3><p>红黑树是一种平衡树，但却不是一种基于高度的平衡树，在STL map和Linux中都作为平衡树来应用，当搜索的要求高或者修改频繁时，其表现效果更是好于AVL树，因为后者是基于高度的，所以在每次修改后都要进行rebalance，开销很大。而红黑树的插入只要两次旋转，删除最多三次旋转，虽然搜索稳定性不及AVL，但是仍不失为一种折中的好办法。</p>
<p>为保持红黑树的平衡，需要对树进行一些调整，好比为了保证一个黑客集团内部的黑帽子和红帽子的平衡，在成员之间的帽子问题上进行调整，假定只有两种帽子，黑帽子和红帽子，而且等级森严，按照辈分排：  </p>
<ul>
<li>根节点必须为黑色，就是说老大必须是黑帽子；</li>
<li>每个成员非黑即红；</li>
<li>每个红帽子下面有两个黑帽子；</li>
<li>从任何一个成员自己数起到自小的下线，黑帽子个数都是一致的。</li>
</ul>
<p>当一个新的成员（帽子为暂定为红色）加入后，对家族成员帽子颜色的调整有下面几种情况：  </p>
<ul>
<li>CASE1：新加入成员的Uncle辈是个红帽子，调整波及Uncle、Parent和Granparent，全部调整帽子颜色；</li>
<li>CASE2：新加入成员的Uncle是个黑帽子，而且该成员是Uncle父亲的左孩子的右孩子或者是右孩子的左孩子，调整波及Uncle和Granparent，以Uncle为轴旋转，交换了Uncle和Granparent的位置。</li>
<li>CASE3：新加入成员的Uncle是个黑帽子，而且该成员是Uncle父亲的左孩子的左孩子或者是右孩子的右孩子，调整波及很大，不仅涉及Uncle和Granparent的调整（以Uncle为轴旋转，交换了Uncle和Granparent的位置），还需将Uncle和Granparent的帽子颜色换掉。</li>
</ul>
<p>上述规则可用下图表示：  </p>
<p><img src="/assets/images/rb_rule.png" alt="图片"></p>
<p>依次插入6个节点123456，建立一颗红黑树如图所示：  </p>
<p><img src="/assets/images/rb_insert.png" alt="图片"></p>
<h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><ol>
<li><a href="https://www.youtube.com/watch?v=PhY56LpCtP4" target="_blank" rel="external">RB Tree Howto</a>  </li>
<li><a href="http://kakack.github.io/2014/04/%E9%9D%A2%E8%AF%95%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91/" target="_blank" rel="external">RB Tree Github</a>  </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Timer&quot;&gt;&lt;a href=&quot;#1-Timer&quot; class=&quot;headerlink&quot; title=&quot;1. Timer&quot;&gt;&lt;/a&gt;1. Timer&lt;/h2&gt;&lt;p&gt;Timer是底层库实现中重要的一部分，其作用主要是实现超时处理，应用的场景有：  &lt;/p&gt;
&lt;u
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="Timer" scheme="https://skypacer210.github.io/tags/Timer/"/>
    
      <category term="Event Loop" scheme="https://skypacer210.github.io/tags/Event-Loop/"/>
    
      <category term="RedBlack Tree" scheme="https://skypacer210.github.io/tags/RedBlack-Tree/"/>
    
  </entry>
  
  <entry>
    <title>调试工具杂记之OpenSSL篇</title>
    <link href="https://skypacer210.github.io/2015/02/01/debug-tool-openssl/"/>
    <id>https://skypacer210.github.io/2015/02/01/debug-tool-openssl/</id>
    <published>2015-01-31T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>OpenSSL，可以用来公私密钥对产生，证书查看（查看证书整体或者是单个信息），证书格式转化以及网络抓包，很多时候可以用于验证。</p>
<h3 id="2-利用OpenSSL进行验证"><a href="#2-利用OpenSSL进行验证" class="headerlink" title="2. 利用OpenSSL进行验证"></a>2. 利用OpenSSL进行验证</h3><p><strong>利用OpenSSL验证证书</strong>  </p>
<p>由于OpenSSL在验证证书时基于PEM格式，因此首先将非PEM格式转化为PEM格式。root证书由对方发送过来，但是server没有给，到是可以从网络抓包中export出来如图所示：  </p>
<p><img src="/assets/images/tool/extract_cert.png" alt="图片">  </p>
<ul>
<li>转化root证书<br><code>openssl x509 -inform der -in FZROOTCA.cer -out FZROOTCA.pem</code></li>
<li>查看证书<br><code>openssl x509 -in rsa_server.pem -noout –text</code>  </li>
<li>转化sever证书<br><code>openssl x509 -inform der -in rsa_server.der -out rsa_server.pem</code>  </li>
<li>利用root证书验证server证书：<br><code>openssl verify -verbose -CAfile FZROOTCA.pem  rsa_server.pem</code><br>结果显示：<br><code>rsa_server.pem: OK</code>，但貌似并不对签名进行验证，继续。</li>
</ul>
<p><strong>利用OpenSSL验证签名</strong>   </p>
<p>为了验证签名，需要将public key从证书中单独抓出来：  </p>
<p>  <code>openssl x509 -pubkey -noout -in rsa_server.pem &gt; server_pubkey.pem</code></p>
<p>同时也需要将Signature从证书中抓出来：  </p>
<p>  <code>openssl asn1parse -in rsa_server.pem -out sig -noout -strparse 614</code>  </p>
<p>利用抓出来的signature和public key进行该证书的签名验证：  </p>
<p>  <code>openssl rsautl -in sig -verify -asn1parse -inkey server_pubkey.pem –pubin</code>  </p>
<p>结果显示：  </p>
<p>  <code>RSA operation error</code><br>  <code>3177:error:0407006A:rsa routines:RSA_padding_check_PKCS1_type_1:block type is not 01:rsa_pk1.c:100:</code><br>  <code>3177:error:04067072:rsa routines:RSA_EAY_PUBLIC_DECRYPT:padding check failed:rsa_eay.c:699:</code>  </p>
<p>对应代码如下：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> 1 int RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,</div><div class="line"> 2 .       .       const unsigned char *from, int flen, int num)</div><div class="line"> 3 &#123;</div><div class="line"> 4 .       int i,j;</div><div class="line"> 5 .       const unsigned char *p;</div><div class="line"> 6 </div><div class="line"> 7 .       p=from;</div><div class="line"> 8 .       if ((num != (flen+1)) || (*(p++) != 01))</div><div class="line"> 9 .       &#123; 10 .       .       RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_BLOCK_TYPE_IS_NOT_01);</div><div class="line">11 .       .       return(-1);</div><div class="line">12 .       &#125;</div><div class="line">13 </div><div class="line">14 .       /* scan over padding data */</div><div class="line">15 .       j=flen-1; /* one for type. */</div><div class="line">16 .       for (i=0; i&lt;j; i++)</div><div class="line">17 .       &#123;</div></pre></td></tr></table></figure>
<p>从上面的结果可以得知公钥未能正确对签名解密，严重怀疑server将私钥弄错了。实际上如果解密成功，则应该是下面这个样子：  </p>
<p><img src="/assets/images/tool/sig_decrypt.png" alt="图片">  </p>
<p>其实就是遵循PKCS#1标准对数据的封装，整个明文长度和签名长度一致，都是RSA modulus个比特，上图中签名长度为2048 Bits，即256字节。第一个字节<code>00</code>意思是确保该加密块在转化为一个整数的时候其长度小于RSA的modulus。第二个字节<code>01</code>代表了这是一个私钥操作，即签名过程。然后是一大堆<code>FF</code>字节，用来填充结果，最后以<code>00</code>字节结尾。<code>30 21 30 09 06 05 2B 0E 03 02 1A 05 00 04 14</code> 则指明了HASH算法ID是SHA-1。最后的20个字节才是真正对整个证书进行HASH的结果，以此作为验证的比对对象。</p>
<h3 id="开发新功能"><a href="#开发新功能" class="headerlink" title="开发新功能"></a>开发新功能</h3><p>为了在原有安全库的基础上支持PSSRSA，需要理解此类算法的封装格式，利用OpenSSL直接可以查看此类证书的ASN1编码格式：   </p>
<p>  <code>openssl asn1parse -in pss_rsa_server.pem</code>    </p>
<p>当然OpenSSL的功能远不止这些，后续会陆续添加。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://support.citrix.com/article/CTX132907" target="_blank" rel="external">How to Extract an SSL Certificate from a Network Packet Trace File in Wireshark</a>  </li>
<li><a href="https://www.openssl.org/docs/apps/rsautl.html" target="_blank" rel="external">openssl rsautl</a>  </li>
<li><a href="https://www.madboa.com/geek/openssl/#digest-verify" target="_blank" rel="external">OpenSSL Command-Line HOWTO 1</a>  </li>
<li><a href="https://www.madboa.com/geek/openssl/" target="_blank" rel="external">OpenSSL Command-Line HOWTO 2</a>  </li>
<li><a href="http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html" target="_blank" rel="external">The First Few Milliseconds of an HTTPS Connection</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;OpenSSL，可以用来公私密钥对产生，证书查看（查看证书整体或者是单个信息），证书格式转化以及网络抓包，很多时候可以用
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="OpenSSL" scheme="https://skypacer210.github.io/tags/OpenSSL/"/>
    
      <category term="debug" scheme="https://skypacer210.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>浅谈VDI优化</title>
    <link href="https://skypacer210.github.io/2015/01/23/little-on-performance-tune/"/>
    <id>https://skypacer210.github.io/2015/01/23/little-on-performance-tune/</id>
    <published>2015-01-22T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>VDI优化涉及到诸多系统的方面，整个系统的大框架如图所示：  </p>
<p><img src="/assets/images/perf/VDI_framework.png" alt="图片"></p>
<h3 id="VDI-APP层"><a href="#VDI-APP层" class="headerlink" title="VDI APP层"></a>VDI APP层</h3><p>APP内部实现架构选择，比如是采用多进程模型还是单进程模型；  </p>
<h3 id="HTTP层"><a href="#HTTP层" class="headerlink" title="HTTP层"></a>HTTP层</h3><p>目前整体流程基于过程式交互方式，可以改为基于事情驱动的状态机实现方式；  </p>
<h3 id="SSL层"><a href="#SSL层" class="headerlink" title="SSL层"></a>SSL层</h3><p>首先评估SSL的overhead到底有多大，以及主要瓶颈，针对性的进行优化；<br>SSL双方采用的版本也影响overhead，目前SSL的版本号有SSL2.0 SSL3.0，TLS1.0(SSL3.1)，TLS1.0(SSL3.2)和TLS1.0(SSL3.3)。版本号的协商基于如下公式：  </p>
<p><code>min(max. client supported version, max. server supported version)</code>  </p>
<h3 id="TCP-IP层"><a href="#TCP-IP层" class="headerlink" title="TCP/IP层"></a>TCP/IP层</h3><p><strong>关于序列号</strong>   </p>
<ol>
<li>TCP中双方的握手和分手过程，所有报文的<code>TCP Segment Len</code>都为0。  </li>
<li><code>Window</code>就是滑动窗口，用来解决流控问题，即如何提高网络吐吞率，主要涉及到拥塞控制的参数调整。    </li>
<li><code>Sequence Number</code>用来解决乱序问题，即我发送了多少加多少（对于三次握手阶段，以报文个数为单位，即在对方<code>Acknowledgment Number</code>基础上递增1；对于数据发送阶段，以字节数为递增单位，即在自己现有的<code>Sequence Number</code>上递增<code>TCP Segment Len</code>）。</li>
<li><code>Acknowledgment Number</code>用于确认收包，解决丢包问题，即我收到了多少加多少（对于三次握手阶段，同样以报文个数为递增单位，即在对方<code>Sequence Number</code>的基础上上递增1；对于数据发送阶段，也同样以字节数为递增单位，即在自己现有的<code>Acknowledgment Number</code>上递增<code>TCP Segment Len</code>）。如图所示：</li>
</ol>
<p><img src="/assets/images/perf/tcp_seq.png" alt="图片"></p>
<p>其中客户端192.168.69.2和服务器192.168.69.1的三次握手中，服务器的<code>seq</code>是自己产生的，<code>ack</code>则是在收到客户端的SYN报文后递加1（客户端的<code>seq + 1</code>），表示收到了客户端的连接请求；客户端的<code>seq</code>也是自个产生的，发送了一个SYN，就递加1，<code>ack</code>则是在收到服务器的SYN/ACK报文后在服务端的<code>seq + 1</code>。<br>在TCP连接建立后，客户端向服务端发送一个<code>TCP Segment Len</code>为445字节的分片#4，当前<code>seq</code>为1（相对序列号），不管是否送达下一个分片#6发送时，其<code>seq</code>会忠实地递增445字节，变为446。服务端收到分片#4后，将<code>ack</code>递增445字节。</p>
<p>总之，<code>Sequence Number</code>和<code>Acknowledgment Number</code>像极了人的奋斗过程，前者好比付出，后者好比收获，但是付出不一定有收获（如果得到ACK确认则成功，否则失败）。  </p>
<p><strong>网络层：</strong>    </p>
<p>主要涉及到网络接口驱动的实现优化，比如中断轮询模式选择，是否启用DMA等。</p>
<h3 id="加入LRU-Cache"><a href="#加入LRU-Cache" class="headerlink" title="加入LRU Cache"></a>加入LRU Cache</h3><p>LRU即Least Recently Used，是一种在cache中广泛应用的算法，保持经常访问的数据节点在cache中，如果某块节点很少被访问，在达到某种阈值之后就把它交换出去，这就要求查找和插入删除都要快。本系统采用双向链表和哈希表实现，主要利用了双向链表的插入和删除操作和哈希表的查找操作，数据结构定义如下:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> 6 typedef struct __cacheNode &#123;</div><div class="line"> 7 .       ubyte4. .       .       key;</div><div class="line"> 8 .       int.    .       .       value;</div><div class="line"> 9 .       struct list_head.       node;</div><div class="line">10 &#125; cacheNode;</div><div class="line">11 </div><div class="line">12 typedef struct __LRUCache &#123;</div><div class="line">13 .       struct list_head.       first;		//指向链表头部，代表最新访问节点</div><div class="line">14 .       struct list_head.       last;		//指向链表尾部，代表最旧访问节点</div><div class="line">15 .       hashTableOfPtrs..       *cacheMap;	//哈希表</div><div class="line">16 .       int.    .       .       capacity;	//cache容量</div><div class="line">17 .       int.    .       .       curr_size;	//当前节点个数</div><div class="line">18 &#125; LRUCache;</div></pre></td></tr></table></figure>
<p>对应的操作主要就是get和put。    </p>
<ul>
<li>创建LRU cache。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">59 MSTATUS LRU_create(LRUCache **ppNewLRUCache, int capacity)</div><div class="line">60 &#123;</div><div class="line">61 .       MSTATUS..       status = OK;</div><div class="line">62 .       LRUCache.       *pNewLRU = NULL;</div><div class="line">63 .       hashTableOfPtrs.*pCacheMap;</div><div class="line">64         ubyte4. .       remain;</div><div class="line">65         ubyte4. .       count = 0;</div><div class="line">66 </div><div class="line">67 .       if (NULL == (pNewLRU = MALLOC(sizeof(LRUCache)))) &#123;</div><div class="line">68 .       .       status = ERR_MEM_ALLOC_FAIL;</div><div class="line">69 .       .       goto exit;</div><div class="line">70 .       &#125;</div><div class="line">71 </div><div class="line">72 .       MOC_MEMSET((ubyte *)(pNewLRU), 0x00, sizeof(LRUCache));</div><div class="line">73 </div><div class="line">74 .       /*Align capacity*/</div><div class="line">75 .       remain = capacity;</div><div class="line">76 .       while (remain &gt; 0) &#123;</div><div class="line">77 .       .       remain = remain &gt;&gt; 1;</div><div class="line">78 .       .       count++;</div><div class="line">79 .       &#125;</div><div class="line">80 </div><div class="line">81 .       if (OK &gt; (status = HASH_TABLE_createPtrsTable(&amp;pCacheMap, (1 &lt;&lt; count) - 1, NULL, LRU_allocHashPtrElement, LRU_freeHashPtrElement)))</div><div class="line">82 .       .       goto exit;</div><div class="line">83 </div><div class="line">84 .       pNewLRU-&gt;capacity = capacity;</div><div class="line">85 .       pNewLRU-&gt;curr_size = 0;</div><div class="line">86 .       pNewLRU-&gt;cacheMap = pCacheMap;</div><div class="line">87 .       pNewLRU-&gt;first.prev = pNewLRU-&gt;first.prev = &amp;pNewLRU-&gt;first;</div><div class="line">88 .       pNewLRU-&gt;last.prev = pNewLRU-&gt;last.prev = &amp;pNewLRU-&gt;last;</div><div class="line">89 .       *ppNewLRUCache = pNewLRU;</div><div class="line">90 exit:</div><div class="line">91 .       return status;</div><div class="line">92 &#125;</div></pre></td></tr></table></figure>
<ul>
<li>销毁LRU cache。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> 94 MSTATUS LRU_release(LRUCache *pLRUCache)</div><div class="line"> 95 &#123;</div><div class="line"> 96 .       MSTATUS status = OK;</div><div class="line"> 97 </div><div class="line"> 98 .       if (NULL == pLRUCache) &#123;</div><div class="line"> 99 .       .       status = ERR_NULL_POINTER;</div><div class="line">100 .       .       goto exit;</div><div class="line">101 .       &#125;</div><div class="line">102 </div><div class="line">103 .       HASH_TABLE_removePtrsTable(pLRUCache-&gt;cacheMap, NULL);</div><div class="line">104 .       FREE(pLRUCache);</div><div class="line">105 .       pLRUCache = NULL;</div><div class="line">106 exit:</div><div class="line">107 .       return status;</div><div class="line">108 &#125;</div></pre></td></tr></table></figure>
<ul>
<li>插入LRU node。</li>
</ul>
<p>基本思路：如果待插入数据在cache中没有（cache miss）且没有超出cache容量,就为其分配节点，插入至链表头部，表示最近访问，同时插入哈希表当中；如果待插入数据已经存在且cache已经满了，那么首先找到最后一个元素，意味着最近没有访问，从哈希表中删除，然后从双链表中删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">209 extern MSTATUS</div><div class="line">210 LRU_setNode(LRUCache *pCache, ubyte4 key, int value)</div><div class="line">211 &#123;</div><div class="line">212 .       MSTATUS..       status = OK;</div><div class="line">213 .       cacheNode.      *pNode = NULL, *pNewNode = NULL, *pLastNode = NULL;</div><div class="line">214 .       ubyte4. .       hashValue = 0;</div><div class="line">215 .       intBoolean.     foundHashValue;</div><div class="line">216 .       int.    .       hashData;</div><div class="line">217 </div><div class="line">218 .       hashData = key;</div><div class="line">219 .       HASH_VALUE_hashGen(&amp;hashData, sizeof(hashData), INIT_HASH_VALUE, &amp;hashValue);</div><div class="line">220 </div><div class="line">221 .       if (OK &gt; (status = HASH_TABLE_findPtr(pCache-&gt;cacheMap, hashValue, (void *)&amp;hashData, </div><div class="line">222 .       .       .       .       .       LRU_testKey, (void **)pNode, &amp;foundHashValue)))</div><div class="line">223 .       .       goto exit;</div><div class="line">224 </div><div class="line">225 .       if ((TRUE != foundHashValue) || (NULL == pNode)) &#123;</div><div class="line">226 .       .       if (pCache-&gt;curr_size == pCache-&gt;capacity) &#123;</div><div class="line">227 .       .       .       /*Remove last one*/</div><div class="line">228 .       .       .       pLastNode = LIST_ENTRY(pCache-&gt;last.next, cacheNode, node);</div><div class="line">229 .       .       .       hashData = (ubyte4)pLastNode-&gt;key;</div><div class="line">230 .       .       .       HASH_VALUE_hashGen(&amp;hashData, sizeof(hashData), INIT_HASH_VALUE, &amp;hashValue);</div><div class="line">231 </div><div class="line">232 .       .       .       HASH_TABLE_deletePtr(pCache-&gt;cacheMap, hashValue, (void *)&amp;hashData,</div><div class="line">233 .       .       .       .       .       LRU_testKey, (void *)pNode, &amp;foundHashValue);</div><div class="line">234 .       .       .       LRU_removeLast(pCache);</div><div class="line">235 .       .       .       if (pNode)</div><div class="line">236 .       .       .       .       FREE(pNode);</div><div class="line">237 .       .       &#125; else &#123;</div><div class="line">238 .       .       .       pCache-&gt;curr_size++;</div><div class="line">239 .       .       &#125;</div><div class="line">240 .       &#125;</div><div class="line">241 .              </div><div class="line">242 .       pNewNode = MALLOC(sizeof(cacheNode));</div><div class="line">243 .       if (NULL == pNewNode)</div><div class="line">244 .       .       status = ERR_MEM_ALLOC_FAIL;</div><div class="line">245 </div><div class="line">246 .       pNewNode-&gt;key = key;</div><div class="line">247 .       pNewNode-&gt;value = value;</div><div class="line">248 .       pNewNode-&gt;node.prev = pNewNode-&gt;node.prev = &amp;pNewNode-&gt;node;</div><div class="line">249 </div><div class="line">250 .       LRU_moveToHead(pCache, pNewNode);</div><div class="line">251 </div><div class="line">252 .       hashData = pNewNode-&gt;key;</div><div class="line">253 .       HASH_VALUE_hashGen(&amp;hashData, sizeof(hashData), INIT_HASH_VALUE, &amp;hashValue);</div><div class="line">254 .       if (OK &gt; (status = HASH_TABLE_addPtr(pCache-&gt;cacheMap, hashValue, (void *)pNewNode)))</div><div class="line">255 .       .       goto exit;</div><div class="line">256 </div><div class="line">257 exit:</div><div class="line">258 .       return status;</div><div class="line">259 &#125;</div></pre></td></tr></table></figure>
<ul>
<li>查找LRU node。</li>
</ul>
<p>如果cache miss也就罢了，如何找到了，在返回该节点之前因此需要将其移到链表的头部，因为查找某个节点意味着对该节点有了最新的访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">181 extern MSTATUS</div><div class="line">182 LRU_getNode(LRUCache *pCache, ubyte4 key, int *pValue)</div><div class="line">183 &#123;</div><div class="line">184 .       MSTATUS..       status = OK;</div><div class="line">185 .       cacheNode.      *pNode = NULL;. /*AppData*/</div><div class="line">186 .       ubyte4. .       hashValue = key;</div><div class="line">187 .       intBoolean.     foundHashValue;</div><div class="line">188 .       int.    .       hashData;</div><div class="line">189 </div><div class="line">190 .       hashData = key;</div><div class="line">191 .       HASH_VALUE_hashGen(&amp;hashData, sizeof(hashData), INIT_HASH_VALUE, &amp;hashValue);</div><div class="line">192 </div><div class="line">193 .       if (OK &gt; (status = HASH_TABLE_findPtr(pCache-&gt;cacheMap, hashValue, (void *)&amp;hashData, </div><div class="line">194 .       .       .       .       .       LRU_testKey, (void **)&amp;pNode, &amp;foundHashValue)))</div><div class="line">195 .       .       goto exit;</div><div class="line">196 </div><div class="line">197 .       if ((TRUE != foundHashValue) || (NULL == pNode)) &#123;</div><div class="line">198 .       .       status = -1;</div><div class="line">199 .       .       goto exit;</div><div class="line">200 .       &#125;</div><div class="line">201 </div><div class="line">202 .       LRU_moveToHead(pCache, pNode);</div><div class="line">203 </div><div class="line">204 .       *pValue = pNode-&gt;value;</div><div class="line">205 exit:</div><div class="line">206 .       return OK;</div><div class="line">207 &#125;</div></pre></td></tr></table></figure>
<p>实际上两个辅助函数<code>LRU_moveToHead</code>和<code>LRU_removeLast</code>的实现值得注意：   </p>
<p>其中<code>LRU_moveToHead</code>的基本实现思路就是先促成当前节点前后两个节点的牵手，然后再往前坐链表头，最后修改<code>first</code>和<code>last</code>节点。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">134 static </div><div class="line">135 void LRU_moveToHead(LRUCache *pCache, cacheNode *pNode)</div><div class="line">136 &#123;</div><div class="line">137 .       struct list_head.       *first = &amp;pCache-&gt;first;</div><div class="line">138 .       struct list_head.       *last  = &amp;pCache-&gt;last;</div><div class="line">139 .       struct list_head.       *curr = &amp;pNode-&gt;node;</div><div class="line">140 </div><div class="line">141 .       if (first == curr)</div><div class="line">142 .       .       return;</div><div class="line">143 </div><div class="line">144 .       if (NULL != curr-&gt;prev)</div><div class="line">145 .       .       curr-&gt;prev-&gt;next = curr-&gt;next;</div><div class="line">146 </div><div class="line">147 .       if (NULL != curr-&gt;next)</div><div class="line">148 .       .       curr-&gt;next-&gt;prev = curr-&gt;prev;</div><div class="line">149 </div><div class="line">150 .       if (curr == last)</div><div class="line">151 .       .       last = curr-&gt;prev;</div><div class="line">152 </div><div class="line">153 .       if (NULL != first) &#123;</div><div class="line">154 .       .       first-&gt;prev = curr;</div><div class="line">155 .       .       curr-&gt;next = first;</div><div class="line">156 .       &#125;</div><div class="line">157 </div><div class="line">158 .       first = curr;</div><div class="line">159 .       curr-&gt;prev = NULL;</div><div class="line">160 </div><div class="line">161 .       if (NULL == last)</div><div class="line">162 .       .       last = first;</div><div class="line">163 &#125;</div></pre></td></tr></table></figure>
<h3 id="TLS层的优化点"><a href="#TLS层的优化点" class="headerlink" title="TLS层的优化点"></a>TLS层的优化点</h3><p>TLS连接的建立和关闭过程如图：  </p>
<p><img src="/assets/images/perf/SSL_handshake.png" alt="图片"></p>
<p>在TLS中频繁分配释放的内存主要有以下几类：   </p>
<ul>
<li>哈希描述符和哈希值;  </li>
<li>密钥，比如masterkey为48字节;  </li>
<li>典型的小块内存，一般为64字节和96字节;    </li>
</ul>
<p>Memory Pool的主要设计思路：  </p>
<ul>
<li>每块内存都看做一个对象，预先分配好一定数量的对象，即所谓的内存池；  </li>
<li>定义get和put方法，一般成对出现，这样保证了预分配的对象数量可控；    </li>
<li>内存池内的每个对象用单向链表维护，具体操作见图；  </li>
</ul>
<p><img src="/assets/images/perf/mem_pool.jpg" alt="图片"></p>
<p>对SSL的握手过程进行对比测试，结果表明在使用mem pool的性能提升为8%左右，似乎并不理想，看来在SSL握手中此类内存的分配释放并不是影响性能的主要因素。 </p>
<h3 id="充分利用硬件加速"><a href="#充分利用硬件加速" class="headerlink" title="充分利用硬件加速"></a>充分利用硬件加速</h3><p>对于计算密集型的加解密运算，首先想到的就是利用硬件进行加速，这里有两个方面的考虑：  </p>
<ul>
<li>主存和硬件加速单元之间的IO： 数据从主存搬移至硬件，硬件将结果返回给主存  </li>
<li>对硬件处理结果的查询方式选择： 轮询还是中断？    </li>
</ul>
<p>针对上述考虑，采取的措施如下：    </p>
<ul>
<li>分析分析硬件加速的实现代码，发现其涉及到非常多固定大小内存的分配与释放，依然采用上文中的cache机制，需要注意的是硬件读写时要求地址对齐，因此对cache实现稍作修改，加入内存对齐处理。测试结果显示，后者能将性能提升50%左右(见下图)。   </li>
</ul>
<p><img src="/assets/images/perf/SSL_mcache_test.png" alt="图片"></p>
<ul>
<li>利用DMA进行数据拷贝避免动用CPU在主存和硬件加速单元之前拷贝，测试结果表明两者的性能差异大约在2倍左右。</li>
<li>分别实现中断模式和轮询模式，对比后发现轮询模式下效率更高，因此选择了轮询模式。  </li>
</ul>
<p>整体而言，采用硬件加速就是在充分利用压榨硬件计算性能的基础上尽可能减少内存拷贝和IO消耗，最后性能平均提升大约十倍左右。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VDI优化涉及到诸多系统的方面，整个系统的大框架如图所示：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/perf/VDI_framework.png&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;VDI-APP层&quot;&gt;&lt;a href=&quot;#VDI-APP
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="TLS" scheme="https://skypacer210.github.io/tags/TLS/"/>
    
      <category term="performance tune" scheme="https://skypacer210.github.io/tags/performance-tune/"/>
    
      <category term="memory pool" scheme="https://skypacer210.github.io/tags/memory-pool/"/>
    
  </entry>
  
  <entry>
    <title>同步与互斥二三事</title>
    <link href="https://skypacer210.github.io/2015/01/13/synchronization-and-exclusion/"/>
    <id>https://skypacer210.github.io/2015/01/13/synchronization-and-exclusion/</id>
    <published>2015-01-12T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-进程之间为什么需要同步"><a href="#1-进程之间为什么需要同步" class="headerlink" title="1. 进程之间为什么需要同步"></a>1. 进程之间为什么需要同步</h3><p>在顺序程序设计中，由于代码指令都是顺序执行，重复执行会得到相同的结果，即程序与计算一一对应。    </p>
<p>并发程序意味着一个程序未执行完，而另外一个程序已经开始执行，这就是所谓的并发性。并发性从宏观上反映了一个时间段内有几个进程都处于运行态但运行尚未结束的状态。从微观上看，任一时刻仅有一个进程的一个操作在处理器上运行。反过来看，并发其实就是处理器在几个进程之间的多路复用器，是对有限物理资源的强制进行多用户共享，消除计算机部件之间的互等，提供系统资源的利用率。   </p>
<p>由于交互的并发进程共享某些资源，一个进程的执行可能会影响其他或者进程的执行结果，即交互的进程之间<strong>相互制约</strong>。因此，必须对进程的交互过程进行控制，引入了各种同步机制。  </p>
<h3 id="2-互斥与同步的关系"><a href="#2-互斥与同步的关系" class="headerlink" title="2. 互斥与同步的关系"></a>2. 互斥与同步的关系</h3><h4 id="2-1-互斥"><a href="#2-1-互斥" class="headerlink" title="2.1 互斥"></a>2.1 互斥</h4><p>互斥又称为竞争，并发的引入使得原本没有竞争关系的进程在访问共享资源时发生了冲突，进程之间存在<strong>间接制约关系</strong>。在这种关系下，一个进程获得资源，另一个进程不得不阻塞等待，因此可能会导致两个严重问题：死锁与饥饿。防止不公平，或者饿死某些低优先级的进程，是调度系统必须考虑的问题。    </p>
<h4 id="2-2-同步"><a href="#2-2-同步" class="headerlink" title="2.2 同步"></a>2.2 同步</h4><p>进程同步是指为完成共同任务的并发进程基于某个条件来协调其活动，因为需要在某些位置上排定执行的<strong>先后次序</strong>而等待、传递信号或者消息所产生的协作制约关系。这种有先后次序的协作是进程之间的直接制约关系。       </p>
<p>同步是为了几个具备一些依赖性的任务一起协同工作，通信则是为了同步的手段，可以基于共享内存，也可以基于消息传递。进程之间的协作可以是比知道对方名字的协作，比如通过共享内存进行松散式协作；或者进程双方知道对方名字，通过消息机制进行紧密协作。        </p>
<p>竞争关系从某种意义上可以看成是同步，因为存在竞争关系的进程需要互斥的访问资源，也遵循<strong>互斥的访问次序</strong>。</p>
<h3 id="3-实现同步的方式"><a href="#3-实现同步的方式" class="headerlink" title="3. 实现同步的方式"></a>3. 实现同步的方式</h3><p>实现同步的方式有多种，可以基于软件，也可以基于硬件。历史上，其演变史大致由自旋锁至信号量，再到互斥锁。</p>
<h3 id="4-自旋锁"><a href="#4-自旋锁" class="headerlink" title="4. 自旋锁"></a>4. 自旋锁</h3><p>自旋锁可以通过CPU轮询机制实现同步。Spinlock作为一种临界区保护机制，在单处理器和多处理器下的实现不尽相同：  </p>
<ul>
<li>对于单处理器系统，实现互斥的最简单办法就是在进程进入临界区之前关闭中断，在进程退出临界区时开中断。因为进程的上下文切换都是由中断引起的，这样进程的执行就会被打断，因此关掉中断可以保证进行互斥的进入临界区。但不适宜作为通用的互斥机制，关中断事件过程会导致系统性能和效率下降，而且在多处理器中不适用，因为在<strong>一个处理器上关闭中断，并不能防止进程在其他处理器上执行同样的临界段代码</strong>。  </li>
<li>对于多处理器系统，可以基于xchag指令和Test and Set Lock (TSL) instruction: TSL指令这两个指令实现spinlock，因为二者都是原子操作，一个处理器在处理的时候，其余处理器只有等到处理完毕才可获取访问权，实现了对临界区的互斥访问。</li>
</ul>
<p>XCHGB的实现：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">      .globl. xchgb</div><div class="line">xchgb:</div><div class="line">      movl.   4(%esp), %edx   //edx = *((int32 *) (esp + 4));将最后一个参数赋值给ESP</div><div class="line">      movl.   8(%esp), %eax   //eax = *((int32 *) (esp + 8));将第一个参数赋值给寄存器eax</div><div class="line">      lock                    //锁住总线</div><div class="line">      xchgb.  %al, (%edx)     //交换寄存器edx和寄存器al的值</div><div class="line">      ret</div></pre></td></tr></table></figure>
<p>spinlock的实现：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">bool lock = false;</div><div class="line">bool keyi = true;</div><div class="line"></div><div class="line">spin_lock()</div><div class="line">&#123;   </div><div class="line">    </div><div class="line">    do &#123;</div><div class="line">        xchgb(&amp;keyi, lock); //xchg保证原子性操作，中间不会有中断进入</div><div class="line">    &#125; while (keyi);</div><div class="line">&#125;</div><div class="line"></div><div class="line">spin_unlock()</div><div class="line">&#123;</div><div class="line">    xchgb(&amp;keyi, lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自旋锁的适用场合与缺点：适用于<strong>临界区代码执行时间较短</strong>的场合；由于自旋锁采取忙式等待，白白浪费了CPU的时间，将能否进入临界区的责任推给了各个竞争的进程，而且<strong>只能解决竞争问题，而不能解决进程之间的协作问题</strong>。</p>
<h3 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5. 信号量"></a>5. 信号量</h3><p>信号量于1965年由Edsger Dijkstra提出，主要是为了解决并发编程中的竞争问题，其实质是二元信号量，后来Scholten在此基础上提出了通用信号量，也称为计数信号量。不管是哪一种信号量，都加入了进程调度，CPU不再大量的忙等待。</p>
<p>从信号量的等待队列中唤醒进程的算法有如下：  </p>
<ul>
<li>FIFO – 先入先出，唤醒次序由进入次序决定    </li>
<li>Priority – 优先级排序决定唤醒次序</li>
<li>Undefined – 未指定的实现算法  </li>
</ul>
<h4 id="5-1-Linux中信号量的实现"><a href="#5-1-Linux中信号量的实现" class="headerlink" title="5.1 Linux中信号量的实现"></a>5.1 Linux中信号量的实现</h4><p>Linux的信号量semaphore实质上为计数信号量。</p>
<ul>
<li><strong>semaphore定义和初始化</strong>    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">struct semaphore &#123;</div><div class="line">	raw_spinlock_t		lock;	//自旋锁，用于互斥保护</div><div class="line">	unsigned int		count;	//信号量值，若count为正值，代表进入临界区之前可用的资源总数；若count为负值，意外着在该信号量队列当中注册等待的进程个数</div><div class="line">	struct list_head	wait_list;	//信号量队列，即等待队列</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static inline void sema_init(struct semaphore *sem, int val)</div><div class="line">&#123;</div><div class="line">	static struct lock_class_key __key;</div><div class="line">	*sem = (struct semaphore) __SEMAPHORE_INITIALIZER(*sem, val);	//初始化各个字段</div><div class="line">	lockdep_init_map(&amp;sem-&gt;lock.dep_map, &quot;semaphore-&gt;lock&quot;, &amp;__key, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>semaphore的P操作</strong>  </li>
</ul>
<p>P操作也称为down操作，即请求一个资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">void down(struct semaphore *sem)</div><div class="line">&#123;</div><div class="line">	unsigned long flags;</div><div class="line"></div><div class="line">	raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);	//互斥保护信号量计数</div><div class="line">	if (likely(sem-&gt;count &gt; 0))		//如果资源个数大于0，递减</div><div class="line">		sem-&gt;count--;</div><div class="line">	else</div><div class="line">		__down(sem);	//如果资源数不大于0，则将此进程放入该信号量的等待队列。</div><div class="line">	raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static noinline void __sched __down(struct semaphore *sem)</div><div class="line">&#123;</div><div class="line">	__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static inline int __sched __down_common(struct semaphore *sem, long state,</div><div class="line">								long timeout)</div><div class="line">&#123;</div><div class="line">	struct task_struct *task = current;</div><div class="line">	struct semaphore_waiter waiter;</div><div class="line"></div><div class="line">	list_add_tail(&amp;waiter.list, &amp;sem-&gt;wait_list);	//加入信号量的等待队列</div><div class="line">	waiter.task = task;</div><div class="line">	waiter.up = false;	//设置资源释放标志位up为假</div><div class="line"></div><div class="line">	for (;;) &#123;</div><div class="line">		if (signal_pending_state(state, task))</div><div class="line">			goto interrupted;	</div><div class="line">		if (unlikely(timeout &lt;= 0))</div><div class="line">			goto timed_out;</div><div class="line">		__set_task_state(task, state);	//设置当前进程状态为TASK_UNINTERRUPTIBLE</div><div class="line">		raw_spin_unlock_irq(&amp;sem-&gt;lock);</div><div class="line">		timeout = schedule_timeout(timeout);	//当前进程sleep，超时时间为MAX_SCHEDULE_TIMEOUT</div><div class="line">		raw_spin_lock_irq(&amp;sem-&gt;lock);</div><div class="line">		if (waiter.up)	//一旦资源释放标志位up为真，返回0</div><div class="line">			return 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"> timed_out:</div><div class="line">	list_del(&amp;waiter.list);		//超时发生，将当前进程从等待队列移除，返回-ETIME</div><div class="line">	return -ETIME;</div><div class="line"></div><div class="line"> interrupted:		//中断发生，将当前进程从等待队列移除，返回-EINTR</div><div class="line">	list_del(&amp;waiter.list);</div><div class="line">	return -EINTR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>semaphore的V操作，即up操作，尝试释放一个资源</strong>  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void up(struct semaphore *sem)</div><div class="line">&#123;</div><div class="line">	unsigned long flags;</div><div class="line"></div><div class="line">	raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</div><div class="line">	if (likely(list_empty(&amp;sem-&gt;wait_list)))		//如果等待队列为空，只需将可用资源递加即可</div><div class="line">		sem-&gt;count++;</div><div class="line">	else</div><div class="line">		__up(sem);		//如果在该信号量上有等待队列，以某种调度算法唤醒一个进程。比如遵循FCFS算法</div><div class="line">	raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static noinline void __sched __up(struct semaphore *sem)</div><div class="line">&#123;</div><div class="line">	struct semaphore_waiter *waiter = list_first_entry(&amp;sem-&gt;wait_list,</div><div class="line">						struct semaphore_waiter, list);</div><div class="line">	list_del(&amp;waiter-&gt;list);		//将当前进程从等待队列中移除</div><div class="line">	waiter-&gt;up = true;		//设置资源释放标志up为真</div><div class="line">	wake_up_process(waiter-&gt;task);		//唤醒一个进程</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>信号量适用于<strong>等待时间不确定</strong>的场景，但也有其潜在的问题：  </p>
<ul>
<li><strong>Accidental release</strong>   </li>
<li><strong>Recursive deadlock</strong>  </li>
<li><strong>Task-Death deadlock</strong>  </li>
<li><strong>Cyclic Deadlock (Deadly Embrace)</strong></li>
<li><strong>Priority inversion</strong>  </li>
<li><strong>Semaphore as a signal</strong>  </li>
</ul>
<h4 id="5-2-Accidental-release"><a href="#5-2-Accidental-release" class="headerlink" title="5.2 Accidental release"></a>5.2 Accidental release</h4><p>比如没有进程P操作就进行V操作，会导致资源访问错误。    </p>
<h4 id="5-3-Recursive-deadlock"><a href="#5-3-Recursive-deadlock" class="headerlink" title="5.3 Recursive deadlock"></a>5.3 Recursive deadlock</h4><p>所谓死就是进程都在等一个永远不会为真的条件，进程试图获取一个已经lock的信号量，比如如下锁实现会存在此问题。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">typedef.char.   binary_semaphore  </div><div class="line"></div><div class="line">void</div><div class="line">init_sem(binary_semaphore *sem)</div><div class="line">&#123;</div><div class="line">.       *sem = 0;	//互斥锁初始化为0, 类型为char</div><div class="line">&#125;</div><div class="line"></div><div class="line">void</div><div class="line">P(binary_semaphore *sem)</div><div class="line">&#123;</div><div class="line">.       int.    s = spl7();	//关中断</div><div class="line"> </div><div class="line">.       while(xchgb(sem, 0xff) != 0) &#123;	//若sem已经不是0，说明已经有进程持有，则转入休眠，注意此时sem = -1;若sem还是0，说明没有进程持有，继续执行。</div><div class="line">.       .       sleep(sem, PZERO);	//1.将调用进程置成等待互斥锁sem的状态（sleep）；2.放入该互斥锁的队列当中；3.转向进程调度</div><div class="line">.       &#125;</div><div class="line">.       if (xchgb(sem, 1) != 0)		//执行前，sem为-1，再次修改sem为0xff</div><div class="line">.       .       *sem = 0xff;</div><div class="line">.       splx(s);	//开中断</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void</div><div class="line">V(binary_semaphore *sem)</div><div class="line">&#123;</div><div class="line">.       binary_semaphore old;</div><div class="line"> </div><div class="line">.       old = xchgb(sem, 0);		//返回sem旧值，并赋予新值0	</div><div class="line">.       if (old &lt; 0) </div><div class="line">.       .       wakeup(sem);		//若旧值小于0，说明有进程在该锁上等待，因此需要：1.从该锁上队列中唤醒一个； 2.放入运行队； 3.自己则继续执行</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个进程已经获取该锁，当该进程尝试再次获取该锁的时候，会再次将自己置于等待状态而无法释放。</p>
<h4 id="5-4-Task-Death-deadlock"><a href="#5-4-Task-Death-deadlock" class="headerlink" title="5.4 Task-Death deadlock"></a>5.4 Task-Death deadlock</h4><p>如果一个拥有信号量的task死亡了或者被终止了，会有什么后果？如果不能检测这种情况，所有正在等待的的task将永远都无法获得信号量从而进入死锁。  </p>
<p>为了一定程度上解决这个问题，普遍的做法是在获得信号量的函数调用中指定一个可选的超时时间。比如前文提到的Linux实现就指定了超时机制。  </p>
<h4 id="5-5-Cyclic-Deadlock-Deadly-Embrace"><a href="#5-5-Cyclic-Deadlock-Deadly-Embrace" class="headerlink" title="5.5 Cyclic Deadlock (Deadly Embrace)"></a>5.5 Cyclic Deadlock (Deadly Embrace)</h4><h4 id="5-6-Priority-Inversion"><a href="#5-6-Priority-Inversion" class="headerlink" title="5.6 Priority Inversion"></a>5.6 Priority Inversion</h4><p>大部分RTOS使用了优先级驱动的抢占调度算法。每个task拥有一个优先级，抢占调度中，低优先级的task释放CPU，使高优先级的task得以运行，这是构建一个实时操作系统的核心理念。优先级反转是指高优先级的task被低优先级的task挂起。  </p>
<h4 id="5-7-Semaphore-as-a-signal"><a href="#5-7-Semaphore-as-a-signal" class="headerlink" title="5.7 Semaphore as a signal"></a>5.7 Semaphore as a signal</h4><p>同步（Synchronization）这个词经常被错误地用于表示互斥（mutual exclusion）。根据定义，同步是：  </p>
<p><strong>To occur at the same time; be simultaneous</strong><br>一般来说，task之间的同步是指一个task在继续执行前，等待另外一个task的通知。还有一种情况是每个task都可能进入等待状态。互斥是一种保护机制，与此有很大不同。但是，这种错误的使用导致计数信号量可以被用于单向同步：初始化一个信号量，计数值为0。</p>
<p>需要注意的是，<strong>P和V并不是在同一个task中成对出现的</strong>。在这个例子中，假设Task1调用了P(S)它将被挂起。当Task2之后调用V(S)时，单向同步发生了，两个task都进入就绪状态（高优先级的task先运行）。不过，这种对信号量的误用是存在问题的，会导致调试起来非常困难，并可能导致accidental release类型的问题，因为单独的V(S)调用（不与P(S)配对）现在被编译器认为是合法的。</p>
<h3 id="6-互斥体"><a href="#6-互斥体" class="headerlink" title="6. 互斥体"></a>6. 互斥体</h3><p>为了解决信号量存在的问题，1980年提出了一种新的概念——互斥（Mutual Exclusion的缩写）。互斥与二元信号量在原理上是相似的，但有一个很大的不同：属主，这就意味着如果一个task获得了互斥体，只有这个task可以释放这个互斥体。如果某个task试图释放另一个task的互斥体，将会触发错误导致操作失败。一个没有属主的“互斥体”不能被称为互斥体。<strong>加锁与解锁只能在一个task中成对出现</strong>。</p>
<h4 id="6-1-互斥体实现"><a href="#6-1-互斥体实现" class="headerlink" title="6.1 互斥体实现"></a>6.1 互斥体实现</h4><ul>
<li><p><strong>Mutex的定义和初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">typedef.struct mtx &#123;</div><div class="line">.       spinlock_t.     lock;</div><div class="line">.       struct. thread. *owner;</div><div class="line">.       short.  .       count;</div><div class="line">.       u_char. .       flags;</div><div class="line">.       u_char. .       waiters;</div><div class="line">&#125; mutexlock_t;</div><div class="line"></div><div class="line">int</div><div class="line">mutex_init(mutexlock_t *mtx, int flags)</div><div class="line">&#123;</div><div class="line">.       memset(mtx, 0, sizeof(*mtx));</div><div class="line">.       mtx-&gt;flags = flags;</div><div class="line">.       return(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Mutex的定义和初始化</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">mutex_lock(mutexlock_t *mtx)</div><div class="line">&#123;</div><div class="line">.       if (mtx-&gt;owner == curthread) &#123;		//如果当前进程就是属主，计数递加即可</div><div class="line">.       .       mtx-&gt;count++;</div><div class="line">.       .       return(0);</div><div class="line">.       &#125;</div><div class="line"></div><div class="line">.       SPIN_LOCK_SPL0(&amp;mtx-&gt;lock);		//自旋锁进行互斥保护</div><div class="line">.       if (mtx-&gt;count &gt; 0 || mtx-&gt;waiters &gt; 0) &#123;	//</div><div class="line">.       .       do &#123;</div><div class="line">.       .       .       mtx-&gt;waiters++;		//等待计数递加</div><div class="line">.       .       .       SLEEP_SPINLOCK_UNLOCK(mtx, PZERO, &amp;mtx-&gt;lock);		//将当前进程放入互斥体的等待队列</div><div class="line">.       .       .       SPIN_LOCK_SPL0(&amp;mtx-&gt;lock);</div><div class="line">.       .       .       mtx-&gt;waiters--;</div><div class="line">.       .       &#125; while(mtx-&gt;count &gt; 0);</div><div class="line">.       &#125;</div><div class="line"></div><div class="line">.       mtx-&gt;owner = curthread;</div><div class="line">.       mtx-&gt;count = 1;</div><div class="line">.       SPIN_UNLOCK_SPL0(&amp;mtx-&gt;lock);</div><div class="line"></div><div class="line">.       return(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>Mutex的定义和初始化</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">mutex_unlock(mutexlock_t *mtx)</div><div class="line">&#123;</div><div class="line">.       assert(mtx-&gt;count &gt; 0);		//</div><div class="line">.       assert(mtx-&gt;owner == curthread);	//只有当前进程是属主的时候，才可解锁</div><div class="line">.       if (mtx-&gt;count &gt; 1) &#123;</div><div class="line">.       .       mtx-&gt;count--;</div><div class="line">.       .       return(0);</div><div class="line">.       &#125;</div><div class="line">.       SPIN_LOCK_SPL0(&amp;mtx-&gt;lock);		//互斥保护</div><div class="line">.       ASSERT(curthread-&gt;t_mutexcnt &gt; 0);</div><div class="line">.       STAT_DEC(curthread-&gt;t_mutexcnt);</div><div class="line"></div><div class="line">.       ASSERT(mtx-&gt;count == 1);</div><div class="line">.       ASSERT(mtx-&gt;owner == curthread);</div><div class="line">.       mtx-&gt;count = 0;</div><div class="line">.       mtx-&gt;owner = 0;</div><div class="line">.       if (mtx-&gt;waiters &gt; 0)</div><div class="line"> .      .       wakeup1(mtx);	//如果有等待进程，唤醒一个</div><div class="line">.       SPIN_UNLOCK_SPL0(&amp;mtx-&gt;lock);</div><div class="line">.       return(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-2-解决Accidental-release"><a href="#6-2-解决Accidental-release" class="headerlink" title="6.2 解决Accidental release"></a>6.2 解决Accidental release</h4><h4 id="6-3-解决Recursive-deadlock"><a href="#6-3-解决Recursive-deadlock" class="headerlink" title="6.3 解决Recursive deadlock"></a>6.3 解决Recursive deadlock</h4><p>如果是属主进程递归加锁，只需递加计数，不会导致一直等待。</p>
<h4 id="6-4-互斥体API"><a href="#6-4-互斥体API" class="headerlink" title="6.4 互斥体API"></a>6.4 互斥体API</h4><p>目前主流的互斥体接口主要有三类：  </p>
<ul>
<li>VxWorks Version 5.4  </li>
<li>POSIX Threads (pThreads) – IEEE Std 1003.1, 2004 Edition  </li>
<li>Microsoft Windows Win32 – Not .NET  </li>
</ul>
<h4 id="1-VxWorks"><a href="#1-VxWorks" class="headerlink" title="1. VxWorks"></a>1. VxWorks</h4><p>VxWorks主要采用VxWorks mutex，支持优先级继承。</p>
<h4 id="2-POSIX"><a href="#2-POSIX" class="headerlink" title="2. POSIX"></a>2. POSIX</h4><p>缺省的POSIX mutex不支持递归、不支持优先级继承和消亡探测机制。Linux下大多采用POSIX threads编程，支持四种Mutex类型：  </p>
<ul>
<li>Fast mutex – non-recursive and will deadlock [default]</li>
<li>Error checking mutex – non-recursive but will report error</li>
<li>Recursive mutex – as the name implies</li>
<li>Adaptive mutex – extra fast for mutli-processor systems  </li>
</ul>
<h4 id="3-Win32-API"><a href="#3-Win32-API" class="headerlink" title="3. Win32 API"></a>3. Win32 API</h4><p>window下编程接口遵循win32 API,有如下几种：  </p>
<ul>
<li>Semaphore – The counting semaphore</li>
<li>Critical Section – Mutex between threads in the same process; Recursive, no timeout, queuing order undefined</li>
<li>Mutex – As per critical sections, but can be used by threads in different processes; Recursive, timeout, queuing order undefined  </li>
</ul>
<h3 id="7-参考文献"><a href="#7-参考文献" class="headerlink" title="7. 参考文献"></a>7. 参考文献</h3><p><a href="https://github.com/windflyer/windflyer.github.io/blob/master/_posts/2013/semaphore_mutex.md" target="_blank" rel="external">semaphore_mutex</a><br><a href="https://blog.feabhas.com/2009/09/mutex-vs-semaphores-%E2%80%93-part-1-semaphores/" target="_blank" rel="external">semaphore_mutex2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-进程之间为什么需要同步&quot;&gt;&lt;a href=&quot;#1-进程之间为什么需要同步&quot; class=&quot;headerlink&quot; title=&quot;1. 进程之间为什么需要同步&quot;&gt;&lt;/a&gt;1. 进程之间为什么需要同步&lt;/h3&gt;&lt;p&gt;在顺序程序设计中，由于代码指令都是顺序执行，重复
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="Spinlock" scheme="https://skypacer210.github.io/tags/Spinlock/"/>
    
      <category term="Process" scheme="https://skypacer210.github.io/tags/Process/"/>
    
      <category term="Synchronization" scheme="https://skypacer210.github.io/tags/Synchronization/"/>
    
      <category term="Exclusion" scheme="https://skypacer210.github.io/tags/Exclusion/"/>
    
  </entry>
  
  <entry>
    <title>调试工具杂记之Wireshark篇</title>
    <link href="https://skypacer210.github.io/2015/01/07/debug-tool-wireshark/"/>
    <id>https://skypacer210.github.io/2015/01/07/debug-tool-wireshark/</id>
    <published>2015-01-06T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Wireshark作为一个使用频率极高的工具，在日常工作中发挥着不可替代的作用，下面主要结合工作中涉及的无线和安全相关部分展开说明。  </p>
<h2 id="2-WPA-WPA2-PSK抓包解密"><a href="#2-WPA-WPA2-PSK抓包解密" class="headerlink" title="2. WPA/WPA2-PSK抓包解密"></a>2. WPA/WPA2-PSK抓包解密</h2><p>对于基于PSK验证方法的网络报文，可以直接利用抓包工具进行解密。</p>
<h3 id="2-1-获取解密密钥"><a href="#2-1-获取解密密钥" class="headerlink" title="2.1. 获取解密密钥"></a>2.1. 获取解密密钥</h3><p>由于我们的目的在于分析加密报文，因此需要获取加密数据的密钥。简单的方法可以利用Wireshark的WPA Pre-shared Key Generator，原理如下：     </p>
<ul>
<li>根据PSK和SSID经过伪随机函数进行哈希计算得到PMK   </li>
<li>根据PMK和四步握手第一步AP发过来的随机数算出PTK      </li>
<li>PTK则包含了最终用于加密数据的密钥    </li>
</ul>
<p><img src="/assets/images/psk/psk_1.png" alt="图片"></p>
<h3 id="2-2-利用Wireshark解密报文"><a href="#2-2-利用Wireshark解密报文" class="headerlink" title="2.2. 利用Wireshark解密报文"></a>2.2. 利用Wireshark解密报文</h3><p>原始数据：<br><img src="/assets/images/psk/psk_2.png" alt="图片"></p>
<p>在Wireshark中针对IEEE802.11选择解密数据，添加上步计算所得密钥保存即可：   </p>
<p><img src="/assets/images/psk/psk_3.png" alt="图片"></p>
<p>这时候我们可以看到数据已经变为明文：<br><img src="/assets/images/psk/psk_4.png" alt="图片"></p>
<h2 id="3-SSL-TLS抓包解密"><a href="#3-SSL-TLS抓包解密" class="headerlink" title="3. SSL/TLS抓包解密"></a>3. SSL/TLS抓包解密</h2><h3 id="3-1-前提"><a href="#3-1-前提" class="headerlink" title="3.1. 前提"></a>3.1. 前提</h3><p>为了能够对SSL/TLS中的数据报文进行解密，要保证一下几个前提：    </p>
<p>第一：Cipher suit只能选择RSA相关，即必须强制SSL客户端使用RSA Key。如果选择了其他Cipher，比如Ephemeral Diffie-Hellman(称之为DHE) ，Elliptic Curve Diffie-Hellman(称之为TLS_ECDH)。由于在DHE中在产生DH密钥的时候，每次都用新的DH参数，如果想解密报文，必须获取每次的pre-master key。事实上，为调试方便，直接强制使用RSA Cipher即可。对于自己的客户端，直接增加对应接口即可；而对于window客户端，可以通过修改注册表进行修改：  </p>
<p><img src="/assets/images/tool/win_cipher_config.png" alt="图片">  </p>
<p>第二：能够拿到服务器证书对应的私钥，然后将其转化为PEM格式，因为只有私钥才能解密其对应公钥加密的报文。    </p>
<p>第三：确保客户端和服务器之间有一系列完整的通信报文。   </p>
<h3 id="3-2-Wireshark设置"><a href="#3-2-Wireshark设置" class="headerlink" title="3.2. Wireshark设置"></a>3.2. Wireshark设置</h3><p>Wireshark的设置很简单，见下图所示：   </p>
<p><img src="/assets/images/tool/ssl_decrypt.png" alt="图片">  </p>
<p>配置好，之后就可以对所抓报文进行解密。  </p>
<h2 id="4-数据重放"><a href="#4-数据重放" class="headerlink" title="4. 数据重放"></a>4. 数据重放</h2><p>在实际工作中，往往遇到无法直接连接服务器的情形，只能通过抓包进行分析。在其中尤以证书验证问题居多，利用Wireshark报文，既可以将server证书串直接导出，也可以以二进制文件格式导出再辅以其他解析工具导出程序进行调试。</p>
<p>这其实涉及到了数据重放的概念，将实际环境当中的运行数据进行本地化调试，具体步骤如下：   </p>
<p>第一步：获取PCAP，保存证书相关字节流。  </p>
<p><img src="/assets/images/tool/extract_cert_bin.png" alt="图片"> </p>
<p>第二步：编写脚本将hex stream转为数组，并存在一个头文件当中，该python脚本如下:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"> 1 #!/usr/bin/python</div><div class="line"> 2 </div><div class="line"> 3 def usage():</div><div class="line"> 4 .       print &apos;Usage:&apos;</div><div class="line"> 5 .       print &apos;\thex2c.py filename&apos;</div><div class="line"> 6 </div><div class="line"> 7 import sys</div><div class="line"> 8 import re</div><div class="line"> 9 </div><div class="line">10 if sys.argv[1:]:</div><div class="line">11 .       try:</div><div class="line">12 .       .       infile = open(sys.argv[1], &apos;r&apos;)</div><div class="line">13 .       except IOError, msg:</div><div class="line">14 .       .       print &apos;Can\&apos;t open &quot;%s&quot;:&apos; % sys.argv[1], msg</div><div class="line">15 .       .       sys.exit(1)</div><div class="line">16 </div><div class="line">17 .       imagename = sys.argv[1]</div><div class="line">18 .       imagename = sys.argv[1].replace(&apos;.&apos;, &apos;_&apos;)</div><div class="line">19 </div><div class="line">20 .       outfile = open(imagename + &apos;.c&apos;, &apos;w&apos;)</div><div class="line">21 </div><div class="line">22 .       content = infile.read()</div><div class="line">23 .       size = len(content)</div><div class="line">24 </div><div class="line">25 .       outfile.write(&apos;/* content of file &quot;%s&quot; */\n&apos; % sys.argv[1]);</div><div class="line">26 .       outfile.write(&apos;static unsigned char &apos; + imagename + &apos;[%d] = &#123;\n&apos;%size)</div><div class="line">27 .       process = 0</div><div class="line">28 </div><div class="line">29 .       while 1:</div><div class="line">30 .       .       if size &lt;= 0:</div><div class="line">31 .       .       .       break</div><div class="line">32 </div><div class="line">33 .       .       outstring = &apos;\t&apos;</div><div class="line">34 </div><div class="line">35 .       .       for i in range (0, 8):</div><div class="line">36 .       .       .       if ((size - i * 2) &lt;= 1) :</div><div class="line">37 .       .       .       .       break</div><div class="line">38 .       .       .       else:</div><div class="line">39 .       .       .       .       outstring += &apos;0x&apos;</div><div class="line">40 .       .       .       .       outstring += content[process + 2 * i]</div><div class="line">41 .       .       .       .       outstring += content[process + 2 * i + 1]</div><div class="line">42 .       .       .       .       outstring += &apos;, &apos;</div><div class="line">43 </div><div class="line">44 .       .       outstring += &apos;\n&apos;</div><div class="line">45 .       .       outfile.write(outstring)</div><div class="line">46 .       .       process += 16</div><div class="line">47 .       .       size -= 16</div><div class="line">48 </div><div class="line">49 .       outfile.write(&apos;&#125;;\n&apos;)</div><div class="line">50 </div><div class="line">51 .       infile.close()</div><div class="line">52 .       outfile.close()</div><div class="line">53 </div><div class="line">54 .       print &apos;Complete.&apos;</div><div class="line">55 else:</div><div class="line">56 .       usage()</div><div class="line">57 </div><div class="line">58 sys.exit(0)</div></pre></td></tr></table></figure>
<p>第三步：修改源代码，在文件中包含该头文件，使得证书验证的数据流指向该数据即可。   </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://wiki.wireshark.org/SSL" target="_blank" rel="external">Secure Socket Layer (SSL)</a>  </li>
<li><a href="http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html" target="_blank" rel="external">SSL/TLS &amp; Perfect Forward Secrecy</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Wireshark作为一个使用频率极高的工具，在日常工作中发挥着不可替代的作用，下面主要结合工作中涉及的无线和安全相关部
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="WPA" scheme="https://skypacer210.github.io/tags/WPA/"/>
    
      <category term="PSK" scheme="https://skypacer210.github.io/tags/PSK/"/>
    
      <category term="Wireshark" scheme="https://skypacer210.github.io/tags/Wireshark/"/>
    
  </entry>
  
  <entry>
    <title>基于IEEE802.1X访问控制的一点思考</title>
    <link href="https://skypacer210.github.io/2015/01/05/little-about-8021x-access-control/"/>
    <id>https://skypacer210.github.io/2015/01/05/little-about-8021x-access-control/</id>
    <published>2015-01-04T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是802-1X"><a href="#1-什么是802-1X" class="headerlink" title="1. 什么是802.1X"></a>1. 什么是802.1X</h2><p>网络层的访问控制手段有多种，最简单的就是基于MAC地址的访问控制方法；另一个就是802.1X，全称为基于端口的链路层访问控制协议，其控制思路可以比喻为居民家中的防盗锁链，当外来人员试图进入家中时，可以先将防盗锁链展开以便观察验证对方，通过后再开锁。<br>同样道理，802.1X在允许用户访问网络之前，通过EAPoL或者EAPoW报文进行验证，验证成功方可允许网络层接入，即允许IP、ARP等通过。<br>这里引入了EAP（扩展验证协议），该协议提供一种端对端的验证框架：      </p>
<ul>
<li>属于集中式访问控制管理  </li>
<li>本身并未提供具体的验证方法，而是将选择权交给上层；  </li>
<li>验证思路可以是挑战/应答模式，也可以是PKI证书模式；  </li>
<li>本身并未提供承载层，需要借助其他协议，<strong>STA和AP之间利用EAPoL协议封装EAP消息，AP和AS之间则基于RADIUS</strong>（将EAP消息封装至EADIUS的特性字段当中）    </li>
</ul>
<p>802.1X是EAP的承载层，位于OSI中的第二层，即数据链路层。数据链路层分为LLC子层和MAC子层，而MAC子层分为802.11（无线）MAC子层和802.3（大名鼎鼎的以太网）MAC子层，因此EAP相应的有EAPoL（EAP over LAN）和EAPoW（EAP over wireless）。  </p>
<p><img src="/assets/images/802.1X_stack.jpg" alt="图片"></p>
<h2 id="2-802-1X中的访问控制"><a href="#2-802-1X中的访问控制" class="headerlink" title="2. 802.1X中的访问控制"></a>2. 802.1X中的访问控制</h2><p>为了遵循网络资源的安全特性，即CIA即confidential、integrity和avability，802.1X定义了各种访问控制手段，总的过程是首先对方进行身份请求，然后进行身份验证并获得授权，最终得以访问授权范围内的资源。    </p>
<h3 id="2-1-身份验证"><a href="#2-1-身份验证" class="headerlink" title="2.1 身份验证"></a>2.1 身份验证</h3><p>802.1X提供了身份验证机制，但并不是所有的EAP方法都支持双向验证，比如EAP-MD5就只支持客户端验证。    </p>
<ul>
<li>身份验证实际上只在STA和AS之间完成，AP只负责在STA和AS之间传递信息。  </li>
<li>无论WP2/WPA-Enteprize还是WPA2/WPA-PSK，目的都是完成身份验证。  </li>
<li>EAP身份验证请求由AS发起。    </li>
</ul>
<h3 id="2-2-授权"><a href="#2-2-授权" class="headerlink" title="2.2 授权"></a>2.2 授权</h3><p>EAP验证的一个副产品是PMK，可以看做是AS对STA的授权码。  </p>
<h3 id="2-3-机密性"><a href="#2-3-机密性" class="headerlink" title="2.3 机密性"></a>2.3 机密性</h3><p>数据的机密性需要完善的密钥管理与分发机制，协议载体即EAPoL-key，由四步消息组成，称之为4-way handshake，实际上PTK产生和安装需要两步，GTK的产生的安装需要两步：第一对消息完成PTK产生和安装，第二对消息不仅完成对PTK的确认，而且产生和安装GTK。 如图所示：  </p>
<p><img src="/assets/images/802.1X_stack_2.png" alt="图片"></p>
<p>为了保证密钥在发送过程中不被篡改（完整性），需要引入验证机制，通常的做法是在消息后面附加一个校验码，这里用一个密钥做验证密钥使用；为了保证机密性，必须得有加密密钥。这几种密钥的产生过程如下：    </p>
<ul>
<li><strong>PMK转移</strong><br>EAP验证产生PMK产生之后，AS（一般是RADIUS服务器）并不保留PMK，而是转移至Authenticator(一般是AP），存于一张表中。这个过程通过RADIUS消息通知AP，然后AP传递EAP Response Success报文告知STA。<strong>四步握手由AP在这一时间点发起</strong>。    </li>
<li><strong>PTK产生</strong><br>为了加大密钥在传输过程中被破解的难度，增强随机性是常用方法之一，因此需要引入随机因素，这里在STA和AP的MAC地址的基础上引入STA和AP的随机值，由伪随机函数计算得出。由于双方必须知道对方的随机值才能算出PTK，因此必须在握手中发送给对方。根据不同的加密算法PTK产生的位数也不一致，对于TKIP是512位，CCMP是384位。    </li>
<li><strong>PTK分解</strong><br>PTK分为三个部分，KCK、KEK和TK。其中KCK用于消息验证，即用此密钥计算出完整性校验码（HMAC_SHA1算法）并附加在消息后面发给对方，对方用自己的KCK同样计算一次完整性校验码，比较二者。而KCK在<strong>PTK四步握手</strong>和<strong>GTK两步握手</strong>中几乎都会用到，除了<strong>PTK四步握手</strong>的第一条消息。KEK则用于<strong>GTK两步握手</strong>分发GTK，具体方法是用该密钥加密GTK发送给对方。 最后，TK才是真正用于数据加密的密钥，对于TKIP，由于验证密钥和加密密钥不能相同，因此对应分为两个部分；对于CCMP，验证密钥和加密密钥是一个。  </li>
</ul>
<h2 id="3-802-1X-VS-PSK"><a href="#3-802-1X-VS-PSK" class="headerlink" title="3. 802.1X VS PSK"></a>3. 802.1X VS PSK</h2><p>基于802.1X无线的安全模式一般称为WPA-Enterprise或者是WPA2-Enterprise（WPA和WPA2的差别在于前者的加密算法基于TKIP，后者则基于CCMP）；基于PSK（预共享密钥）的无线安全模式称为WPA-PSK或者WPA2-PSK。两种区别如下：  </p>
<h3 id="3-1-是否引入第三方验证"><a href="#3-1-是否引入第三方验证" class="headerlink" title="3.1 是否引入第三方验证"></a>3.1 是否引入第三方验证</h3><p>WPA/WPA2-Enterprise需要RADIUS服务器（需要STA和RADIUS服务器协商出PMK，然后由服务器把PMK交给AP），可以覆盖更多的范围；而WPA/WPA2-PSK则不要用，直接由PSK在AP和STA两边各自计算出同样的PMK。  </p>
<h3 id="3-2-验证对象不同"><a href="#3-2-验证对象不同" class="headerlink" title="3.2 验证对象不同"></a>3.2 验证对象不同</h3><p>WPA/WPA2-Enterprise可以验证双方，取决于EAP方法的选择，而WPA/WPA2-PSK只能验证客户端，即STA。  </p>
<h3 id="3-3-是否支持机器验证"><a href="#3-3-是否支持机器验证" class="headerlink" title="3.3 是否支持机器验证"></a>3.3 是否支持机器验证</h3><p>WPA/WPA2-Enterprise支持机器验证，而WPA/WPA2-PSK只支持用户验证。  </p>
<h3 id="3-4-访问控制的粒度不同"><a href="#3-4-访问控制的粒度不同" class="headerlink" title="3.4 访问控制的粒度不同"></a>3.4 访问控制的粒度不同</h3><p>如果要禁止某个用户访问，对于WPA/WPA2-Enterprise只需吊销该用户的访问权限即可；而对于WPA/WPA2-PSK，一旦修改密码意味着所有用户都无法访问。因此，前者相比后者在访问控制的粒度上更为精细。        </p>
<h3 id="3-5-安全性不同"><a href="#3-5-安全性不同" class="headerlink" title="3.5 安全性不同"></a>3.5 安全性不同</h3><p>从安全角度来看，WPA/WPA2-PSK的主要缺陷如下：    </p>
<ul>
<li>用于身份验证的密码是面向所有用户的，一旦被破解，所有用户都面临数据泄露的危险。  </li>
<li>WPA/WPA2-PSK模式下暴露给嗅探着的数据报文更多，因为相同的PMK被不同的用户同时使用。  </li>
<li>不支持密钥更新，更易遭受蛮力攻击。   </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-什么是802-1X&quot;&gt;&lt;a href=&quot;#1-什么是802-1X&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是802.1X&quot;&gt;&lt;/a&gt;1. 什么是802.1X&lt;/h2&gt;&lt;p&gt;网络层的访问控制手段有多种，最简单的就是基于MAC地址的访问控制
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="802.1X" scheme="https://skypacer210.github.io/tags/802-1X/"/>
    
      <category term="EAP" scheme="https://skypacer210.github.io/tags/EAP/"/>
    
  </entry>
  
  <entry>
    <title>Cloud Application设计模式之Event Sourcing Pattern</title>
    <link href="https://skypacer210.github.io/2014/12/31/event-sourcing-pattern/"/>
    <id>https://skypacer210.github.io/2014/12/31/event-sourcing-pattern/</id>
    <published>2014-12-30T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对Event Sourcing Pattern的设计细节做一个粗略介绍~  </p>
<p>原文链接<a href="http://msdn.microsoft.com/en-us/library/dn589792.aspx/" target="_blank" rel="external">Event Sourcing Pattern</a>  </p>
<hr>
<h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>大多数的应用处理数据，典型的操作就是通过更新用户的数据维护当前的状态。比如CRUD数据操作模式，即创建、读、更新和删除数据，一般的做法是从数据仓库读取数据，对数据进行修改，然后用最新的值更新数据状态，上述操作往往通过锁实现。  </p>
<p>CURD方式的不足之处：  </p>
<ul>
<li>CRUD系统直接对数据仓库进行更新操作会导致性能降低、而且不利于系统扩展。  </li>
<li>在一个协作系统里面，多个并发用户在进行数据更新的时候会发生冲突  </li>
<li>从审计的角度考虑，每个操作记录在单独的日志中，丢失了历史信息。  </li>
</ul>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>事件源模式（event souring pattern）定义了一种对序列化事件驱动数据的操作方法，每个事件都是以累加方式（append-only）进行存储。APP代码发送一系列事件至数据存储，以命令式方式描述每一个动作。同时，数据一致性在数据存储中完成。每个事件代表了对数据的一个属性的改变。<br>完成一致性处理的事件存储在event store，作为数据当前状态的信任源或系统记录（或者称之为已授权数据源中的给定元素或信息片段）。典型地，Event store发布这些事件，这样能够通知到消费者并做相应的处理。作为消费者也可以对其他系统应用执行事件群的动作，或者是完成该操作所需的关联动作。我们可以看到用于产生事件的APP代码与注册了事件的系统之前是解耦的。<br>通过Event store发布事件的一个典型应用就是当APP改变目录行为后对物化视图的维护，并且能够与外部系统集成。比如一个显示了所有客户订单的物化视图，用于产生UI的部分组件。当APP添加或者删除订单时，描述上述行为的事件能够被处理，以更新物化视图。    </p>
<p><img src="/assets/images/Event_Sourcing_Pattern_1.jpg" alt="图片"></p>
<p>The Event Sourcing pattern provides many advantages, including the following:  </p>
<ul>
<li>Events are immutable and so can be stored using an append-only operation. The user interface, workflow, or process that initiated the action that produced the events can continue, and the tasks that handle the events can run in the background. This, combined with the fact that there is no contention during the execution of transactions, can vastly improve performance and scalability for applications, especially for the presentation level or user interface.</li>
<li>Events are simple objects that describe some action that occurred, together with any associated data required to describe the action represented by the event. Events do not directly update a data store; they are simply recorded for handling at the appropriate time. These factors can simplify implementation and management.</li>
<li>Events typically have meaning for a domain expert, whereas the complexity of the object-relational impedance mismatch might mean that a database table may not be clearly understood by the domain expert. Tables are artificial constructs that represent the current state of the system, not the events that occurred.</li>
<li>Event sourcing can help to prevent concurrent updates from causing conflicts because it avoids the requirement to directly update objects in the data store. However, the domain model must still be designed to protect itself from requests that might result in an inconsistent state.</li>
<li>The append-only storage of events provides an audit trail that can be used to monitor actions taken against a data store, regenerate the current state as materialized views or projections by replaying the events at any time, and assist in testing and debugging the system. In addition, the requirement to use compensating events to cancel changes provides a history of changes that were reversed, which would not be the case if the model simply stored the current state. The list of events can also be used to analyze application performance and detect user behavior trends, or to obtain other useful business information.</li>
<li>The decoupling of the events from any tasks that perform operations in response to each event raised by the event store provides flexibility and extensibility. For example, the tasks that handle events raised by the event store are aware only of the nature of the event and the data it contains. The way that the task is executed is decoupled from the operation that triggered the event. In addition, multiple tasks can handle each event. This may enable easy integration with other services and systems that need only listen for new events raised by the event store. However, the event sourcing events tend to be very low level, and it may be necessary to generate specific integration events instead.</li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p><img src="/assets/images/Event_Sourcing_Pattern_2.jpg" alt="图片"></p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>TODO</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对Event Sourcing Pattern的设计细节做一个粗略介绍~  &lt;/p&gt;
&lt;p&gt;原文链接&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dn589792.aspx/&quot; target=&quot;_blank&quot; rel
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="Cloud Design Pattern" scheme="https://skypacer210.github.io/tags/Cloud-Design-Pattern/"/>
    
      <category term="Event-Driven" scheme="https://skypacer210.github.io/tags/Event-Driven/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu上安装NS-3实践</title>
    <link href="https://skypacer210.github.io/2014/12/26/building-ns-3-on-ubuntu/"/>
    <id>https://skypacer210.github.io/2014/12/26/building-ns-3-on-ubuntu/</id>
    <published>2014-12-25T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>##1 概述 ##  </p>
<p>本文记录了NS-3模拟器在Ubuntu12.04桌面版上的完整安装记录。  </p>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h2><p>NS-3的安装方法有两种，一种是利用bake工具自动化安装，另一种是手动安装，安装包的下载可以通过Mercurial或则是直接下载tar包。<br>由于Bake工具安装陷入超时，因此直接采用基于Mercurial的手动安装。</p>
<h3 id="2-1-依赖软件包安装"><a href="#2-1-依赖软件包安装" class="headerlink" title="2.1 依赖软件包安装"></a>2.1 依赖软件包安装</h3><p>Bake本身提供依赖包检测，这里直接将所需包安装成功。  </p>
<pre><code>
apt-get install mercurial
apt-get install qt4-dev-tools
apt-get install gdb valgrind
apt-get install gsl-bin libgsl0-dev libgsl0ldbl
apt-get install flex bison libfl-dev
apt-get install tcpdump
apt-get install sqlite sqlite3 libsqlite3-dev
apt-get install libxml2 libxml2-dev
apt-get install libgtk2.0-0 libgtk2.0-dev
apt-get install vtun lxc
apt-get install uncrustify
apt-get install doxygen graphviz imagemagick
apt-get install python-sphinx dia
apt-get install python-pygraphviz python-kiwi python-pygoocanvas libgoocanvas-dev
apt-get install libboost-signals-dev libboost-filesystem-dev
apt-get install openmpi-bin openmpi-common openmpi-doc libopenmpi-dev
</code></pre>


<h4 id="2-2-建立工作目录"><a href="#2-2-建立工作目录" class="headerlink" title="2.2 建立工作目录"></a>2.2 建立工作目录</h4><pre><code>
mkdir workspace
cd workspace
mkdir repos
cd repos
hg clone http://code.nsnam.org/ns-3-allinone
</code></pre>

<p>过程：</p>
<pre><code>
requesting all changes
adding changesets
adding manifests
adding file changes
</code></pre>

<p>最终生成ns-3-allinone目录。</p>
<h3 id="2-3-利用Mercurial下载ns-3-dev"><a href="#2-3-利用Mercurial下载ns-3-dev" class="headerlink" title="2.3 利用Mercurial下载ns-3-dev"></a>2.3 利用Mercurial下载ns-3-dev</h3><pre><code>
./download.py -n ns-3-dev
</code></pre>

<p>下载过程：  </p>
<pre><code>
    #
    # Get NS-3
    #

Cloning ns-3 branch
 =>  hg clone http://code.nsnam.org/ns-3-dev ns-3-dev
requesting all changes
adding changesets
adding manifests
adding file changes
...
added 11117 changesets with 52385 changes to 7390 files
updating to branch default
2998 files updated, 0 files merged, 0 files removed, 0 files unresolved

    #
    # Get PyBindGen
    #

Required pybindgen version:  0.17.0.886
Trying to fetch pybindgen; this will fail if no network connection is available.  Hit Ctrl-C to skip.
 =>  bzr checkout -rrevno:886 https://launchpad.net/pybindgen pybindgen
Fetch was successful.                                                                                         

    #
    # Get NetAnim
    #

Required NetAnim version:  netanim-3.105
Retrieving NetAnim from http://code.nsnam.org/netanim
 =>  hg clone http://code.nsnam.org/netanim netanim
requesting all changes
adding changesets
adding manifests
adding file changes
added 275 changesets with 1533 changes to 228 files
updating to branch default
196 files updated, 0 files merged, 0 files removed, 0 files unresolved

    #
    # Get bake
    #

Retrieving bake from http://code.nsnam.org/bake
 =>  hg clone http://code.nsnam.org/bake
destination directory: bake
requesting all changes
adding changesets
adding manifests
adding file changes
added 333 changesets with 790 changes to 63 files
updating to branch default
45 files updated, 0 files merged, 0 files removed, 0 files unresol
</code></pre>

<h3 id="2-4-编译"><a href="#2-4-编译" class="headerlink" title="2.4 编译"></a>2.4 编译</h3><p>NS-3的编译借助build.py脚本工具。</p>
<pre><code>
./build.py
</code></pre>

<p>但是会碰到如下错误：  </p>
<pre><code>
[1459/1770] cxx: src/lte/model/lte-ffr-sap.cc -> build/src/lte/model/lte-ffr-sap.cc.1.o
[1460/1770] cxx: src/lte/model/lte-fr-no-op-algorithm.cc -> build/src/lte/model/lte-fr-no-op-algorithm.cc.1.o
[1461/1770] cxx: src/lte/model/lte-ffr-soft-algorithm.cc -> build/src/lte/model/lte-ffr-soft-algorithm.cc.1.o
[1462/1770] cxx: src/lte/model/lte-ue-power-control.cc -> build/src/lte/model/lte-ue-power-control.cc.1.o
[1463/1770] cxx: build/src/lte/bindings/ns3module.cc -> build/src/lte/bindings/ns3module.cc.7.o
g++: internal compiler error: Killed (program cc1plus)
Please submit a full bug report,
with preprocessed source if appropriate.
See <file: usr="" share="" doc="" gcc-4.6="" readme.bugs=""> for instructions.
Waf: Leaving directory `/home/fyang/project/workspace/repos/ns-3-allinone/ns-3-dev/build'
Build failed
 -> task in 'ns3module_lte' failed (exit status 4): 
    {task 159048492: cxx ns3module.cc -> ns3module.cc.7.o}
['/usr/bin/g++', '-O0', '-ggdb', '-g3', '-Wall', '-Werror', '-Wno-error=deprecated-declarations', '-fstrict-alid', '-fno-strict-aliasing', '-fwrapv', '-fstack-protector', '-fno-strict-aliasing', '-fvisibility=hidden', '-Wn, '-I..', '-Isrc/lte/bindings', '-I../src/lte/bindings', '-I/usr/include/python2.7', '-I/usr/include/gtk-2.0', -I/usr/include/atk-1.0', '-I/usr/include/cairo', '-I/usr/include/gdk-pixbuf-2.0', '-I/usr/include/pango-1.0', 'glib-2.0', '-I/usr/lib/i386-linux-gnu/glib-2.0/include', '-I/usr/include/pixman-1', '-I/usr/include/freetype2',bxml2', '-DNS3_ASSERT_ENABLE', '-DNS3_LOG_ENABLE', '-DHAVE_SYS_IOCTL_H=1', '-DHAVE_IF_NETS_H=1', '-DHAVE_NET_ETTE3=1', '-DHAVE_IF_TUN_H=1', '-DHAVE_GSL=1', '-DNS_DEPRECATED=', '-DNS3_DEPRECATED_H', '-DNDEBUG', 'src/lte/binings/ns3module.cc.7.o']
Traceback (most recent call last):
  File "./build.py", line 170, in <module>
    sys.exit(main(sys.argv))
  File "./build.py", line 161, in main
    build_ns3(config, build_examples, build_tests, args, build_options)
  File "./build.py", line 81, in build_ns3
    run_command([sys.executable, "waf", "build"] + build_options)
  File "/home/fyang/project/workspace/repos/ns-3-allinone/util.py", line 24, in run_command
    raise CommandError("Command %r exited with code %i" % (argv, retval))
util.CommandError: Command ['/usr/bin/python', 'waf', 'build'] exited with code 1
</module></file:></code></pre>

<p>似乎是g++编译器自身的问题，解决办法是利用swap:  </p>
<pre><code>
sudo dd if=/dev/zero of=/swapfile bs=64M count=16
sudo mkswap /swapfile
sudo swapon /swapfile
</code></pre>

<p>编译完成后删除：  </p>
<pre><code>
sudo swapoff /swapfile
sudo rm /swapfile
</code></pre>

<p>如果成功，则显示：  </p>
<pre><code>
Waf: Leaving directory `/home/fyang/project/workspace/repos/ns-3-allinone/ns-3-dev/build'
'build' finished successfully (7m31.696s)
Modules built:
antenna                   aodv                      applications             
bridge                    buildings                 config-store             
core                      csma                      csma-layout              
dsdv                      dsr                       energy                   
fd-net-device             flow-monitor              internet                 
lr-wpan                   lte                       mesh                     
mobility                  mpi                       netanim (no Python)      
network                   nix-vector-routing        olsr                     
point-to-point            point-to-point-layout     propagation              
sixlowpan                 spectrum                  stats                    
tap-bridge                test (no Python)          topology-read            
uan                       virtual-net-device        visualizer               
wave                      wifi                      wimax                    

Modules not built (see ns-3 tutorial for explanation):
brite                     click                     openflow                 

Leaving directory `./ns-3-dev
</code></pre>

<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h2><h3 id="3-1-添加实例程序"><a href="#3-1-添加实例程序" class="headerlink" title="3.1 添加实例程序"></a>3.1 添加实例程序</h3><p>Waf工具用于脚本运行，并保证共享库在运行时处在正确位置。 通过修改Waf程序配置，添加实例程序：</p>
<pre><code>
$ ./waf clean
$ ./waf configure --enable-examples --enable-tests --enable-modules=core
$ ./waf build
</code></pre>

<h3 id="3-2-单元测试"><a href="#3-2-单元测试" class="headerlink" title="3.2 单元测试"></a>3.2 单元测试</h3><p>NS-3自带单元测试功能，有了上述实程序之后，进行验证：    </p>
<pre><code>
fyang@fyang-virtual-machine:~/project/workspace/repos/ns-3-allinone/ns-3-dev$ ./test.py 
Waf: Entering directory `/home/fyang/project/workspace/repos/ns-3-allinone/ns-3-dev/build'
Waf: Leaving directory `/home/fyang/project/workspace/repos/ns-3-allinone/ns-3-dev/build'
'build' finished successfully (0.210s)

Modules built:
core                     

Modules not built (see ns-3 tutorial for explanation):
brite                     click                     openflow                 

PASS: TestSuite attributes
PASS: TestSuite callback
PASS: TestSuite command-line
PASS: TestSuite config
PASS: TestSuite global-value
PASS: TestSuite int64x64
PASS: TestSuite object-name-service
PASS: TestSuite object
PASS: TestSuite ptr
PASS: TestSuite event-garbage-collector
PASS: TestSuite sample
PASS: TestSuite simulator
PASS: TestSuite time
PASS: TestSuite timer
PASS: TestSuite traced-callback
PASS: TestSuite type-traits
PASS: TestSuite watchdog
PASS: TestSuite hash
PASS: TestSuite type-id
PASS: TestSuite threaded-simulator
PASS: TestSuite random-number-generators
PASS: TestSuite random-variable-stream-generators
PASS: Example examples/tutorial/hello-simulator
PASS: Example examples/tutorial/fourth
PASS: Example src/core/examples/main-callback
PASS: Example src/core/examples/sample-simulator
PASS: Example src/core/examples/main-ptr
PASS: Example src/core/examples/sample-random-variable
PASS: Example src/core/examples/sample-simulator.py
</code></pre>  

<h3 id="3-3-运行测试"><a href="#3-3-运行测试" class="headerlink" title="3.3 运行测试"></a>3.3 运行测试</h3><p>运行模拟器：  </p>
<pre><code>
./waf --run hello-simulator
</code></pre> 
结果：    
<pre><code>  
Waf: Entering directory `/home/fyang/project/workspace/repos/ns-3-allinone/ns-3-dev/build'
Waf: Leaving directory `/home/fyang/project/workspace/repos/ns-3-allinone/ns-3-dev/build'
'build' finished successfully (0.202s)
Hello Simulator
</code></pre>


<h2 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4 参考文献"></a>4 参考文献</h2><ol>
<li><a href="http://www.roguelynn.com/words/explain-like-im-5-kerberos/" target="_blank" rel="external">explain-like-im-5-kerberos</a> </li>
<li><a href="https://cryptocointalk.com/topic/14840-how-to-solve-g-internal-compiler-error-killed-program-cc1plus/" target="_blank" rel="external">g++ error</a></li>
<li><a href="https://www.nsnam.org/wiki/HOWTO_enable/disable_examples_and_tests_in_ns-3" target="_blank" rel="external">使能测试程序1</a></li>
<li><a href="http://www.nsnam.org/docs/manual/html/enable-modules.html" target="_blank" rel="external">使能测试程序2</a><br><a href="http://www.nsnam.org/docs/release/3.10/tutorial/html/getting-started.html" target="_blank" rel="external">getting-started</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##1 概述 ##  &lt;/p&gt;
&lt;p&gt;本文记录了NS-3模拟器在Ubuntu12.04桌面版上的完整安装记录。  &lt;/p&gt;
&lt;h2 id=&quot;2-安装&quot;&gt;&lt;a href=&quot;#2-安装&quot; class=&quot;headerlink&quot; title=&quot;2 安装&quot;&gt;&lt;/a&gt;2 安装&lt;/h2&gt;
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="NS-3" scheme="https://skypacer210.github.io/tags/NS-3/"/>
    
      <category term="Python" scheme="https://skypacer210.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Token VS Cookie</title>
    <link href="https://skypacer210.github.io/2014/12/16/token-vs-cookie/"/>
    <id>https://skypacer210.github.io/2014/12/16/token-vs-cookie/</id>
    <published>2014-12-15T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>#1 概述<br>Client请求server端应用时，server端的验证方法有两种：  </p>
<ol>
<li>最常见的cookie-based Authentication：  Serve端发送给client的cookie，这样client每次登陆的时候server只需验证cookie即可。Cookie可以存在内存或者硬盘中。  </li>
<li>基于token的验证：<br>client收到签发的token之后，以后每次登陆需要发送至server端。</li>
</ol>
<p>#2 Token相比于cookie的优点</p>
<ul>
<li>Cross-domain/CORS:<br>Cookie + CORS 在不同的域之间工作的不是很好，token方法允许你利用AJAX调用至任何server和任何域，因为你利用HTTP头传递用户信息。<br>比如说SAML Tokens, SAML(Security Assertion Markup Language) tokens是一种标准化的基于XML的token，可以提供跨平台交互，而且client和server无需再同一个安全域内。  </li>
<li>无状态：<br>Server端无需维护一个session的存储，token本身是一个包含所有用户信息的实体。Cookie则存在状态，并且必须保存在client端。</li>
<li>CDN：<br>Sever端可以提供所有的APP特性，只需通过API访问CDN即可。</li>
<li>解耦：<br>无需绑定某个特定的验证方案，token可以在任何地方产生，因为你能够在任何地方以一种方式调用这些API。  </li>
<li>性能<br>计算HMAC-SHA256似乎效率更高</li>
<li>标准化：<br>你的API可以接受标准的JWT(JSON Web Token)。</li>
</ul>
<p>#3 Token存储<br>Token可以存储在三个地方：session storage/local storage/client side cookie。 如果存储在cookie中，利用了cookie的存储机制，而不是验证机制。  </p>
<p>#4 Token的生命周期<br>Token和cookie都有生命周期。  </p>
<ol>
<li>对于cookie而言，控制器生命周期有如下选择：  </li>
</ol>
<ul>
<li>Session cookie在浏览器关闭后被销毁；  </li>
<li>可以实现一个server端的检查，避免过期；  </li>
<li>Cookie可以在生命周期内是永久的，即浏览器关闭后不销毁。  </li>
</ul>
<ol>
<li>对Token而言，一旦token过期，你需要一个新的，可以用如下的更新机制：  </li>
</ol>
<ul>
<li>验证留的token；  </li>
<li>检查用户是否仍旧存在或者访问权限被吊销；  </li>
<li>签发一个更新了有效期的token</li>
</ul>
<p>#5 Token缺点</p>
<ol>
<li>对于大公司而言，token可能变得很大  </li>
<li>开发者的APP或者API变得更加复杂  </li>
<li>维护的时间成本较高<br>#6 Token VS Certificate VS Ticket<br>三者都是引入了第三方机构,以window的验证模式为例：  </li>
<li>Token：SAML Token，引入STS(Security Token Service)作为第三方机构  </li>
<li>Certificate：引入CA，即X.509 PKI架构  </li>
<li>Ticket：基于Kerberos的验证架构，引入TGS和AS作为KDC  </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#1 概述&lt;br&gt;Client请求server端应用时，server端的验证方法有两种：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最常见的cookie-based Authentication：  Serve端发送给client的cookie，这样client每次登陆的时候serve
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="token" scheme="https://skypacer210.github.io/tags/token/"/>
    
      <category term="cookie" scheme="https://skypacer210.github.io/tags/cookie/"/>
    
      <category term="http authentication" scheme="https://skypacer210.github.io/tags/http-authentication/"/>
    
  </entry>
  
  <entry>
    <title>OAuth 2.0初探</title>
    <link href="https://skypacer210.github.io/2014/12/08/authorization-code-flow-in-oauth-20/"/>
    <id>https://skypacer210.github.io/2014/12/08/authorization-code-flow-in-oauth-20/</id>
    <published>2014-12-07T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OAuth解决什么问题"><a href="#OAuth解决什么问题" class="headerlink" title="OAuth解决什么问题"></a>OAuth解决什么问题</h3><h3 id="1、场景"><a href="#1、场景" class="headerlink" title="1、场景"></a>1、场景</h3><p>某孕妇Mrs.Lily向她的私人医生Dr.Michael申请做胎心监护，Dr.Michael了解到Mrs.Lily在医院A.Hospital做过类似的检查，因此Dr.Michael希望访问A.Hospital的在线系统获取Mrs.Lily的相关数据，最直接的方法就是向Mrs.Lily索要其在A.Hospital在线系统用户名和密码。<br>那么问题来了，该方法会造成哪些潜在安全威胁？    </p>
<ul>
<li>Dr.Michael会保存用户Mrs.Lily的密码，很不安全  </li>
<li>Dr.Michael拥有了获取用户Mrs.Lily在A.Hospital在线系统的所有资料的权利，这样用户无法限制Dr.Michael的授权范围和时间  </li>
<li>Mrs.Lily只有修改其密码，才能收回赋予Dr.Michael的权力，但同时也使得其他获得Mrs.Lily授权的访问应用失效  </li>
</ul>
<h3 id="2、OAuth的特点"><a href="#2、OAuth的特点" class="headerlink" title="2、OAuth的特点"></a>2、OAuth的特点</h3><p>OAuth解决了上述问题，即定义了一种允许一个APP访问用户相关的其他APP的验证机制，比如用户可以利用QQ账号登陆其他APP。基本思路如下：   </p>
<ol>
<li>OAuth在“客户端”与“服务提供商”之间，设置了一个授权层（authorization layer）。 “客户端”不能直接登陆和访问“服务提供商”，只能登陆授权层，这样就把用户和客户端分隔开来。  </li>
<li>“客户端”不在使用密码，而是令牌(token),可以在登陆的时候指定授权范围和有效期限。  </li>
<li>“客户端”登陆授权层之后，“服务提供商”根据令牌的授权范围和有效期限，以决定向客户开放哪些信息。  </li>
</ol>
<h3 id="OAuth工作流程"><a href="#OAuth工作流程" class="headerlink" title="OAuth工作流程"></a>OAuth工作流程</h3><p>待续。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="http://architecture-soa-bpm-eai.blogspot.com/2012/08/oauth-20-for-my-ninth-grader.html" target="_blank" rel="external">oauth-20-for-my-ninth-grader</a>  </li>
<li><a href="http://liboauth.sourceforge.net/" target="_blank" rel="external">liboauth in C</a></li>
</ol>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;OAuth解决什么问题&quot;&gt;&lt;a href=&quot;#OAuth解决什么问题&quot; class=&quot;headerlink&quot; title=&quot;OAuth解决什么问题&quot;&gt;&lt;/a&gt;OAuth解决什么问题&lt;/h3&gt;&lt;h3 id=&quot;1、场景&quot;&gt;&lt;a href=&quot;#1、场景&quot; class=&quot;
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="OAuth" scheme="https://skypacer210.github.io/tags/OAuth/"/>
    
      <category term="Authorization" scheme="https://skypacer210.github.io/tags/Authorization/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议栈中的数据收发</title>
    <link href="https://skypacer210.github.io/2014/12/02/little-on-tcpip-stack/"/>
    <id>https://skypacer210.github.io/2014/12/02/little-on-tcpip-stack/</id>
    <published>2014-12-01T16:00:00.000Z</published>
    <updated>2017-08-09T14:22:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对TCP/IP的数据收发做一个粗略总结~    </p>
<hr>
<h3 id="1、TCP-IP基本特点"><a href="#1、TCP-IP基本特点" class="headerlink" title="1、TCP/IP基本特点"></a>1、TCP/IP基本特点</h3><p>TCP/IP总的设计目的就是保证数据的快速有序的传输，且无丢失，基本特点如下：  </p>
<ul>
<li><strong>面向连接</strong>：两端组成一个连接，每端以五元组为标识</li>
<li><strong>双工字节流</strong>： 采用字节流进行双工数据通信</li>
<li><strong>有序发送</strong>：利用序列号保证发送的有序性</li>
<li><strong>可靠性</strong>：利用ACK保证数据的可靠性</li>
<li><strong>流控</strong>：接收方利用接收窗口通告发送方</li>
<li><strong>拥塞控制</strong>：接收方利用拥塞窗口通告发送方  </li>
</ul>
<h3 id="2、报文发送过程"><a href="#2、报文发送过程" class="headerlink" title="2、报文发送过程"></a>2、报文发送过程</h3><p>TCP/IP网络协议栈包含多个层次，下图以一个TCP连接中的报文发送过程简述其基本流程：</p>
<p><img src="/assets/images/TCP/tx.jpg" alt="图片">  </p>
<center>Figure 1: TX flow</center>

<ol>
<li>用户层创建数据，调用write系统调用发送数据。</li>
<li>一旦执行系统调用，系统则进入内核层。对于类Linux系统，通过文件描述符关联socket和应用，内核中socket包含收发两块buffer。</li>
<li>在系统调用执行数据将被拷贝至内核memory当中，然后添加至发送buffer尾部，即按序发送。</li>
<li>在TCP层，TCB(TCP Control Block) 关联socket，如果TCP允许数据发送，内核创建TCP segment。否则，由于规则或者流量控制会将该报文丢弃。至于TCP segment报文格式，无外乎一个header加payload，还有个checksum。TCP校验和往往由网卡进行计算。</li>
<li>继续在TCP segment上封装IP层，再算下IP校验和，就可以扔给网络层了，比如以太网层。</li>
<li>以太网层开始查找下一跳IP的MAC地址，一旦完成将继续封装Etherent头，最终送往driver层，这里往往也是各大抓包工具进行数据拷贝的地方，比如tcpdump/wirshark，或者是自己写的抓包工具；流量整形也往往在这一层完成。</li>
<li>driver层在收到发送请求之后，通过DMA将该主存中的数据拷贝至内部RAM之中。在数据拷贝中，同时加入符合以太网协议的相关header，IFG、前导符和CRC。对于以太网网络，物理层发送采用CSMA/CD,即在发送过程中侦听链路冲突；而对于Wi-Fi网络，则采用CSMA/CA，其基本思想是要想占用channel并发言，首先做好聆听（也是做人哲学之一），对于需要ACK的报文，一旦在规定时间内搜不到ACK，则重传该报文。</li>
<li>一旦网卡完成报文发送，将产生中断通知CPU。</li>
</ol>
<p>对于报文发送过程而言，上层协议栈是生产者，驱动层为消费者。  </p>
<p>下面以无线网卡驱动为例详述整个报文发送流程的实现细节：      </p>
<ul>
<li>上层协议栈（三层及以上）和驱动层之间的数据传递采用队列，一个网络接口绑定一个三层报文发送队列。802.11 MAC层从网络接口的发送队列中拿到三层报文，添加LLC层和802.11 header，此时二层报文已经组好。  </li>
<li>驱动层同样采用一个二层报文发送队列，可以将上一步组好的二层报文放入该队列。驱动的任务就是把二层报文送入无线网卡的硬件FIFO，最终转为射频信号发送。软硬件交互通过一个循环缓冲区完成，具体而言，首先主存中定义一个TX Ring，包括多个TFD（发送描述符），其中一个TFD可以由多个TB（发送缓冲区）组成，里面除了包含要发送的数据，还包含了发送相关的控制信息；数据在DRAM和硬件FIFO之间的搬迁由DMA完成，搬迁的数量通过TX Ring的两个指针完成，一个是写指针，由软件更新，告诉硬件我已经把这个位置的TFD准备好，你可以拿了，另一个是读指针，由硬件拿走数据后更新该指针，通过中断告诉软件我已经取走数据，你可以继续在该TFD上更新数据。</li>
</ul>
<h3 id="3、报文的接收过程"><a href="#3、报文的接收过程" class="headerlink" title="3、报文的接收过程"></a>3、报文的接收过程</h3><p><img src="/assets/images/TCP/rx.jpg" alt="图片">  </p>
<center>Figure 2: RX flow</center>

<ol>
<li>网卡对报文进行CRC检查，如果合法就写入主存（一般通过DMA完成）。一旦完成写入，网卡发送中断通知CPU。</li>
<li>驱动层对报文进行检查，在发送至上层协议栈之前，必须封装成OS相关的数据结构，比如Linux对应sk_buff，BSD对应mbuf。</li>
<li>以太网层同样对报文进行合法性检查，然后发送至网络层，交给不同的协议处理模块，对于IP报文交给IP层，而对于ARP报文则送至ARP模块。</li>
<li>IP层继续检查报文合法性，判断其是进行IP路由还是本地处理。根据IP头的协议字段，上发至上层，比如6对应TCP层。</li>
<li>TCP层同样检查TCP检验和，往往由网卡计算完成，而不是内核。</li>
<li>以TCP报文的五元组作为关键字进行连接查找，查看是否匹配该层的规则，如果符合，则加入接收缓冲区。</li>
</ol>
<h3 id="4、不是结束语"><a href="#4、不是结束语" class="headerlink" title="4、不是结束语"></a>4、不是结束语</h3><p>理解问题需从根上抓起，TCP/IP也一样，仍有许多细节需要在工作实践中反复体会。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对TCP/IP的数据收发做一个粗略总结~    &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1、TCP-IP基本特点&quot;&gt;&lt;a href=&quot;#1、TCP-IP基本特点&quot; class=&quot;headerlink&quot; title=&quot;1、TCP/IP基本特点&quot;&gt;&lt;/a&gt;1、TCP/IP基本
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="TCP/IP" scheme="https://skypacer210.github.io/tags/TCP-IP/"/>
    
      <category term="Stack" scheme="https://skypacer210.github.io/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>一张物联网框图</title>
    <link href="https://skypacer210.github.io/2014/11/20/iot-technology-stack/"/>
    <id>https://skypacer210.github.io/2014/11/20/iot-technology-stack/</id>
    <published>2014-11-19T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>#IOT  </p>
<p><img src="/assets/images/IOT.png" alt="图片">  </p>
<center>IOT technology stack</center>  ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#IOT  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/IOT.png&quot; alt=&quot;图片&quot;&gt;  &lt;/p&gt;
&lt;center&gt;IOT technology stack&lt;/center&gt;  
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="IOT" scheme="https://skypacer210.github.io/tags/IOT/"/>
    
      <category term="物联网" scheme="https://skypacer210.github.io/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>OOP小记</title>
    <link href="https://skypacer210.github.io/2014/10/25/oop-review/"/>
    <id>https://skypacer210.github.io/2014/10/25/oop-review/</id>
    <published>2014-10-24T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OOP中的类"><a href="#OOP中的类" class="headerlink" title="OOP中的类"></a>OOP中的类</h2><ul>
<li><strong>类即数据结构</strong>：实现新的类库就是定义了新的数据结构。  </li>
<li><strong>广义的生产者和消费者</strong>：类创建者对应生产者，类使用者即客户端程序员。  </li>
<li><strong>对象即服务</strong>：关注于该对象能提供给用户那些服务，而不关注其内部实现。  </li>
<li><strong>类关系表达方法</strong>：基类开始由上至下。  </li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态用到的技术即后期绑定，由JAVA内部一段程序实现；相反，前期绑定则通过绝对地址调用实现。C++需要用virtual显示声明,JAVA默认支持。</p>
<h2 id="容器与迭代器"><a href="#容器与迭代器" class="headerlink" title="容器与迭代器"></a>容器与迭代器</h2><p>容器本质提供了各种数据类型的抽象，JAVA中包括List类，MAP类，以及队列、树堆栈等。迭代则提供了对容器成员的抽象化访问，比如设值、取值和遍历等。在C语言中可以利用<strong>函数指针</strong>进行迭代器的设计。</p>
<h2 id="单根继承结构"><a href="#单根继承结构" class="headerlink" title="单根继承结构"></a>单根继承结构</h2><p>所有对象都具备相同的接口，好处是垃圾回收器可以方便的发送适当的消息给系统中的每一个对象。</p>
<h2 id="向上转型向下转型"><a href="#向上转型向下转型" class="headerlink" title="向上转型向下转型"></a>向上转型向下转型</h2><p>有待理解。</p>
<h2 id="真并发与伪并发"><a href="#真并发与伪并发" class="headerlink" title="真并发与伪并发"></a>真并发与伪并发</h2><p>前者即多个线程运行在多个处理器上，后者是多个线程分时复用一个CPU。程序写得不好，会造成在多处理器中出现线程总运行与某个处理器之上。</p>
<h2 id="为什么会有WEB客户端编程"><a href="#为什么会有WEB客户端编程" class="headerlink" title="为什么会有WEB客户端编程"></a>为什么会有WEB客户端编程</h2><p>WEB客户端编程设计初衷就是期望减轻服务器端压力，将计算和逻辑控制过程置于客户端运行。具体方法包括插件、脚本语言比如JAVAScript、VBScript等、JAVA（利用applet）。相比脚本语言。JAVA applet和前者的本质区别在于其本身是以被编译过的形式存在的，并且利用<strong>数字签名</strong>保障安全性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;OOP中的类&quot;&gt;&lt;a href=&quot;#OOP中的类&quot; class=&quot;headerlink&quot; title=&quot;OOP中的类&quot;&gt;&lt;/a&gt;OOP中的类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类即数据结构&lt;/strong&gt;：实现新的类库就是定义了新的数据结构。  &lt;/li
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="JAVA" scheme="https://skypacer210.github.io/tags/JAVA/"/>
    
      <category term="OOP" scheme="https://skypacer210.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议与Web开发</title>
    <link href="https://skypacer210.github.io/2014/10/19/web-application-layer/"/>
    <id>https://skypacer210.github.io/2014/10/19/web-application-layer/</id>
    <published>2014-10-18T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-Basic"><a href="#HTTP-Basic" class="headerlink" title="HTTP Basic"></a>HTTP Basic</h2><h3 id="HTTP资源"><a href="#HTTP资源" class="headerlink" title="HTTP资源"></a>HTTP资源</h3><p>HTTP用于获取服务器的资源，资源的种类称为MIME，资源的表达方式URI（统一资源标识符）。URI有两种形式，URL和URN：      </p>
<ul>
<li>URL精确说明了资源的位置及如何访问它，包括方案（HTTP、FTP），服务器因特网地址和WEB服务器上的某个资源。  </li>
<li>URN（统一资源名）目的是为了使用同一个名字通过多种网络协议来访问资源。URI几乎都是URL。</li>
</ul>
<h3 id="HTTP事务"><a href="#HTTP事务" class="headerlink" title="HTTP事务"></a>HTTP事务</h3><p>一个事务包含一条请求加响应的响应。HTTP方法：    </p>
<ul>
<li>GET：从服务器向客户端发送命令资源     </li>
<li>POST：将客户端数据发送至一个服务器网关应用程序；  </li>
<li>PUT：将来自客户端的数据存储至一个命名的服务器资源中去；  </li>
<li>DELETE：从服务器张删除命名资源。  </li>
</ul>
<p>HTTP客户端的应用程序为了完成某项任务可以发布多个HTTP事务，而请求的资源可以位于不同的HTTP服务器端。比如JAVA小程序、图像等。</p>
<h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>HTTP报文都是纯文本，不是二进制，包含三部分：     </p>
<ul>
<li>起始行（start lines）： 典型首部字段比如Content-Type: text/html; charset=utf-8    </li>
<li>首部 (Header)   </li>
<li>主体 (entity body)</li>
</ul>
<h3 id="HTTP报文传输"><a href="#HTTP报文传输" class="headerlink" title="HTTP报文传输"></a>HTTP报文传输</h3><p>基于TCP/IP传输，因此需要目的IP地址和端口号。HTTP通过URL告诉TCP层IP地址和端口号。其中URL可以直接包含IP地址或者通过DNS查询得到，端口号默认为80。<br>TCP为HTTP提供了一条可靠的比特传输通道，从TCP一端填入的字节会从另外一端以原有顺序、正确的传送出来。  </p>
<p><img src="/assets/images/tcp_http.jpg" alt="图片"></p>
<p>HTTP事务的性能在很大程度上决定上取决于底层TCP通道的性能。HTTP时延主要由TCP时延引起。需要考虑如下因素：  </p>
<ul>
<li>TCP连接建立握手；  </li>
<li>TCP慢启动拥塞控制；  </li>
<li>数据汇聚的Nagle算法；  </li>
<li>用于捎带确认的TCP延迟确认算法；    </li>
</ul>
<h3 id="HTTP连接管理"><a href="#HTTP连接管理" class="headerlink" title="HTTP连接管理"></a>HTTP连接管理</h3><p>在HTTP层的优化方法：      </p>
<ul>
<li>并行化连接：HTTP客户端打开多个连接，并行执行HTTP事务，即每个事务对应自己的。  </li>
<li>持久化连接：通过头部的connection字段完成，client填充keep-alive，如果server同意，就会回复同样的字段和数据内容。  </li>
<li>管道化连接  </li>
</ul>
<h3 id="HTTP验证框架"><a href="#HTTP验证框架" class="headerlink" title="HTTP验证框架"></a>HTTP验证框架</h3><p><strong>Secruity Realm</strong>  </p>
<p>server通过安全域告诉client授权范围限定在该域内。        </p>
<p><strong>HTTP Basic Authentication</strong>           </p>
<p>HTTP的验证框架基于Challenge/Response验证，一般仅用于测试可用性。具体而言，基本的HTTP验证通过GET方法，在首部利用WWW-Authentication字段（GET Response）和Authorization字段（GET Request）完成交互。 </p>
<p><img src="/assets/images/http_auth.jpg" alt="图片"></p>
<p>根据client在Authorization字段的对身份凭证（比如用户名密码）的处理方式不同，可以引申出诸多验证方式。    </p>
<ul>
<li>基于BASE64编码的基本认证；  </li>
<li>基于HASH算法的摘要认证；  </li>
<li>另外，为了防止重放攻击，可以再客户端和服务器端都引入随机数。    </li>
</ul>
<p>但是其其缺点也很明显：  </p>
<ul>
<li>缺乏对客户端的认证；  </li>
<li>缺乏对服务器端的认证；  </li>
<li>无法保证客户端和服务器端数据的完整性；  </li>
<li>无法保证客户端和服务器端之间数据的私密性；  </li>
</ul>
<p>HTTPS应运而生。    </p>
<p><strong>Token-based HTTP Authentication</strong></p>
<p>该种验证方式适合于桌面系统和移动设备客户端。</p>
<p><strong>Session backend for authentication</strong>  </p>
<p><strong>OAuth-based Authentication</strong>  </p>
<h2 id="Web应用的层次结构"><a href="#Web应用的层次结构" class="headerlink" title="Web应用的层次结构"></a>Web应用的层次结构</h2><p>Web的基本原理即client向server发起HTTP Requst, server向client回应HTTP Response。client不仅仅局限于浏览器，也不限于人，更一般的情况下client向第三方发起HTTP Requst,得到第三方的HTTP Response。</p>
<h3 id="Static-website"><a href="#Static-website" class="headerlink" title="Static website"></a>Static website</h3><p>nginx 1.5 + modsecutity + openssl + bootstrap 2</p>
<h3 id="Background-workers"><a href="#Background-workers" class="headerlink" title="Background workers"></a>Background workers</h3><p>Phython 3.0 + celery + pyedis + libcurl + ffmpeg + libopencv + nodejs + phantomjs</p>
<h3 id="User-DB"><a href="#User-DB" class="headerlink" title="User DB"></a>User DB</h3><p>postgresql + pgv8 + v8  </p>
<h3 id="Anaytics-DB"><a href="#Anaytics-DB" class="headerlink" title="Anaytics DB"></a>Anaytics DB</h3><p>hadoop + hive + thrift + OpenJDK  </p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>随着HTTP交互的数据量增长，不可避免会出现请求无法响应的情况，例如Twitter的在宕机时会出现fail whale图片。为了解决这个问题，引入消息队列。    </p>
<ul>
<li>可以向第三方应用发送HTTP Request;  </li>
<li>可以更快的响应浏览器；  </li>
<li>如果第三方应用失败，不会影响到client；  </li>
<li>还可以发起重试；  </li>
<li>可以向对个第三方应用推送数据。  </li>
</ul>
<p>目前的消息队列库的实现可以基于多种语言，包括Ruby、Python、Java、Erlang、Scala、C#、Lua、 PHP 等等。  </p>
<p>消息队列遵循的协议有STOMP、AMQP和Memcache。  </p>
<p>消息队列相关的软件包括RabbitMQ、Stompserver、ZeroMQ、Morbid、ApacheMQ、Starling、Beanstalk、Kestrel以及MemcacheQ。  </p>
<p>Redis + redis-sentinel</p>
<ol>
<li>Kafka: A Distributed Messaging System</li>
<li>Redis: A Simple Key-Value Store</li>
</ol>
<h3 id="API-endpooint"><a href="#API-endpooint" class="headerlink" title="API endpooint"></a>API endpooint</h3><p>Python 2.7 + Flask + pyredis + celery + psycop + postgresql-client</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP-Basic&quot;&gt;&lt;a href=&quot;#HTTP-Basic&quot; class=&quot;headerlink&quot; title=&quot;HTTP Basic&quot;&gt;&lt;/a&gt;HTTP Basic&lt;/h2&gt;&lt;h3 id=&quot;HTTP资源&quot;&gt;&lt;a href=&quot;#HTTP资源&quot; class=&quot;
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="Docker" scheme="https://skypacer210.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux下802.11n TX aggregation实现框图</title>
    <link href="https://skypacer210.github.io/2014/10/10/80211n-tx-aggregation-in-linux/"/>
    <id>https://skypacer210.github.io/2014/10/10/80211n-tx-aggregation-in-linux/</id>
    <published>2014-10-09T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小引"><a href="#小引" class="headerlink" title="##小引"></a>##小引</h2><h2 id="正文"><a href="#正文" class="headerlink" title="##正文"></a>##正文</h2><p>本文研究了Linux下802.11n TX aggregation过程。</p>
<p>###1、MAC80211 Framework  </p>
<p>Linux协议栈中mac80211的整体架构如下图所示：      </p>
<p><img src="/assets/images/mac80211_framework.png" alt="图片">  </p>
<center>Figure 1: mac80211 framework</center>

<p>###2、Transmission: kernel-&gt;mac80211-&gt;iwlwifi  </p>
<p>kernel-&gt;mac80211-&gt;iwlwifi的具体层次如下图所示：      </p>
<p><img src="/assets/images/tx_agg_1.png" alt="图片">  </p>
<center>Figure 1: kernel-&gt;mac80211-&gt;iwlwifi flow</center>


<p>###3、Transmission: iwlwifi-&gt;hardware  </p>
<p>iwlwifi-&gt;hardware的具体层次如下图所示：      </p>
<p><img src="/assets/images/tx_agg_1.png" alt="图片">  </p>
<center>Figure 1: kernel-&gt;mac80211-&gt;iwlwifi flow</center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;小引&quot;&gt;&lt;a href=&quot;#小引&quot; class=&quot;headerlink&quot; title=&quot;##小引&quot;&gt;&lt;/a&gt;##小引&lt;/h2&gt;&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;##正文&quot;&gt;&lt;/a&gt;##正文&lt;/h
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="Linux" scheme="https://skypacer210.github.io/tags/Linux/"/>
    
      <category term="TX Aggregation" scheme="https://skypacer210.github.io/tags/TX-Aggregation/"/>
    
      <category term="mac80211" scheme="https://skypacer210.github.io/tags/mac80211/"/>
    
  </entry>
  
  <entry>
    <title>LCRS树在证书管理中的应用</title>
    <link href="https://skypacer210.github.io/2014/05/16/lcrs-and-certificate-store/"/>
    <id>https://skypacer210.github.io/2014/05/16/lcrs-and-certificate-store/</id>
    <published>2014-05-15T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works"></a>How it works</h2><h3 id="1-LCRS"><a href="#1-LCRS" class="headerlink" title="1. LCRS"></a>1. LCRS</h3><p>LCRS, 即left-child, right-sibling representation is a way of encoding a multi-way tree using a binary tree  </p>
<ul>
<li>树的本质在于用继承性的关系描述数据结构，只需理解继承性即可理解树</li>
<li>Binary Tree：意味着每个节点最多有两个孩子</li>
<li>Multi-way tree: 意味着每个节点有任意数目的孩子</li>
<li>LCRS仅仅是一种编码形式  </li>
</ul>
<h3 id="2-为什么要用到LCRS-Tree"><a href="#2-为什么要用到LCRS-Tree" class="headerlink" title="2. 为什么要用到LCRS Tree"></a>2. 为什么要用到LCRS Tree</h3><p>传统的Mutil-way Tree  </p>
<pre><code>
                    A       
                 //|\ \
               / / | \  \
              B C  D  E  F
              |   /|\   / \
              G  H I J K   L
</code></pre>  

<p><strong>数据结构表达</strong>  </p>
<pre><code>
struct Node {
    DataType value;
    std::vector<node*> children;  /*用到多个孩子指针*/
};
</node*></code></pre> 

<p>每个节点存储一个是leftmost child，另外一个指针指向其右兄弟节点，形式变化如下：  </p>
<pre><code>
            A
           /
          /
         /
        B -> C -> D -> E -> F
       /         /           /
      G         H->I->J   K->L
</code></pre>

<p>层次和结构不变，变的是存储方式。可以理解为double chained  tree:</p>
<ul>
<li>每个节点的leftmost child都链接在单链表里， 用child域存储下一个child，在tree的层次逐层增加；</li>
<li>每个节点的兄弟节点都链接在另外一个单链表里，用sibling域存储该节点的兄弟节点，在tree中的层次是一样的</li>
</ul>
<p><strong>遍历</strong></p>
<p>From a parent node to its kth child (zero-indexed):</p>
<p>Descend至当前节点的leftmost child,即child向右遍历该节点的兄弟节点k次返回节点,<br>数据结构描述相应变为：</p>
<pre><code>  
struct Node {    
    DataType data;
    Node* leftChild;/**/
    Node* rightSibling; /*存储着*/
};  
</code></pre> 

<p><strong>Multi-way tree VS LCSR tree</strong>  </p>
<ul>
<li>内存空间：后者比前者节省大约40%    </li>
<li>时间：如果分叉因子很多，即每层的节点很多，前者查询节点只需找到对应的子节点指针即可，后者则需进行单链表遍历（树退化为链表），导致时间变长  </li>
</ul>
<h3 id="3-LCRS适用场景"><a href="#3-LCRS适用场景" class="headerlink" title="3. LCRS适用场景"></a>3. LCRS适用场景</h3><ul>
<li>Memory is extremely scarce: 如果在主存中存储一颗巨大多路树，LCRS会合适</li>
<li>Random access of a node’s children is not required  </li>
</ul>
<p>在构建某些特定的数据结构是，比如Heap data structures ，采样LCRS可以优化空间，而最常见操作集中如下：删除tree的根节点和处理一个孩子；合并两颗树，而这二者对于LCRS易于完成，对于certificate存储系统，该操作常见。</p>
<h2 id="LCRS在证书系统中的应用"><a href="#LCRS在证书系统中的应用" class="headerlink" title="LCRS在证书系统中的应用"></a>LCRS在证书系统中的应用</h2><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><pre><code>
#define CTREE_CLASS_CERT.       0
#define CTREE_C_SCLASS_PUBLIC.  0x0001.
#define CTREE_C_SCLASS_PRIVATE. 0x0002.
#define CTREE_C_SCLASS_BOTH.    0x0003.
#define CTREE_CLASS_ROOT.       1
#define CTREE_CLASS_FOLDER.     2.     
#define CTREE_F_SCLASS_COMMON.  0x0020.
#define CTREE_F_SCLASS_UNKNOWN. 0x0021

struct tree {
    struct tree *parent;
    struct tree *child;    /*leftmost child, as the sibling’s list head*/
    struct tree *sibling;    /*link to child in single list structure*/
    uchar.  name[64];        /*file name, eg certificate name*/
    uint .  id;    /* Must be > 0 */
    ushort. type, subtype;    /* both for reserved */
    ushort .iclass, subclass;    /*cert/root/folder; private key/public key*/
    uchar.  num_child, level, unused[2];    /*tree level*/
    uint .  capability;    /*reserved*/
    pBmp.   EBmp, CBmp;    /*Icon*/
    void.   *iprivate;    /*for unkown CA folder and private info*/
};   

</code></pre>   

<h3 id="2-API"><a href="#2-API" class="headerlink" title="2. API"></a>2. API</h3><p><strong>Insert node</strong>  </p>
<p><strong>remove node</strong>  </p>
<pre><code>
STATIC void

ctree_remove_node(struct tree *troot, uchar *filename)
{
        struct tree *delte, *parent, *child, *lost, *lastchild;
        delte = tree_find_node_by_name(troot, filename, 1);/*获取要删除的节点*/

        if (delte == 0)
                return;

        parent = delte->parent;         /*取得被删节点的父指针*/
        child = parent->child;          /*取得leftmost child指针*/

        if (parent->child == delte)     /*Case1: 被删节点就是leftmost child*/
                parent->child = delte->sibling; /* 修改leftmost child指向被删节点的兄弟*/
        else {  /*Case1: 被删节点是sibling节点*/
                child = parent->child;  /*以leftmost child为单链表头遍历，获取要删除的sibling节点 */
                while (child->sibling != delte)
                        child = child->sibling;
                ASSERT(child->sibling == delte);
                if (child->sibling != delte)
                        return;
                child->sibling = delte->sibling;
        }

        delte->parent = 0;
        delte->sibling = 0;
        if (delte->child == 0)  /*如果被删节点没有孩子，则直接返回*/
                return;

        lost = (struct tree *) troot->iprivate; /*重新连接整个子树至unkown CA*/

        //re-link child
        child = delte->child;

        do {    /*将该层所有的孩子节点的父指针修改为lost,即unkown CA*/
                child->parent = lost;
                lastchild = child; /*记录该层最后一个孩子节点*/
                child = child->sibling;/*单链表遍历*/
        } while (child);

        lastchild->sibling = lost->child; /*最后一个孩子节点的next指针(sibling)指向lost的leftmost child*/

        lost->child = delte->child; /*修改lost的leftmost child为被删节点的leftmost child*/

        delte->child = 0;

        ctree_free_node(delte);

        tree_update_order(lost); /*更新以lost为root的子树*/
}

</code></pre>


<p><strong>update subtree</strong>     </p>
<pre><code>  
void tree_update_order(struct tree *parent)
{    
    struct tree *child;
    uint.   previd = 0;.   

    PRINTF("TW: parent update [%s] (lv %d, id %x)\n", parent->name, parent->level, parent->id);

    parent->num_child = 0;

    while (child = tree_next_child(parent, previd)) { /*获取该层的所有孩子*/
        child->level = parent->level + 1; /*孩子的层是父亲层加1*/
        child->id = tree_calc_orderid(parent);
        PRINTF("TW: child [%s] lv %d id %x\n", child->name,  child->level, child->id);

        tree_update_order(child); /*child作为子树root递归调用*/
        previd = child->id; /*更新前一个id*/
        child = child->sibling; /*单链表遍历*/
    }

    PRINTF("TW: [%s] return \n", parent->name);
}  

</code></pre>  

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;How-it-works&quot;&gt;&lt;a href=&quot;#How-it-works&quot; class=&quot;headerlink&quot; title=&quot;How it works&quot;&gt;&lt;/a&gt;How it works&lt;/h2&gt;&lt;h3 id=&quot;1-LCRS&quot;&gt;&lt;a href=&quot;#1-LCRS&quot;
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="LCRS" scheme="https://skypacer210.github.io/tags/LCRS/"/>
    
      <category term="certificate" scheme="https://skypacer210.github.io/tags/certificate/"/>
    
      <category term="data structure" scheme="https://skypacer210.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>LDAP那些事儿</title>
    <link href="https://skypacer210.github.io/2014/04/24/ldap-those-things/"/>
    <id>https://skypacer210.github.io/2014/04/24/ldap-those-things/</id>
    <published>2014-04-23T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LDAP-概述"><a href="#LDAP-概述" class="headerlink" title="LDAP 概述"></a>LDAP 概述</h2><p>由DAP发展而来，相比DAP，其基于TCP/IP，在功能上有所减少。LDAP本质上就是一种定义了如何访问目录数据的方法的协议，同时定义了在目录服务中数据是如何表达的。<br>对于数据操作，LDAP只定义了数据如何加载至目录服务和如何从目录服务导出数据，并未定义如何存储数据和操作，厂家可以有自己的back-end的具体实现，比如OpenLDAP提供了选择back-end数据库的支持。事实上很多商业DB都提供了LDAP视图。  </p>
<p>###1. LDAP与DB  </p>
<p>LDAP可以看做是一种读优化的数据库。LDAP Server可以基于multi-master架构，也可以基于Multi-master架构。  </p>
<ol>
<li>LDAP提供了一种标准化的远程和本地数据的访问方法。可以在不影响外部数据访问接口的前提下替换LDAP的实现。  </li>
<li>由于标准化了数据访问，LDAP客户端和服务器端可以独立开发。  </li>
<li>可以不影响外部数据访问的前提下转移数据至多个地点。  </li>
</ol>
<p>###2. LDAP信息模式  </p>
<p>LDAP是面向对象的数据库，定义了基础原语（read/delete/modify），以继承性对象的方式表示数据。  </p>
<p>###3. LDAP与AD  </p>
<p>LDAP提供了一种可以查询和修改目录服务的应用协议。AD本质就是一种数据库的系统，在window环境中提供验证、目录、策略和其他服务。<br>LDAP是一个标准，AD则是微软的基于目录服务器的一中LDAP实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LDAP-概述&quot;&gt;&lt;a href=&quot;#LDAP-概述&quot; class=&quot;headerlink&quot; title=&quot;LDAP 概述&quot;&gt;&lt;/a&gt;LDAP 概述&lt;/h2&gt;&lt;p&gt;由DAP发展而来，相比DAP，其基于TCP/IP，在功能上有所减少。LDAP本质上就是一种定义了如何
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="LDAP" scheme="https://skypacer210.github.io/tags/LDAP/"/>
    
      <category term="AD" scheme="https://skypacer210.github.io/tags/AD/"/>
    
      <category term="database" scheme="https://skypacer210.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Kerberos那些事</title>
    <link href="https://skypacer210.github.io/2014/04/09/kerberos-those-thing/"/>
    <id>https://skypacer210.github.io/2014/04/09/kerberos-those-thing/</id>
    <published>2014-04-08T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对kerberos的协议细节做一个粗略介绍~  </p>
<p>原文链接<a href="http://www.roguelynn.com/words/explain-like-im-5-kerberos/" target="_blank" rel="external">explain-like-im-5-kerberos</a>  </p>
<hr>
<h2 id="1、Nutshell"><a href="#1、Nutshell" class="headerlink" title="1、Nutshell"></a>1、Nutshell</h2><p>Kerberos源自古希腊神话中的三头狗，对应引入了第三方验证系统。Kerberos有如下特点：  </p>
<ul>
<li>一种验证协议</li>
<li>采用ticket进行验证</li>
<li>密码通过网络进行传递，避免了本地存储</li>
<li>需要引入第三方机构</li>
<li>基于对称加密算法  </li>
</ul>
<p>一个ticket意味着用特定服务请求所对应的key加密后的身份证明，如果其有效，你可以在一个kerberos域内访问该服务。</p>
<p>Ticket由很多信息组成，以保证特定服务授权的针对性和实效性。<br>Keberos其目的仍是保证client和client所请求的服务或者主机之间的session key。  </p>
<p>典型实例：<br>访问内网的工资系统，每次重新输入user/password的时候或者在终端运行kinit USER的时候，用户的ticket会更新。  </p>
<h2 id="2、Kerberos-Realm"><a href="#2、Kerberos-Realm" class="headerlink" title="2、Kerberos Realm"></a>2、Kerberos Realm</h2><p>管理员创建realm，囊括了所有可能的访问，即定义了不同服务和主机的访问策略和授权，其本质为依据谁能够访问什么的原则定义了Kerberos的管理内容。  </p>
<p>用户主机位于该realm,同时也包括了所期望访问的服务、KDC(Key Distribution Center)。  </p>
<p>KDC可以分为Authentication Server 和Ticket Granting Server。  </p>
<p><img src="/assets/images/kerberos/Kerb.001.jpg" alt="图片"></p>
<h2 id="3、Kerberos那些事"><a href="#3、Kerberos那些事" class="headerlink" title="3、Kerberos那些事"></a>3、Kerberos那些事</h2><p>当访问一个服务或者主机时，存在着三种交互：  </p>
<ul>
<li>Client 和Authentication Server</li>
<li>Client 和Ticket Granting Server</li>
<li>Client和服务器</li>
</ul>
<p>其他要点如下：</p>
<ul>
<li>每次交互client可以收到两条消息，一条是可以解密的，一条是无法解密的；</li>
<li>Client期望访问的服务或者主机从不直接与KDC通信；</li>
<li>KDC存储了其数据库下所有主机和服务的密钥；</li>
<li>密钥由密码加上一组随机数的哈希值，哈希算法由Kerberos的具体实现选择。对于服务和主机而言，其本身是没有密码的。一个密码实际上是由管理员的初始启动时产生和存储于服务和主机中的；</li>
<li>所有密钥存储于KDC数据库；</li>
<li>KDC本身由主密钥加密；</li>
<li>已经存在Kerberos的配置和实现采用公钥加密。</li>
</ul>
<p>上述定义的消息和内容并未反映他们在TCP、UDP发送中的实际顺序, 下面描述如果访问一个内部的HTTP服务，将会发生什么。</p>
<h3 id="3-1、You-and-the-Authentication-Server"><a href="#3-1、You-and-the-Authentication-Server" class="headerlink" title="3.1、You and the Authentication Server"></a>3.1、You and the Authentication Server</h3><p>在访问HTTP服务之前，client必须向authentication server介绍自己。当登陆系统或者运行kinit USERNAME的时候，通过一个明文请求TGT(Ticket Granting Ticket)。其具体内容包括：</p>
<ul>
<li>Name/ID</li>
<li>服务ID(有很多的服务ID？)</li>
<li>网络地址</li>
<li>合法TGT的请求生命周期</li>
</ul>
<p><img src="/assets/images/kerberos/Kerb.002.jpg" alt="图片"></p>
<p>Authentication server仅仅检查是否存在于KDC数据库，无需密码。</p>
<p><img src="/assets/images/kerberos/Kerb.003.jpg" alt="图片"></p>
<p>Authentication server回复两条消息：<br>消息一，即用TGS的密钥(TGS和Authenticator都知道各自的密钥？)加密的ticket, 即TGT，这个TGT包括如下：</p>
<ul>
<li>Client name/ID；</li>
<li>TGS name/ID,即ticket服务器也自报家门；</li>
<li>时间戳；</li>
<li>Client的网络地址；</li>
<li>TGT生命周期，即ticket的生命周期；</li>
<li>TGS session Key，即会话密钥。  </li>
</ul>
<p>消息二，即client密钥加密的TGS会话密钥等：  </p>
<ul>
<li>TGS name/ID;</li>
<li>Timestamp;</li>
<li>生命周期；</li>
<li>TGS session key;</li>
</ul>
<p>TGS session key就是client和TGS之间的共享密钥。  </p>
<p><img src="/assets/images/kerberos/Kerb.004.jpg" alt="图片"></p>
<p>Client 密钥通过提示client输入密码，再加上一个随机串，最后对整个进行哈希得到。可以用该密钥解密TGS发送过来的第二条消息，以获取TGS 会话密钥。显然，如果密码错误，client 将无法解密该条消息。实际上是完成了对client password的隐性验证。   </p>
<p><img src="/assets/images/kerberos/Kerb.005.jpg" alt="图片"> </p>
<p>由于不知道TGS 密钥，无法解密TGT，将此加密的TGT存储于credential cache当中。</p>
<h3 id="3-2、You-and-the-Ticket-Granting-Server"><a href="#3-2、You-and-the-Ticket-Granting-Server" class="headerlink" title="3.2、You and the Ticket Granting Server"></a>3.2、You and the Ticket Granting Server</h3><p>此时，client拥有TGS session key，但是没有TGS密钥。<br>现在轮到client发送两条消息了：  </p>
<p>第一条消息为Authenticator 准备，用TGS会话密钥加密如下信息：<br>Client name/ID + timestamp  </p>
<p>第二条消息是明文，包含请求的HTTP服务名称和HTTP服务的ticket生命周期同时还有加密的Authenticator和TGT。   </p>
<p><img src="/assets/images/kerberos/Kerb.006.jpg" alt="图片"></p>
<p>TGS收到这两个消息后，首先检查KDC数据库中是否存在所请求的HTTP服务。  </p>
<p><img src="/assets/images/kerberos/Kerb.007.jpg" alt="图片"></p>
<p>如果存在，TGS用TGS密钥解密TGT。因为解密后的TGT包含TGS会话密钥，因此TGS可以解密client所发送的Authenticator。    </p>
<p><img src="/assets/images/kerberos/Kerb.008.jpg" alt="图片"></p>
<p>TGS然后将作如下操作：  </p>
<ul>
<li>比较authenticator中包含的client ID和TGT中包含的；</li>
<li>比较两者之间的时间戳，误差一般可容忍2分钟；</li>
<li>通过生命周期字段检查TGT是否过期；</li>
<li>检查authenticator已经不在TGS的cache当中。</li>
<li>如果原始请求中的网络地址不为NULL，比较其中的IP地址与TGT中的；</li>
</ul>
<p>此时，TGS开始随机产生client所请求的HTTP服务的会话密钥，准备HTTP服务ticket，包含如下信息：  </p>
<ul>
<li>Client name/ID;</li>
<li>HTTP服务name/ID;</li>
<li>Client的网络地址；</li>
<li>时间戳；</li>
<li>Ticket的生命周期；</li>
<li>HTTP服务session key;  </li>
</ul>
<p>上述信息由HTTP服务密钥加密。  </p>
<p><img src="/assets/images/kerberos/Kerb.009.jpg" alt="图片"></p>
<p>然后TGS向client发送两条信息：  </p>
<p>第一条是由HTTP服务密钥加密的HTTP服务ticket；  </p>
<p>第二条是由TGS session key加密的信息：  </p>
<ul>
<li>HTTP服务name/ID;</li>
<li>时间戳；</li>
<li>Ticket的生命周期；</li>
<li>HTTP服务session key。  </li>
</ul>
<p>Client利用cached的TGS session key解密第二条消息，以获取HTTP服务session key。而无法解密第一条消息，因为其没有HTTP服务密钥。</p>
<p><img src="/assets/images/kerberos/Kerb.010.jpg" alt="图片"></p>
<h3 id="3-3、-You-and-the-HTTP-Service"><a href="#3-3、-You-and-the-HTTP-Service" class="headerlink" title="3.3、 You and the HTTP Service"></a>3.3、 You and the HTTP Service</h3><p>为了访问HTTP服务，client准备了另外的Authenticator消息，包括：  </p>
<ul>
<li>Client name/ID;</li>
<li>时间戳。  </li>
</ul>
<p>用HTTP服务session key加密后发送给HTTP服务，同时也发送未解密的HTTP服务ticket。  </p>
<p><img src="/assets/images/kerberos/Kerb.011.jpg" alt="图片"></p>
<p>HTTP服务在收到消息后用HTTP服务密钥解密消息二，获取HTTP服务session key。然后用该Key解密client发送的第一条authenticator消息。    </p>
<p><img src="/assets/images/kerberos/Kerb.012.jpg" alt="图片"></p>
<p>类似于TGS，HTTP服务器也要做如下校验：    </p>
<ul>
<li>Client ID;</li>
<li>时间戳；</li>
<li>ticket是否过期；</li>
<li>避免反重放攻击，查看HTTP服务器的cache是否包含authenticator；</li>
<li>网络地址比较。  </li>
</ul>
<p>如果通过校验，HTTP服务然后发送一条Authenticator消息，该消息包含其服务ID及时间戳，由HTTP服务session key加密。  </p>
<p><img src="/assets/images/kerberos/Kerb.013.jpg" alt="图片"></p>
<p>Client收到HTTP服务发送的加密信息，用cache的HTTP 服务session key解密，由此接收到一条HTTP服务ID和时间戳的明文信息。  </p>
<p>此时client已经验证通过使用HTTP服务，将来的请求利用cached的HTTP服务ticket，前提是在定义的生命周期内。    </p>
<p><img src="/assets/images/kerberos/Kerb.014.jpg" alt="图片"></p>
<p>这里有个前提，HTTP服务本身必须支持Kerberos。同时，client必须要有一个支持SPNEGO/Negotiate的浏览器。  </p>
<p><img src="/assets/images/kerberos/Kerb.015.jpg" alt="图片"></p>
<p>##4、后续</p>
<p>token VS ticket</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对kerberos的协议细节做一个粗略介绍~  &lt;/p&gt;
&lt;p&gt;原文链接&lt;a href=&quot;http://www.roguelynn.com/words/explain-like-im-5-kerberos/&quot; target=&quot;_blank&quot; rel=&quot;external
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="ACCESS CONTROLS" scheme="https://skypacer210.github.io/tags/ACCESS-CONTROLS/"/>
    
  </entry>
  
  <entry>
    <title>《APIs with an Appetite》读后感</title>
    <link href="https://skypacer210.github.io/2014/01/30/c-api-design/"/>
    <id>https://skypacer210.github.io/2014/01/30/c-api-design/</id>
    <published>2014-01-29T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>##问题提出  </p>
<p>设计一个数据库的API，可供不同的WEB前端服务存储和获取数据。一些存储图像，一些存储文本、声音、图像等，如何控制API对数据的上述访问方法？  </p>
<p>##解决方案  </p>
<p>###1、瘦API  </p>
<p>void <em>do_as_i_say(…)  ，其参数是void </em>  </p>
<p>函数的目的在于提高访问复杂软件的接口，通过隐藏复杂性，提高软件的易用性, 但是该API并不能直观的告诉调用者如何使用。</p>
<p>###2、Fat APIs  </p>
<pre><code>
int store_jpeg_image(string name, image data);
image get_jpeg_image(string name); 
int delete_jpeg_image(string name); 
int store_gif_image(string name, image data); 
image get_gif_image(string name); 
int delete_gif_ image(string name); 
int store_tiff_image(string name, image data); 
image get_tiff_image(string name); 
int delete_tiff_image(string name); 
int store_text(string name, string data); 
string get_text(string name); 
int delete_text(string name);
</code></pre><p>这里走向了另外一个极端，这里有几个问题：</p>
<ul>
<li>很多信息应该作为参数，而不是一个个罗列为API</li>
<li>尽量提供少的名字和用法，因为人类的记忆有限，不可靠记住如此多的用法</li>
</ul>
<p>###3、Good Example<br>Unix的文件IO操作为我们提供了一个良好的示例，该接口只有五个API：open、close、read、write、ioctl，其中最重要的API是ioctl,它为程序提供了访问系统底层的能力，以备为设计者预先没有想到的需要，相当于提供了一个后门。  </p>
<p>##奇淫巧计  </p>
<p>###1、instance  </p>
<p>该概念类似面向对象设计中的对象，用于维护一个实体，即可以创建、查找、销毁一个Instance。</p>
<p>###2、Cookie  </p>
<p>cookie的含义很广，在分层设计中，cookie可以用于保存上层的数据，包括配置数据和配置行为(往往通过回调函数定义)，这样底层可以无需知道上层的配置细节，直接调用其配置方法即可。  </p>
<p>###3、Callback  </p>
<ul>
<li><p>Callback可以实现底层调用上层，这里无需赘述  </p>
</li>
<li><p>Callback可以用于实现异步通知机制，比如在一个异步事件通知系统中，可以将事件处理方法和ID组成事件对象加入事件队列，其中事件处理方法采用callback函数，在事件注册时定义，实现处理系统轮询该事件队列，逐个调用，当然也可以加入优先级以改变响应次序。</p>
</li>
</ul>
<p>##结论  </p>
<p>API设计应该是一个迭代的过程，首先你提供你认为用户需要的，同时流出后门。然后观察用户在使用过程中利用后门所做的操作，再在API全集中添加给API，依次类推。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##问题提出  &lt;/p&gt;
&lt;p&gt;设计一个数据库的API，可供不同的WEB前端服务存储和获取数据。一些存储图像，一些存储文本、声音、图像等，如何控制API对数据的上述访问方法？  &lt;/p&gt;
&lt;p&gt;##解决方案  &lt;/p&gt;
&lt;p&gt;###1、瘦API  &lt;/p&gt;
&lt;p&gt;void 
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="Design Pattern" scheme="https://skypacer210.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>代码之美读后感之《设计XML验证器之经验》</title>
    <link href="https://skypacer210.github.io/2014/01/19/Reading-about-XML-validator/"/>
    <id>https://skypacer210.github.io/2014/01/19/Reading-about-XML-validator/</id>
    <published>2014-01-18T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>两大基本需求：  </p>
<ul>
<li>读入XML文档进行输入验证；</li>
<li>输出验证，生成XML文档</li>
</ul>
<p>其中包括对XML的合法性检查，作者利用了JAVA中的JDOM类。</p>
<h3 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h3><ol>
<li>第一级优化：避免重复验证</li>
<li>第二级优化：将所有可能存储至一张表当中，以便进行位操作，当然提前是查找表可以一次读入内存。</li>
<li>第三级优化：引入cache,将常用的名字存入集合，其中对于小集合，利用数组即可实现，代价小于哈希表。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;两大基本需求：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读入XML文档进行输入验证；&lt;/li&gt;
&lt;li&gt;输出验证，生成XML文档&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Reading" scheme="https://skypacer210.github.io/categories/Reading/"/>
    
    
      <category term="XML" scheme="https://skypacer210.github.io/tags/XML/"/>
    
      <category term="代码之美" scheme="https://skypacer210.github.io/tags/%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>再谈Diffie-Hellman算法</title>
    <link href="https://skypacer210.github.io/2014/01/15/little-about-DH/"/>
    <id>https://skypacer210.github.io/2014/01/15/little-about-DH/</id>
    <published>2014-01-14T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在工作中又碰到了DH(Diffie-Hellman)算法，鉴于之前对该算法理解地支离破碎，因此在博文中总结归纳下。  </p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>DH算法用于在不安全的公共通道中协商密钥，安全性体现在：在有限域上计算离散代数非常困难。上两位大牛Whitfield Diffie 和 Martin Hellman的照片：  </p>
<p><img src="/assets/images/DH/DH_master.jpg" alt="图片"></p>
<p>算法描述：<br>假定Alice和Bob期望在一个不安全的网络中协商一个共同的密钥，那么进行如下步骤：</p>
<ul>
<li>两人先说好大素数（质数）p和它的原始根g。</li>
<li>Alice随机产生一个数a，并计算<code>A = p^a mod g</code>, 发送给Bob。</li>
<li>Bob随机产生一个数b，并计算B= pb mod g，发送给Alice。    </li>
</ul>
<p>此时， Alice手握Bob发过来的B，结合自己产生的a开始这样计算：</p>
<p><code>B^a mod p = (p^b mod g)^a mod p = p^ab mod g</code>。  </p>
<p>Bob也拿到了Alice发来的A，同时结合自己的b，也开始计算：</p>
<p> <code>B^a mod p = (p^b mod g)^a mod p = p^ab mod g</code>。</p>
<p>这样Alice和Bob都得到了相同的密钥。     </p>
<h3 id="DH的安全缺陷"><a href="#DH的安全缺陷" class="headerlink" title="DH的安全缺陷"></a>DH的安全缺陷</h3><p>DH不仅支持两点密钥交互，也可以支持多点密钥交互。但是DH算法本身存在安全性缺陷，即没有对交互双方进行身份验证，容易遭受中间人攻击。攻击思路具体如下：    </p>
<ul>
<li>Alice本来想发送A给Bob，被EVE截胡，EVE自己选择一个私有数c，计算出<code>C = p^c mod g</code>，发送给Bob。</li>
<li>Bob本来想发送B给Alice，也被EVE截胡，EVE再把<code>C = p^c mod g</code>发送给Alice。</li>
<li>此时，Alice和EVE计算出共同的密钥<code>K1 = p^ac mod g</code>，Bob和EVE计算出共同的密钥<code>K2 = p^bc mod g</code>。</li>
<li>Alice和Bob都以为是和对方协商好了共享密钥，于是开始发送数据，Alice用K1加密数据后发送给Bob，又被该死的EVE截胡，EVE用K1解密，不仅可以看到Alice想对Bob发送的信息，还可以修改，然后再用K2加密该篡改之后的信息，发给蒙在鼓里的Bob。Bob当然可以用K2解开，但是已经被EVE窥探甚至修改。  </li>
</ul>
<p>因此必须引入身份验证以防范此类攻击，利用RSA数字签名即可达到此目的。</p>
<h3 id="DH在TLS中的应用"><a href="#DH在TLS中的应用" class="headerlink" title="DH在TLS中的应用"></a>DH在TLS中的应用</h3><p>DH算法作为一种密钥协商机制，可以用于TLS协议当中。  </p>
<p>如果在DH交互过程中Alice和Bob始终使用相同的私钥，就会导致后续产生的共享密钥是一样的，如果有嗅探者截获通信双方的所有数据，由于都是同一个密钥加密所得，一旦被破解，后续的通信将全部暴露。</p>
<p>为了保证安全性，必须引入前向保密，即Forward Secrecy。其基本实现思路就是在Alice和Bob在选择各自的私钥是引入随机性，也印证了那句话：要用发展的眼光看问题，不能一成不变。  </p>
<p>事实上FS在诸多加密协议中应用广泛，比如IKEv2和802.11i密钥分发中的4-way握手，无一不引入此方法。</p>
<p>那么问题来了，TLS中哪一个才是最安全的cipher呢？就目前而言，最安全的三个候选者如下：  </p>
<ul>
<li><code>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P521</code></li>
<li><code>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P384</code></li>
<li><code>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P256</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在工作中又碰到了DH(Diffie-Hellman)算法，鉴于之前对该算法理解地支离破碎，因此在博文中总结归纳下。  &lt;/p&gt;
&lt;h3 
    
    </summary>
    
      <category term="Reading" scheme="https://skypacer210.github.io/categories/Reading/"/>
    
    
      <category term="DH" scheme="https://skypacer210.github.io/tags/DH/"/>
    
      <category term="TLS" scheme="https://skypacer210.github.io/tags/TLS/"/>
    
  </entry>
  
  <entry>
    <title>无线安全之前世今生</title>
    <link href="https://skypacer210.github.io/2014/01/10/history-of-wireless-security/"/>
    <id>https://skypacer210.github.io/2014/01/10/history-of-wireless-security/</id>
    <published>2014-01-09T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对wireless security的发展做一个粗略介绍，从open system到WPA、WPA2和802.1X，权当做抛砖引玉~</p>
<p>注：任何一次技术变革不仅仅是技术方案的较量，更多的是市场的博弈。原文链接<a href="http://securityuncorked.com/2008/08/history-of-wireless-security/" target="_blank" rel="external">history of wireless security</a></p>
<hr>
<p>##1、Open and SKA</p>
<p>802.11在发展早期主要采用两类验证方法– Open System Association (OSA) 和Shared Key Authentication (SKA).</p>
<ul>
<li>Open = no authentication</li>
<li>Shared Key = WEP</li>
</ul>
<p>Open systems 相当于没有任何验证手段，任何人可以连接至无线网络。</p>
<p>SKA基于WEP加密，我们会在4个预共享密钥中选择一个作为所有无线站点连接AP的密钥，虽然后来WEP被发现存在安全漏洞。让我们来看看WEP何罪之有？<br>WEP本身有诸多问题，在wired介质当中是一个足够强健的算法，但是并不适合无线介质，下面是WEP的若干罪状：</p>
<ul>
<li>采用基于流的算法</li>
<li>每包重用master key </li>
<li>在AP之间采用相同的组播密钥</li>
<li>缺乏对client端的有效认证机制</li>
<li>易于遭受重放攻击和完整性攻击  </li>
</ul>
<p>##2、 从WEP的改造到WPA的崭露头角  </p>
<p>###2.1、 “i”之初创  </p>
<p>随着WEP越来越多的漏洞被发现，IEEE决定成立802.11i工作组以改进无线安全。作为一个安全网络的过渡期，WPA应运而生，其目的在于开发一个强健的安全网络。<br>802.11i工作组面临诸多困难，其中之一便是如何在仍旧使用现有硬件的基础上对WEP进行安全加密流程进行改造。作为一个过渡性解决方案，WPA在解决WEP现有不足的基础上同时考虑长期的无线安全。  </p>
<p>###2.2、 WPA与TKIP  </p>
<p>Wi-Fi联盟(Wi-Fi Alliance)的目的在于创建一个在主流厂家之间互通的安全平台；而WPA源于‘Wi-Fi Protected Access’其本身不是一个标准甚至不能称之为框架，仅仅是一个由无线厂商为达到相互之间的互通而形成的ad-hoc联合。<br>WPA作为802.11i的一个准标准，既采用了特定的密钥管理，也遵循了802.11i中的验证架构-802.1X。由于当时的硬件不支持AES算法，WPA采用TKIP((Temporal Key Integrity Protocol))作为替代算法。</p>
<p>###2.3、WPA中的密钥建立机制  </p>
<p>WPA采用PMK建立PTKs，即会话密钥，其目的在于保护每个会话。伪随机数函数PSF (pseudo-random function)确保PTKs包含nonces、MAC地址计数、时间以及随机数。密钥建立机制的重新设计目的在于最大程度地降低主密钥被窃取的可能性。见图1。  </p>
<p><img src="/assets/images/wireless_brief_fig_1.png" alt="图片">  </p>
<center>Figure 1. WEP vs WPA</center>  

<p>###2.4、WPA的其他改进点  </p>
<p>WPA在安全性方面的改进之处主要有以下几点:</p>
<ul>
<li>IV扩展至56bit（对于弱密钥可以允许8bit的密钥扩展空间）</li>
<li>采用PTKs（再一次扩展了有效的密钥空间）</li>
<li>指定IV rotation，避免了密钥重用</li>
<li>采用MICHAEL算法进行完整性校验</li>
<li>通过IEEE802.1X进行网络验证</li>
<li>增加了序列号以防止重放攻击</li>
<li>报文头和负载的完整性检查以防止重定向攻击</li>
</ul>
<p>###2.5、WPA小结<br>WPA作为一种安全架构主要包含两类组件：第一类是加密组件TKIP；第二类是验证组件，可以是PSK也可以是RADIUS。除了安全性相比WEP有提升之外，更重要的是保证了向前兼容。</p>
<p>##3、 WPA2一统天下   </p>
<p>2008年WPA的漏洞被发现，即TKIP exploit,该漏洞通过改变验证组件无法修正，唯一的解决方法是用AES替代TKIP。WPA2应运而生，这就要求硬件进行改变。TKIP可以作为WPA2的可选项。<br>802.11i和WPA2指的是同一件事情，这样一来，在现有的硬件上可以用统一的的加密方式-AES，这正是IEEE标准下所谓的强健网络。<br>作为当前无线安全的标准，802.11i/WPA2又像极了当年的WPA准标准，仅在一些细微处有所不同。随着802.11i完成最终的业界应用，现有的硬件将AES加密算法作为内置算法。<br>WPA2相比WPA有如下两大改变：</p>
<ol>
<li>AES加密算法替代WEP被内置进硬件</li>
<li>加强了完整性检查  </li>
</ol>
<p>###3.1、802.11i与802.1x     </p>
<p>802.11i采用802.1x保证密钥的建立与验证。EAPoL虽然本身是基于有线设计的，但是很容易适用于无线。802.1X相比之前的验证方法的最大不同之处在于验证过程发生在station和RADIUS server之间，而不是station和AP之间。由于AP不参与密钥产生，所以session key（由PTK导出）和每包密钥需要和AP共享，这些密钥由一个安全通道TLS传输。  </p>
<p>图2描述了多种通信流，用不同的颜色予以标记。EAPoL通信由黑色标记，而EAP握手由蓝色区分。RADIUS采用绿色，TLS则使用了橙色。从该图可以清晰地看到station、AP以及RADIUS server之间的交互流程。</p>
<p><img src="/assets/images/wireless_brief_fig_2.png" alt="图片">  </p>
<center>Figure 2. 802.1X in Wireless</center>

<p>###3.2、源自RADIUS的TLS隧道    </p>
<p>802.11i利用802.1X不仅建立密钥同时也完成了验证， 相应地，RADIUS服务器也通过该途径向client验证其自身。这条从RADIUS服务器端到客户端的隧道提供了安全通信的机制，从而保证了验证过程中的密钥交互。</p>
<p>###3.3、WPA2的安全性  </p>
<p>WPA2也同样包含两类组件，一是基于AES的加密组件，二是基于PSK或者是RADIUS的验证组件。但并不意味着WPA2就没有漏洞，比如可以通过错误配置PEAP验证组件进行攻击。</p>
<p>##4、 后记</p>
<p>尽管业界对于802.1X仍然有一些争议，但其已经成为主流的安全无线验证机制并被广泛接受。总之，802.1X囊括了安全密钥交换、密钥轮转、主密钥保护以及AES加密等，成为目前一种具有单项优势的技术。</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对wireless security的发展做一个粗略介绍，从open system到WPA、WPA2和802.1X，权当做抛砖引玉~&lt;/p&gt;
&lt;p&gt;注：任何一次技术变革不仅仅是技术方案的较量，更多的是市场的博弈。原文链接&lt;a href=&quot;http://security
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="wireless" scheme="https://skypacer210.github.io/tags/wireless/"/>
    
      <category term="security" scheme="https://skypacer210.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下OpenStack配置小记</title>
    <link href="https://skypacer210.github.io/2014/01/08/openstack-deploy-in-ubuntu1204/"/>
    <id>https://skypacer210.github.io/2014/01/08/openstack-deploy-in-ubuntu1204/</id>
    <published>2014-01-07T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文由<a href="http://skypacer210.github.io/">skypacer</a>根据<a href="http://docs.openstack.org/trunk/install-guide/install/apt/content/" target="_blank" rel="external">OpenStack Installation Guide for Ubuntu 12.04 (LTS)</a>在自己的环境中实际部署情况整理而成。转载请注明出处！</p>
<p>###1、安装准备  </p>
<h4 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h4><ul>
<li>安装双网卡：通过vsphere client安装两个网卡，一个内网，一个外网。<br>修改文件/etc/network/interfaces如下：    </li>
</ul>
<pre><code>
auto lo
iface lo inet loopback 
# The primary network interface
# Internal network
auto eth0
#iface eth0 inet dhcp
iface eth0 inet static
address 10.151.122.138
netmask 255.255.255.0
gateway 10.151.122.1
dns-nameservers 10.151.122.5 10.151.120.21 10.140.2.48
dns-search wyse.com
# This is an autoconfigured IPv6 interface
iface eth0 inet6 auto

# External network
auto eth1
iface eth1 inet static
address 10.151.120.190
netmask 255.255.255.0
gateway 10.151.120.1
dns-nameservers 10.151.122.5 10.151.120.21 10.140.2.48
dns-search wyse.com  

</code></pre>  

<ul>
<li>修改host<br>修改/etc/hostname文件如下：   <pre><code>  
controller
</code></pre>     

</li>
</ul>
<p>修改/etc/hosts文件如下：  </p>
<pre><code>  
127.0.0.1       localhost
10.151.122.138  controller
10.151.122.139  compute1

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
</code></pre> 


<ul>
<li>重启网络：service networking restart  </li>
<li>测试网络：通过hostname命令检查主机名设置；通过ping检查主机解析  </li>
</ul>
<p>####1.2、安装数据库    </p>
<ul>
<li>apt-get install python-mysqldb mysql-server</li>
<li>修改/etc/mysql/my.cnf：将mysql的绑定地址改为内网IP：1<br>bind-address            = 10.151.122.138  </li>
<li>重启MYSQL：service mysql restart</li>
<li>删除匿名用户：<br><pre><code>  <h1 id="mysql-install-db"><a href="#mysql-install-db" class="headerlink" title="mysql_install_db"></a>mysql_install_db</h1><h1 id="mysql-secure-installation"><a href="#mysql-secure-installation" class="headerlink" title="mysql_secure_installation"></a>mysql_secure_installation</h1></code></pre> }</li>
</ul>
<p>####1.3、安装时间服务器  </p>
<ul>
<li>安装NTP服务器用于同步时间：apt-get install ntp</li>
<li>创建各自密码：暂时不考虑安全性，为了方便暂时保存在.bashrc中的环境变量中</li>
</ul>
<p>###2、Identity services配置</p>
<p><a id="single_res" name="single_res"> </a></p>
<p>单一责任原则，即一个类只能有一种原因去驱动改变，该原则的是同open-closed原则有异曲同工之妙：尽量避免现有代码的修改。当违反了单一原则的时候，一个模块有多种原因需要去修改。更糟的是，多个不同的责任集中于一个模块当中会耦合在一起，使得测试与修改变得非常复杂。  </p>
<p>单一责任原则本质是集中性，便于进行多层抽象，而不仅仅是一个过程上下文，简单地讲类替换为函数将有利于我们在此原则基础上分析算法。  </p>
<p>####2.1、验证机制  </p>
<p>####2.2、定义用户、租户和角色  </p>
<p>由于在/etc/keystone/keystone.conf中定义了admin_token，这是一个keystone和other openstack services的预共享密钥，在创建租户时会用到。  </p>
<ul>
<li>通过设置两个环境变量指定token和identity service运行的路径<br>export OS_SERVICE_TOKEN=ADMIN_TOKEN<br>export OS_SERVICE_ENDPOINT=<a href="http://controller:35357/v2.0" target="_blank" rel="external">http://controller:35357/v2.0</a></li>
<li>创建租户  </li>
</ul>
<p>keystone tenant-create –name=admin –description=”Admin Tenant”  </p>
<pre><code>  

+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
| description |           Admin Tenant           |
|   enabled   |               True               |
|      id     | 5e7178983104482a92433f55b09c6dcd |
|     name    |              admin               |
+-------------+----------------------------------+  
</code></pre> }

keystone tenant-create --name=service --description="Service Tenant"    

<pre><code> 
+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
| description |          Service Tenant          |
|   enabled   |               True               |
|      id     | 2b1ee1230ed34dcf9b73941f9e6b89c1 |
|     name    |             service              |
+-------------+----------------------------------+
</code></pre> }  

-    创建管理员用户  

keystone user-create --name=admin --pass=ADMIN_PASS --email=yangyongbupt168@gmail.com  

<pre><code>  
+----------+----------------------------------+
| Property |              Value               |
+----------+----------------------------------+
|  email   |    yangyongbupt168@gmail.com     |
| enabled  |               True               |
|    id    | d9308be3ba924b94ac051eb8d0750cd6 |
|   name   |              admin               |
+----------+----------------------------------+  
</code></pre> }    

-    创建角色：角色由各种OpenStack服务对应的policy.json文件指定，缺省的策略文件赋予admin角色访问大多数服务的权利。    

<pre><code> 
+----------+----------------------------------+
| Property |              Value               |
+----------+----------------------------------+
|    id    | 372478ee2d2647858d864ce9066acccd |
|   name   |              admin               |
+----------+----------------------------------+  
</code></pre> }    

-    为用户添加角色：用户总是以租户身份登录，角色通过租户被赋予给用户。例如，当用户admin以admin租户的身份登录时，赋予其admin角色。
    keystone user-role-add --user=admin --tenant=admin --role=admin    

####2.3、定义services和API endpoints  

-    为Identity services创建一个服务实体    

keystone service-create --name=keystone --type=identity --description="Keystone Identity Service"    

<pre><code>   
+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
| description |    Keystone Identity Service     |
|      id     | 7d36ad0a2c0f4ec893b1fedc95d5e9de |
|     name    |             keystone             |
|     type    |             identity             |
+-------------+----------------------------------+  
</code></pre> }    

-    利用返回的service ID（随机产生）创建API endpoint，其实就是创建内外网API等URL。

    keystone endpoint-create \
    --service-id=7d36ad0a2c0f4ec893b1fedc95d5e9de \
    --publicurl=http://controller:5000/v2.0 \
    --internalurl=http://controller:5000/v2.0 \
    --adminurl=http://controller:35357/v2.0  

<pre><code> 
+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
|   adminurl  |   http://controller:35357/v2.0   |
|      id     | 42eb21997c244fa480320fa8bd4102dc |
| internalurl |   http://controller:5000/v2.0    |
|  publicurl  |   http://controller:5000/v2.0    |
|    region   |            regionOne             |
|  service_id | 7d36ad0a2c0f4ec893b1fedc95d5e9de |
+-------------+----------------------------------+
</code></pre> }   

####2.4、验证Identity Services安装  

本质上是利用user/token验证绑定user/password的过程，期望通过user/password 查找token。  

-    删除临时环境变量

unset OS_SERVICE_TOKEN OS_SERVICE_ENDPOINT  

-    基于用户的验证：用admin的user/passord请求验证token  

keystone --os-username=admin --os-password=ADMIN_PASS \
    --os-auth-url=http://controller:35357/v2.0 token-get  

<pre><code>

+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Property |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| expires  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 2014-01-10T03:29:38Z                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|    id    | MIIC8QYJKoZIhvcNAQcCoIIC4jCCAt4CAQExCTAHBgUrDgMCGjCCAUcGCSqGSIb3DQEHAaCCATgEggE0eyJhY2Nlc3MiOiB7InRva2VuIjogeyJpc3N1ZWRfYXQiOiAiMjAxNC0wMS0wOVQwMzoyOTozOC4xNTMwNDAiLCAiZXhwaXJlcyI6ICIyMDE0LTAxLTEwVDAzOjI5OjM4WiIsICJpZCI6ICJwbGFjZWhvbGRlciJ9LCAic2VydmljZUNhdGFsb2ciOiBbXSwgInVzZXIiOiB7InVzZXJuYW1lIjogImFkbWluIiwgInJvbGVzX2xpbmtzIjogW10sICJpZCI6ICJkOTMwOGJlM2JhOTI0Yjk0YWMwNTFlYjhkMDc1MGNkNiIsICJyb2xlcyI6IFtdLCAibmFtZSI6ICJhZG1pbiJ9LCAibWV0YWRhdGEiOiB7ImlzX2FkbWluIjogMCwgInJvbGVzIjogW119fX0xggGBMIIBfQIBATBcMFcxCzAJBgNVBAYTAlVTMQ4wDAYDVQQIDAVVbnNldDEOMAwGA1UEBwwFVW5zZXQxDjAMBgNVBAoMBVVuc2V0MRgwFgYDVQQDDA93d3cuZXhhbXBsZS5jb20CAQEwBwYFKw4DAhowDQYJKoZIhvcNAQEBBQAEggEAAS-Fdhv74-kaGYHDuVnJo3ZHhfQ0sdXtdJE68V86gB3TnRMBvDizYaaBlUEDkVLEsOTf-SwO+2fVDnEQ82eARFwXi5RgGUW-rSPX-DU9iJob0ajc4Pn7tRioEzjUByON+8kYge7V5hmowc4e+qM7vvbUcLkTC3eKkF4b4xNg7JSCEMeRCIPSDlqOR3a-S5jODUSdQlfkcZyjocQjcQdaEBW8Rm+bv4TTVYi2PotbqoZQHGvVPg45cjeFnLFSs9XVCkFMx9rUgXmj4+FdV61t6wH0goJ5LriIHKOlKD0dp6V8RX0p1hpmFoD1dI+yDFD68dmmUV5t6gtluyZA5dJNBw== |
| user_id  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           d9308be3ba924b94ac051eb8d0750cd6                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

</code></pre> }   



这是一个包含用户ID的token paired。  

keystone --os-username=admin --os-password=ADMIN_PASS \
    --os-tenant-name=admin --os-auth-url=http://controller:35357/v2.0 token-get  

<pre><code>

+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|  Property |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|  expires  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           2014-01-10T03:41:25Z                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|     id    | MIIEsgYJKoZIhvcNAQcCoIIEozCCBJ8CAQExCTAHBgUrDgMCGjCCAwgGCSqGSIb3DQEHAaCCAvkEggL1eyJhY2Nlc3MiOiB7InRva2VuIjogeyJpc3N1ZWRfYXQiOiAiMjAxNC0wMS0wOVQwMzo0MToyNS45NjI4MzUiLCAiZXhwaXJlcyI6ICIyMDE0LTAxLTEwVDAzOjQxOjI1WiIsICJpZCI6ICJwbGFjZWhvbGRlciIsICJ0ZW5hbnQiOiB7ImRlc2NyaXB0aW9uIjogIkFkbWluIFRlbmFudCIsICJlbmFibGVkIjogdHJ1ZSwgImlkIjogIjVlNzE3ODk4MzEwNDQ4MmE5MjQzM2Y1NWIwOWM2ZGNkIiwgIm5hbWUiOiAiYWRtaW4ifX0sICJzZXJ2aWNlQ2F0YWxvZyI6IFt7ImVuZHBvaW50cyI6IFt7ImFkbWluVVJMIjogImh0dHA6Ly9jb250cm9sbGVyOjM1MzU3L3YyLjAiLCAicmVnaW9uIjogInJlZ2lvbk9uZSIsICJpbnRlcm5hbFVSTCI6ICJodHRwOi8vY29udHJvbGxlcjo1MDAwL3YyLjAiLCAiaWQiOiAiNzMzOWEwZDY1NDBlNGM0MGI4YWE4NGI1NDEzODNlMTYiLCAicHVibGljVVJMIjogImh0dHA6Ly9jb250cm9sbGVyOjUwMDAvdjIuMCJ9XSwgImVuZHBvaW50c19saW5rcyI6IFtdLCAidHlwZSI6ICJpZGVudGl0eSIsICJuYW1lIjogImtleXN0b25lIn1dLCAidXNlciI6IHsidXNlcm5hbWUiOiAiYWRtaW4iLCAicm9sZXNfbGlua3MiOiBbXSwgImlkIjogImQ5MzA4YmUzYmE5MjRiOTRhYzA1MWViOGQwNzUwY2Q2IiwgInJvbGVzIjogW3sibmFtZSI6ICJhZG1pbiJ9XSwgIm5hbWUiOiAiYWRtaW4ifSwgIm1ldGFkYXRhIjogeyJpc19hZG1pbiI6IDAsICJyb2xlcyI6IFsiMzcyNDc4ZWUyZDI2NDc4NThkODY0Y2U5MDY2YWNjY2QiXX19fTGCAYEwggF9AgEBMFwwVzELMAkGA1UEBhMCVVMxDjAMBgNVBAgMBVVuc2V0MQ4wDAYDVQQHDAVVbnNldDEOMAwGA1UECgwFVW5zZXQxGDAWBgNVBAMMD3d3dy5leGFtcGxlLmNvbQIBATAHBgUrDgMCGjANBgkqhkiG9w0BAQEFAASCAQA3-Ce1g6lmH707ibg+NDRTn2xiTds9SkWUvpHNTPSDvbnW5-eoSSE+Ty7EVMb5XFkCZlDYHHKuDRfdG9reFfQq9qVcXzS4R8FAxJF8V9Nfx4z76l1yGyZxRbn566uKPYc2BUlp3ZydeP7eX+k54GCNkPj+dMgCcr4weSCfuIXaVejKVsKaz1fJu7AmypeDa24fTjseJUTzqUNkCLp4+RkVMsb2SaQDgNSSJf890m+TB70zPJN63IasJvH8DnAzZ2G2F2MIw+zBAQ7kTl7lskRKOGVtUIZxxxb8TGWP+Y34VrAHLoUoXsP+fQhIlv-dKfuNt5qoWe0AlnBkrwQl3HK1 |
| tenant_id |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     5e7178983104482a92433f55b09c6dcd                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|  user_id  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     d9308be3ba924b94ac051eb8d0750cd6                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

</code></pre> }   


期望返回一绑定租户的token。  


-    脚本操作：上述手动操作的替代方法  

<pre><code> 
#!/bin/bash

export OS_USERNAME=admin
export OS_PASSWORD=ADMIN_PASS
export OS_TENANT_NAME=admin
export OS_AUTH_URL=http://controller:35357/v2.0  

</code></pre> }   

-    确保admin账户已经被验证

keystone user-list

<pre><code> 
+----------------------------------+-------+---------+---------------------------+
|                id                |  name | enabled |           email           |
+----------------------------------+-------+---------+---------------------------+
| d9308be3ba924b94ac051eb8d0750cd6 | admin |   True  | yangyongbupt168@gmail.com |
+----------------------------------+-------+---------+---------------------------+
</code></pre> 

<p>###3、OpenStack clients安装与配置  </p>
<p>通过命令行客户端进行API调用，可以设置在脚本中自动执行。在OpenStack内部，可以运行cURL命令执行内嵌API请求。OpenStack是一种基于HTTP协议REST风格的API，包括方法、URI、介质类型和响应代码。<br>每个Openstack服务都有自己的命令行客户端。</p>
<p>####3.1、基于python的开源客户端  </p>
<ul>
<li>ceilometer：度量openStack</li>
<li>cinder：创建和管理volume</li>
<li>glance:创建和管理图片</li>
<li>heat：从模板登录和管理stack</li>
<li>keystone:创建管理用户、租户、角色和密钥等</li>
<li>neutron：为客户端server配置网络</li>
<li>nova：管理图片、句柄和flavors</li>
<li>swift：统计Object Storage服务的元数据</li>
<li>充电</li>
</ul>
<p>###4、验证Identity Services安装     </p>
<p>####4.1、安装Image Service  </p>
<ul>
<li>注册Image服务和Identity服务，这样其他的OpenStack服务可以定位到它  </li>
</ul>
<p>keystone service-create –name=glance –type=image \<br>    –description=”Glance Image Service”</p>
<pre><code> 
+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
| description |       Glance Image Service       |
|      id     | 21b15dc9b1d846149883e953af08d906 |
|     name    |              glance              |
|     type    |              image               |
+-------------+----------------------------------+
</code></pre>  

<ul>
<li>利用serveice id创建endpoint</li>
</ul>
<p>keystone endpoint-create –service-id=21b15dc9b1d846149883e953af08d906 –publicurl=<a href="http://controller:9292" target="_blank" rel="external">http://controller:9292</a> –internalurl=<a href="http://controller:9292" target="_blank" rel="external">http://controller:9292</a> \<br>    –adminurl=<a href="http://controller:9292" target="_blank" rel="external">http://controller:9292</a></p>
<pre><code> 
+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
|   adminurl  |      http://controller:9292      |
|      id     | 9cf77dd344514215812b1391dbf2b498 |
| internalurl |      http://controller:9292      |
|  publicurl  |      http://controller:9292      |
|    region   |            regionOne             |
|  service_id | 21b15dc9b1d846149883e953af08d906 |
+-------------+----------------------------------+
</code></pre>  

<p>####4.2、安装Image Service</p>
<p>验证安装：  </p>
<ul>
<li>上传Image</li>
</ul>
<p>root@controller:/home/fyang/project/images# glance image-create –name=”CirrOS 0.3.0” –disk-format=qcow2 –container-format=bare –is-public=true &lt; cirros-0.3.0-x86_64-disk.img   </p>
<p>root@controller:/home/fyang/project/images# glance image-create –name=”CirrOS 0.3.0” –disk-format=qcow2 –container-format=bare –is-public=true &lt; cirros-0.3.0-x86_64-disk.img  </p>
<ul>
<li>显示Image列表  </li>
</ul>
<p>glance image-list</p>
<pre><code> 
+--------------------------------------+--------------+-------------+------------------+---------+--------+
| ID                                   | Name         | Disk Format | Container Format | Size    | Status |
+--------------------------------------+--------------+-------------+------------------+---------+--------+
| 59c63869-ce77-4647-90b5-782d258e3354 | CirrOS 0.3.0 | qcow2       | bare             | 9761280 | active |
| 05f2ae82-0926-4b8a-9d11-dfc99d8ee845 | CirrOS 0.3.1 | qcow2       | bare             | 9761280 | active |
+--------------------------------------+--------------+-------------+------------------+---------+--------+
</code></pre>  

<p>###5、计算控制服务安装与配置  </p>
<p>####5.1、概述  </p>
<p>####5.1、安装Image Service  </p>
<ul>
<li>创建计算服务表：</li>
</ul>
<p>nova-manage db sync  </p>
<pre><code>
    2014-01-09 17:45:46.814 7918 INFO migrate.versioning.api [-] 215 -> 216... 
2014-01-09 17:45:46.837 7918 INFO migrate.versioning.api [-] done
</code></pre>  

<ul>
<li>创建用户</li>
</ul>
<p>keystone user-create –name=nova –pass=NOVA_PASS –email=nova@example.</p>
<pre><code>
+----------+----------------------------------+
| Property |              Value               |
+----------+----------------------------------+
|  email   |          nova@example.           |
| enabled  |               True               |
|    id    | 26e1951aa2264a11800c68cc58dbce59 |
|   name   |               nova               |
+----------+----------------------------------+
</code></pre>  

<ul>
<li>充电</li>
</ul>
<p>root@controller:/home/fyang/project/images# keystone service-create –name=nova –type=compute –description=”Nova Compute service”  </p>
<pre><code>
+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
| description |       Nova Compute service       |
|      id     | 0d67dd130ebc4de2ba8e54ac241e92d0 |
|     name    |               nova               |
|     type    |             compute              |
+-------------+----------------------------------+

</code></pre>  

<ul>
<li>创建endpoint</li>
</ul>
<p>root@controller:/home/fyang/project# keystone endpoint-create –service-id=0d67dd130ebc4de2ba8e54ac241e92d0 –publicurl=<a href="http://controller:8774/v2/%\(tenant_id\)s" target="_blank" rel="external">http://controller:8774/v2/%\(tenant_id\)s</a> –internalurl=<a href="http://controller:8774/v2/%\(tenant_id\)s" target="_blank" rel="external">http://controller:8774/v2/%\(tenant_id\)s</a> –adminurl=<a href="http://controller:8774/v2/%\(tenant_id\)s" target="_blank" rel="external">http://controller:8774/v2/%\(tenant_id\)s</a>  </p>
<pre><code>
+-------------+-----------------------------------------+
|   Property  |                  Value                  |
+-------------+-----------------------------------------+
|   adminurl  | http://controller:8774/v2/%(tenant_id)s |
|      id     |     21f036edca9547e196b5976a4c31f561    |
| internalurl | http://controller:8774/v2/%(tenant_id)s |
|  publicurl  | http://controller:8774/v2/%(tenant_id)s |
|    region   |                regionOne                |
|  service_id |     0d67dd130ebc4de2ba8e54ac241e92d0    |
+-------------+-----------------------------------------+  
</code></pre>  
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文由&lt;a href=&quot;http://skypacer210.github.io/&quot;&gt;skypacer&lt;/a&gt;根据&lt;a href=&quot;http://docs.openstack.org/trunk/install-guide/install/apt/content/&quot; tar
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="deploy" scheme="https://skypacer210.github.io/tags/deploy/"/>
    
      <category term="openstack" scheme="https://skypacer210.github.io/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>REACTOR设计模式C实现</title>
    <link href="https://skypacer210.github.io/2014/01/02/patterns-in-c-reactor/"/>
    <id>https://skypacer210.github.io/2014/01/02/patterns-in-c-reactor/</id>
    <published>2014-01-01T16:00:00.000Z</published>
    <updated>2017-08-09T14:27:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文由<a href="http://skypacer210.github.io/">skypacer</a>译自<a href="http://www.adampetersen.se/Patterns%20in%20C%205,%20REACTOR.pdf" target="_blank" rel="external">Patterns in C REACTOR</a>，原文作者<a href="http://www.adampetersen.se/" target="_blank" rel="external">Adam Petersen</a>。</p>
<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><hr>
<p>本篇英文原文所发布的站点<a href="http://www.adampetersen.se/" target="_blank" rel="external">Adam Petersen</a>是一个个人网站，本文翻译了其中reactor C实现章节, 水平有限，欢迎指正。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><hr>
<p>1、<a href="#mutil_client">多客户端示例</a><br>2、<a href="#single_res">单一责任原则</a><br>3、<a href="#open_closed">违反Open-Closed原则</a><br>4、<a href="#performance">从性能谈起</a><br>5、<a href="#issue_sum">问题总结</a><br>6、<a href="#reactor_pattern">REACTOR模式</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.1、<a href="#6.1">事件探测</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.2、<a href="#6.2">实现机制</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.3、<a href="#6.3">Reactor注册策略</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.4、<a href="#6.4">Reactor实现</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.5、<a href="#6.5">触发Reactor</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.6、<a href="#6.6">处理注册</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.7、<a href="#6.7">事件多样性</a><br>7、<a href="#vs">REACTOR vs OBSERVER</a><br>8、<a href="#cons">结论</a><br>9、<a href="#sum">总结</a>            </p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><hr>
<p><a id="mutil_client" name="mutil_client"> </a>  </p>
<p>本文将研究一种适用于<em>event-driven</em>应用的模式。Reactor Pattern将应用的不同职责解耦，允许应用由多个潜在的client端分离并分发事件。</p>
<h3 id="1、多客户端示例"><a href="#1、多客户端示例" class="headerlink" title="1、多客户端示例"></a>1、多客户端示例</h3><p>为了简化对大系统的维护，工程师可以单独搜集子系统的诊断信息然后再合并至中心。每个子系统利用TCP/IP连接至诊断服务器，由于TCP/IP是一个面向连接的协议，客户端（不同的子系统）不得不单独向server请求相应的连接。一旦连接建立，client可以随时发送诊断信息。  </p>
<p>为了解决这个问题，最容易想到的方法就是服务器依次扫描客户端的连接请求和诊断信息，如下图所示：      </p>
<p><img src="/assets/images/reactor_figure_1.png" alt="图片">  </p>
<center>Figure 1: eternal loop to scan for different events</center>

<p>尽管这是一个极其简化的例子，这里仍然存在不少潜在的问题。首先是该方法将应用逻辑、网络代码、事件分发代码这几个毫不相干的逻辑捆绑在一起，会带来严重的维护、测试和可扩展问题，这样的设计违反了基本的设计原则。  </p>
<p><a id="mutil_client" name="mutil_client"> </a>    </p>
<h3 id="2、单一责任原则"><a href="#2、单一责任原则" class="headerlink" title="2、单一责任原则"></a>2、单一责任原则</h3><p><a id="single_res" name="single_res"> </a></p>
<p>单一责任原则，即一个类只能有一种原因去驱动改变，该原则的是同open-closed原则有异曲同工之妙：尽量避免现有代码的修改。当违反了单一原则的时候，一个模块有多种原因需要去修改。更糟的是，多个不同的责任集中于一个模块当中会耦合在一起，使得测试与修改变得非常复杂。  </p>
<p>单一责任原则本质是集中性，便于进行多层抽象，而不仅仅是一个过程上下文，简单地讲类替换为函数将有利于我们在此原则基础上分析算法。  </p>
<h3 id="3、违反Open-Closed原则"><a href="#3、违反Open-Closed原则" class="headerlink" title="3、违反Open-Closed原则"></a>3、违反Open-Closed原则</h3><p><a id="open_closed" name="open_closed"> </a>  </p>
<p>如果违反了Open-Closed原则，上述例子的模块将变得难以维护，或者该代码在设计之初就没打算扩展性。不幸的是，该中设计已经违反了Open-Closed原则，若不改变现有代码，新的功能将无法加入。总而言之，这种设计使得修改代码变得代价高昂。  </p>
<h3 id="4、从性能谈起"><a href="#4、从性能谈起" class="headerlink" title="4、从性能谈起"></a>4、从性能谈起</h3><p><a id="performance" name="performance"> </a>  </p>
<p>这种方案的糟糕之处还在于整个系统的性能变得很差，当线性扫描所有事件时，尽快采用了超时机制，然而很多时间被白白浪费了。  </p>
<p>一个潜在的性能问题就是并发失败的处理，一种解决方案是引入多线程，诊断服务器轮询事件，但是此时的轮询代价已经只剩下处理连接请求，一旦请求建立，分配相应的线程处理该连接上的所有消息处理。  </p>
<p>然后多线程方案无法从根本上解决这种设计的问题：违反了单一责任原则和Open-Closed原则。尽管扫描代码和诊断消息处理从主循环中移除，添加一个新的服务端口仍需修改现有代码。  </p>
<p>从设计的角度看，线程不能改变任何事情，事实上，即使考虑到性能，这种改进导致上下文切换和同步，反而比单线程方法更糟。</p>
<h3 id="5、问题总结"><a href="#5、问题总结" class="headerlink" title="5、问题总结"></a>5、问题总结</h3><p><a id="issue_sum" name="issue_sum"> </a>  </p>
<p>总结以上的经验，我们发现上述设计方南的失败之处归结于它们以三种责任为解决前提。问题即违反了Open-Closed原则，导致难于修改现有代码。  </p>
<p>理想的解决方案应该是易于扩展、封装和多种责任解耦，并能够同时服务多个客户端，即使不引入多线程。Reactor模式通过在事件处理中封装应用逻辑和在事件分发中隔离代码很好的解决了这些问题。  </p>
<h3 id="6、REACTOR模式"><a href="#6、REACTOR模式" class="headerlink" title="6、REACTOR模式"></a>6、REACTOR模式</h3><p><a id="reactor_pattern" name="reactor_pattern"> </a>  </p>
<p>Reactor模式定义：“reactor架构使得事件驱动型的不同应用实现分离，并将来自一个或多个客户端的服务请求分发至一个应用中”。  </p>
<p><img src="/assets/images/reactor_figure_2.png" alt="图片"></p>
<center>Figure 2: Structure of the REACTOR pattern</center>   

<p>其中包含的参与者如下：  </p>
<ul>
<li><strong>EventHandler</strong>：一个EventHandler定义了一个接口，该接口由处理事件的模块实现，每个EventHandler有自己的Handle。  </li>
<li><strong>Handle</strong>：<strong>Handle</strong> 本质是reactor模式在OS上实现的具体句柄，例如，<strong>handle</strong>  包含了像文件、socket和timer等系统资源。</li>
<li><strong>DiagnosticsServer</strong> and <strong>DiagnosticsClient</strong>: 这是两种具体的事件handler，每个独立封装一个责任，为了能够接受事件通知，这些具体的事件handlers必须在 <strong>Reactor</strong> 中进行注册。</li>
<li><strong>Reactor</strong>：<strong>Reactor</strong> 维护 <strong>EventHandler</strong> 的注册，并取出相应的 <strong>Handles</strong>. <strong>Reactor</strong> 等待已经注册 <strong>handles</strong> 中的事件，当 <strong>Handle</strong> 通知事件发生时，触发相应的 <strong>EventHandler</strong> 。</li>
</ul>
<h4 id="6-1、事件探测"><a href="#6-1、事件探测" class="headerlink" title="6.1、事件探测"></a>6.1、事件探测</h4><p><a id="6.1" name="6.1"> </a>  </p>
<p>在一些文献中关于 <strong>reactor</strong> 的描述中，定义了一个工具，即 <strong>synchronous Event Demultiplexer </strong>， 该分离器由 <strong>reactor</strong> 调用等待已经注册的 <strong>Handles</strong> 的事件。 </p>
<p>该事件分离器一般由操作系统提供，比如 <em>poll()</em> ，<em>select()</em> 和 <em>WaitForMutipleObjects()</em> 。</p>
<h4 id="6-2、实现机制"><a href="#6-2、实现机制" class="headerlink" title="6.2、实现机制"></a>6.2、实现机制</h4><p><a id="6.2" name="6.2"> </a>    </p>
<p><strong>EventHandler</strong> 和 <strong>Reactor</strong> 之间的合作关系类似OBSERVER模式中的observer和它的对象。    </p>
<p>为了将Reactor和它的事件处理器解耦，同时Reactor仍能够通知到他们，每个具体的事件处理器必须关联一个唯一的instance。这里的C实现中，采用void <em>作为通用类型以描述 <em>*EventHandler</em></em> 接口。  </p>
<ul>
<li>事件处理接口：EventHandler.h  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">14 #ifndef EVENT_HANDLER_H</div><div class="line">15 #define EVENT_HANDLER_H</div><div class="line">16 </div><div class="line">17 #include &quot;Handle.h&quot;</div><div class="line">18 </div><div class="line">19 /* All interaction from Reactor to an event handler goes </div><div class="line">20 through function pointers with the following signatures: */</div><div class="line">21 typedef Handle (*getHandleFunc)(void *instance);</div><div class="line">22 typedef void (*handleEventFunc)(void *instance);</div><div class="line">23 </div><div class="line">24 typedef struct &#123;</div><div class="line">25 .       void *instance;</div><div class="line">26 .       getHandleFunc getHandle;</div><div class="line">27 .       handleEventFunc handleEvent;</div><div class="line">28 &#125; EventHandler;</div><div class="line">29 </div><div class="line">30 #endif</div></pre></td></tr></table></figure>
<ul>
<li>Reactor注册接口：ractor.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">14 #ifndef REACTOR\_H</div><div class="line">15 #define REACTOR\_H</div><div class="line">16</div><div class="line">17 #include &quot;EventHandler.h&quot;</div><div class="line">18</div><div class="line">19 void Register(EventHandler* handler);</div><div class="line">20 void Unregister(EventHandler* handler);</div><div class="line">21</div><div class="line">22 #endif</div></pre></td></tr></table></figure>
<ul>
<li>具体的事件处理器：DiagnosticsServer.c</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div></pre></td><td class="code"><pre><div class="line"> 22 #include &quot;base.h&quot;</div><div class="line"> 23 #include &quot;DiagnosticsServer.h&quot;</div><div class="line"> 24 #include &quot;DiagnosticsClient.h&quot;</div><div class="line"> 25 #include &quot;EventHandler.h&quot;</div><div class="line"> 26 #include &quot;ServerEventNotifier.h&quot;</div><div class="line"> 27 #include &quot;Reactor.h&quot;</div><div class="line"> 28 </div><div class="line"> 29 #include &quot;Error.h&quot;</div><div class="line"> 30 #include &quot;TcpServer.h&quot;</div><div class="line"> 31 </div><div class="line"> 32 #define MAX\_NO\_OF\_CLIENTS 10</div><div class="line"> 33 </div><div class="line"> 34 struct DiagnosticsServer &#123;</div><div class="line"> 35 .       Handle listeningSocket;</div><div class="line"> 36 .       EventHandler eventHandler;</div><div class="line"> 37 </div><div class="line"> 38 .       /* All connected clients able to send diagnostics messages. */</div><div class="line"> 39 .       DiagnosticsClientPtr clients[MAX\_NO\_OF\_CLIENTS];</div><div class="line"> 40 &#125;;</div><div class="line"> 41 </div><div class="line"> 42 /************************************************************</div><div class="line"> 43 * Function declarations.</div><div class="line"> 44 ************************************************************/</div><div class="line"> 45 </div><div class="line"> 46 static void deleteAllClients(DiagnosticsServerPtr server);</div><div class="line"> 47 </div><div class="line"> 48 static int matchControlledClientByPointer(const DiagnosticsServerPtr server, const DiagnosticsClientPtr clientToMatch);</div><div class="line"> 49 </div><div class="line"> 50 static int findFreeClientSlot(const DiagnosticsServerPtr server);</div><div class="line"> 51 </div><div class="line"> 52 static int findMatchingClientSlot(const DiagnosticsServerPtr server, const DiagnosticsClientPtr client);</div><div class="line"> 53 </div><div class="line"> 54 static Handle getServerSocket(void* instance);</div><div class="line"> 55 </div><div class="line"> 56 static void handleConnectRequest(void* instance);</div><div class="line"> 57 </div><div class="line"> 58 static void onClientClosed(void* server, void* closedClient);</div><div class="line"> 59 </div><div class="line"> 60 /************************************************************</div><div class="line"> 61 * Implementation of the EventHandler interface.</div><div class="line"> 62 ************************************************************/</div><div class="line"> 63 </div><div class="line"> 64 static Handle getServerSocket(void* instance)</div><div class="line"> 65 &#123;</div><div class="line"> 66    const DiagnosticsServerPtr server = instance;</div><div class="line"> 67    return server-&gt;listeningSocket;</div><div class="line"> 68 &#125;</div><div class="line"> 69 </div><div class="line"> 70 static void handleConnectRequest(void* instance)</div><div class="line"> 71 &#123;</div><div class="line"> 72 .       DiagnosticsServerPtr server = instance;</div><div class="line"> 73 </div><div class="line"> 74 .       const int freeSlot = findFreeClientSlot(server);</div><div class="line"> 75 </div><div class="line"> 76 .       if(0 &lt;= freeSlot) &#123;</div><div class="line"> 77 .       .       /* Define a callback for events requiring the actions of the server (for example </div><div class="line"> 78 .       .          a closed connection). */</div><div class="line"> 79 .       .       ServerEventNotifier eventNotifier = &#123;0&#125;;</div><div class="line"> 80 .       .       eventNotifier.server = server;</div><div class="line"> 81 .       .       eventNotifier.onClientClosed = onClientClosed;</div><div class="line"> 82 </div><div class="line"> 83 .       .       server-&gt;clients[freeSlot] = createClient(server-&gt;listeningSocket, &amp;eventNotifier);</div><div class="line"> 84 </div><div class="line"> 85 .       .       ne_debug(REACTOR_DEBUG, &quot;Server: Incoming connect request accepted\n&quot;);</div><div class="line"> 86 .       &#125;</div><div class="line"> 87 .       else &#123;</div><div class="line"> 88 .       .       ne_debug(REACTOR_DEBUG, &quot;Server: Not space for more clients\n&quot;);</div><div class="line"> 89 .       &#125;</div><div class="line"> 90 &#125;</div><div class="line"> 91 </div><div class="line"> 92 /************************************************************</div><div class="line"> 93 * Implementation of the ServerEventNotifier interface. </div><div class="line"> 94 ************************************************************/</div><div class="line"> 95 </div><div class="line"> 96 /**</div><div class="line"> 97 * This function is invoked as a callback from the client representation </div><div class="line"> 98 * in case it detects a disconnect on TCP level.</div><div class="line"> 99 */</div><div class="line">100 static void onClientClosed(void* server,</div><div class="line">101 .       .       void* closedClient)</div><div class="line">102 &#123;</div><div class="line">103 .       DiagnosticsServerPtr serverInstance = server;</div><div class="line">104 .       DiagnosticsClientPtr clientInstance = closedClient;</div><div class="line">105 </div><div class="line">106 .       const int clientSlot = findMatchingClientSlot(serverInstance, clientInstance);</div><div class="line">107 </div><div class="line">108 .       if(0 &gt; clientSlot) &#123;</div><div class="line">109 .       .       ne_debug(REACTOR_DEBUG, &quot;Phantom client detected\n&quot;);</div><div class="line">110 .       .       return;</div><div class="line">111 .       &#125;</div><div class="line">112 </div><div class="line">113 .       destroyClient(clientInstance);</div><div class="line">114 </div><div class="line">115 .       serverInstance-&gt;clients[clientSlot] = NULL;</div><div class="line">116 &#125;</div><div class="line">117 </div><div class="line">118 /************************************************************</div><div class="line">119 * Implementation of the ADT functions of the server. </div><div class="line">120 ************************************************************/</div><div class="line">121 </div><div class="line">122 /**</div><div class="line">123 * Creates a server listening for connect requests on the given port.</div><div class="line">124 * The server registers itself at the Reactor upon creation.</div><div class="line">125 */</div><div class="line">126 DiagnosticsServerPtr createServer(unsigned int tcpPort)</div><div class="line">127 &#123;</div><div class="line">128 .       DiagnosticsServerPtr newServer = malloc(sizeof *newServer);</div><div class="line">129 </div><div class="line">130 .       if(NULL != newServer) &#123;</div><div class="line">131 .       .       int i = 0;</div><div class="line">132 </div><div class="line">133 .       .       for(i = 0; i &lt; MAX_NO_OF_CLIENTS; ++i) &#123;</div><div class="line">134 .       .       .       newServer-&gt;clients[i] = NULL;</div><div class="line">135 .       .       &#125;</div><div class="line">136 </div><div class="line">137 .       .       newServer-&gt;listeningSocket = createServerSocket(tcpPort);</div><div class="line">138 .       .       if (newServer-&gt;listeningSocket &lt; 0) &#123;</div><div class="line">139 .       .       .       ne_debug(REACTOR_DEBUG, &quot;fail create sock=%d.\n&quot;, newServer-&gt;listeningSocket);</div><div class="line">140 .       .       .       return NULL;</div><div class="line">141 .       .       &#125;</div><div class="line">142 </div><div class="line">143 .       .       /* Successfully created -&gt; register the listening socket. */</div><div class="line">144 .       .       newServer-&gt;eventHandler.instance = newServer;</div><div class="line">145 .       .       newServer-&gt;eventHandler.getHandle = getServerSocket;</div><div class="line">146 .       .       newServer-&gt;eventHandler.handleEvent = handleConnectRequest;</div><div class="line">147 </div><div class="line">148 .       .       Register(&amp;newServer-&gt;eventHandler);</div><div class="line">149 .       .       ne_debug(REACTOR_DEBUG, &quot;register event sock=%d.\n&quot;, newServer-&gt;listeningSocket);</div><div class="line">150 .       &#125;</div><div class="line">151 </div><div class="line">152 .       return newServer;</div><div class="line">153 &#125;</div><div class="line">154 </div><div class="line">155 /**</div><div class="line">156 * Unregisters at the Reactor and deletes all connected clients </div><div class="line">157 * before the server itself is disposed.</div><div class="line">158 * After completion of this function, the server-handle is invalid.</div><div class="line">159 */</div><div class="line">160 void destroyServer(DiagnosticsServerPtr server)</div><div class="line">161 &#123;</div><div class="line">162 .       deleteAllClients(server);</div><div class="line">163 </div><div class="line">164 .       /* Before deleting the server we have to unregister at the Reactor. */</div><div class="line">165 .       Unregister(&amp;server-&gt;eventHandler);</div><div class="line">166 </div><div class="line">167 .       disposeServerSocket(server-&gt;listeningSocket);</div><div class="line">168 .       free(server);</div><div class="line">169 &#125;</div><div class="line">170 </div><div class="line">171 /************************************************************</div><div class="line">172 * Definition of the local utility functions.</div><div class="line">173 ************************************************************/</div><div class="line">174 </div><div class="line">175 static void deleteAllClients(DiagnosticsServerPtr server)</div><div class="line">176 &#123;</div><div class="line">177 .       int i = 0;</div><div class="line">178 </div><div class="line">179 .       for(i = 0; i &lt; MAX_NO_OF_CLIENTS; ++i) &#123;</div><div class="line">180 .       .       if(NULL != server-&gt;clients[i]) &#123;</div><div class="line">181 .       .       .       destroyClient(server-&gt;clients[i]);</div><div class="line">182 .       .       &#125;</div><div class="line">183 .       &#125;</div><div class="line">184 &#125;</div><div class="line">185 </div><div class="line">186 /**</div><div class="line">187 * Returns the index where a client matching the given pointer is found.</div><div class="line">188 * Returns -1 if no match was found. </div><div class="line">189 */</div><div class="line">190 static int matchControlledClientByPointer(const DiagnosticsServerPtr server,</div><div class="line">191 .       .       const DiagnosticsClientPtr clientToMatch)</div><div class="line">192 &#123;</div><div class="line">193 .       int clientSlot = -1;</div><div class="line">194 .       int slotFound = 0;</div><div class="line">195 .       int i = 0;</div><div class="line">196 </div><div class="line">197 .       for(i = 0; (i &lt; MAX_NO_OF_CLIENTS) &amp;&amp; (0 == slotFound); ++i) &#123;</div><div class="line">198 </div><div class="line">199 .       .       if(clientToMatch == server-&gt;clients[i]) &#123;</div><div class="line">200 .       .       .       clientSlot = i;</div><div class="line">201 .       .       .       slotFound = 1;</div><div class="line">202 .       .       &#125;</div><div class="line">203 .       &#125;</div><div class="line">204 </div><div class="line">205 .       return clientSlot;</div><div class="line">206 &#125;</div><div class="line">207 </div><div class="line">208 static int findFreeClientSlot(const DiagnosticsServerPtr server)</div><div class="line">209 &#123;</div><div class="line">210 .       return matchControlledClientByPointer(server, NULL);</div><div class="line">211 &#125;</div><div class="line">212 </div><div class="line">213 static int findMatchingClientSlot(const DiagnosticsServerPtr server,</div><div class="line">214 .       .       const DiagnosticsClientPtr client)</div><div class="line">215 &#123;  </div><div class="line">216 .       return matchControlledClientByPointer(server, client);</div><div class="line">217 &#125;</div></pre></td></tr></table></figure>
<h4 id="6-3、Reactor注册策略"><a href="#6-3、Reactor注册策略" class="headerlink" title="6.3、Reactor注册策略"></a>6.3、Reactor注册策略</h4><p><a id="6.3" name="6.3"> </a>  </p>
<p>当实现具体的事件处理器时定义抽象数据结构，这样做的好处是封装具体的注册处理细节，这样就隐藏了具体的信息，client甚至无需了解如何同reactor交互。  </p>
<p>Reactor的另外一个好处体现在server内部，比如说对handle的封装通过getServerSocket获得，这样我们为reactor提供一个方式获取handle；同时，reactor对事件处理器进行访问控制：只有注册的事件处理器方可被调用相应的handle及其相关资源。  </p>
<h4 id="6-4、Reactor实现"><a href="#6-4、Reactor实现" class="headerlink" title="6.4、Reactor实现"></a>6.4、Reactor实现</h4><p><a id="6.4" name="6.4"> </a>  </p>
<p>Reactor的实现依赖于具体的同步事件分发器，如果OS提供了多种同步事件分发器，比如select()和poll()，Reactor就需要针对这些分发器实现多个reactor实例，并由链接器根据问题选择，即所谓的链接多态。  </p>
<p>每种Reactor的实现必须确定该应用下所需要的reactor实例。在多数场景中，应用只需一个reactor实例，即single reactor。如果应用需要多个reactor实例，则可以对reactor本身进行抽象。  </p>
<p>为了独立于具体的分离机制，Reactor必须维护一个已注册具体的事件处理器集合。简单地做法就是采用数组，适用于最大的客户端数目已知的情形。  </p>
<p>基于Poll()实现的Reactor：PollReactor.c  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div></pre></td><td class="code"><pre><div class="line">19 #include &quot;base.h&quot;</div><div class="line"> 20 #include &quot;Reactor.h&quot;</div><div class="line"> 21 #include &quot;ReactorEventLoop.h&quot;</div><div class="line"> 22 </div><div class="line"> 23 #include &quot;Error.h&quot;</div><div class="line"> 24 </div><div class="line"> 25 #include &lt;sys/poll.h&gt;</div><div class="line"> 26 #define POLLRDNORM      0x0040          /* non-OOB/URG data available */</div><div class="line"> 27 </div><div class="line"> 28 #include &lt;assert.h&gt;</div><div class="line"> 29 #include &lt;stddef.h&gt;</div><div class="line"> 30 #include &lt;stdio.h&gt;</div><div class="line"> 31 </div><div class="line"> 32 #define MAX_NO_OF_HANDLES 32</div><div class="line"> 33 </div><div class="line"> 34 /* POSIX requires &lt;poll.h&gt; to define INFTIM. </div><div class="line"> 35    However, in my environment it doesn&apos;t -&gt; follow the recommendations by Mr. Stevens.</div><div class="line"> 36 */</div><div class="line"> 37 #ifndef INFTIM</div><div class="line"> 38 #define INFTIM -1</div><div class="line"> 39 #endif</div><div class="line"> 40 </div><div class="line"> 41 /* Bind an event handler to the struct used to interface poll(). */</div><div class="line"> 42 typedef struct</div><div class="line"> 43 &#123;</div><div class="line"> 44    int isUsed;</div><div class="line"> 45    EventHandler handler;</div><div class="line"> 46    struct pollfd fd;</div><div class="line"> 47 &#125; HandlerRegistration;</div><div class="line"> 48 </div><div class="line"> 49 static HandlerRegistration registeredHandlers[MAX_NO_OF_HANDLES];</div><div class="line"> 50 </div><div class="line"> 51 /************************************************************</div><div class="line"> 52 * Function declarations.</div><div class="line"> 53 ************************************************************/</div><div class="line"> 54 </div><div class="line"> 55 /* Add a copy of the given handler to the first free position in registeredHandlers. */</div><div class="line"> 56 static int addToRegistry(EventHandler* handler);</div><div class="line"> 57 </div><div class="line"> 58 /* Identify the event handler in the registeredHandlers and remove it. */</div><div class="line"> 59 static int removeFromRegistry(EventHandler* handler);</div><div class="line"> 60 </div><div class="line"> 61 /* Add a copy of all registered handlers to the given array. */</div><div class="line"> 62 static size_t buildPollArray(struct pollfd* fds);</div><div class="line"> 63 </div><div class="line"> 64 /* Identify the event handler corresponding to the given descriptor in the registeredHandlers. */</div><div class="line"> 65 static EventHandler* findHandler(int fd);</div><div class="line"> 66 </div><div class="line"> 67 /* Detect all signalled handles and invoke their corresponding event handlers. */</div><div class="line"> 68 static void dispatchSignalledHandles(const struct pollfd* fds, size_t noOfHandles);</div><div class="line"> 69 </div><div class="line"> 70 /****************************************************************</div><div class="line"> 71 * Implementation of the Reactor interface used for registrations.</div><div class="line"> 72 *****************************************************************/</div><div class="line"> 73 </div><div class="line"> 74 void Register(EventHandler* handler)</div><div class="line"> 75 &#123;</div><div class="line"> 76 .       assert(NULL != handler);</div><div class="line"> 77 </div><div class="line"> 78 .       if(!addToRegistry(handler)) &#123;</div><div class="line"> 79 .       .       /* NOTE: In production code, this error should be delegated to the client instead. */</div><div class="line"> 80 .       .       ne_debug(REACTOR_DEBUG, &quot;No more registrations possible\n&quot;);</div><div class="line"> 81 .       .       return;</div><div class="line"> 82 .       &#125;</div><div class="line"> 83 &#125;</div><div class="line"> 84 </div><div class="line"> 85 void Unregister(EventHandler* handler)</div><div class="line"> 86 &#123;</div><div class="line"> 87 .       assert(NULL != handler);</div><div class="line"> 88 </div><div class="line"> 89 .       if(!removeFromRegistry(handler)) &#123;</div><div class="line"> 90 .       .       /* NOTE: In production code, this error should be delegated to the client instead. */</div><div class="line"> 91 .       .       ne_debug(REACTOR_DEBUG,&quot;Event handler not registered\n&quot;);</div><div class="line"> 92 .       .       return;</div><div class="line"> 93 .       &#125;</div><div class="line"> 94 &#125;</div><div class="line"> 95 </div><div class="line"> 96 /****************************************************************</div><div class="line"> 97 * Implementation of the reactive event loop </div><div class="line"> 98 * (interface separated in ReactorEventLoop.h).</div><div class="line"> 99 *****************************************************************/</div><div class="line">100 </div><div class="line">101 void HandleEvents(void)</div><div class="line">102 &#123;</div><div class="line">103 .       /* Build the array required to interact with poll().*/</div><div class="line">104 .       struct pollfd fds[MAX_NO_OF_HANDLES] = &#123;0&#125;;</div><div class="line">105 </div><div class="line">106 .       const size_t noOfHandles = buildPollArray(fds);</div><div class="line">107 </div><div class="line">108 .       /* Inoke the synchronous event demultiplexer.*/</div><div class="line">109 .       if(0 &lt; poll(fds, noOfHandles, INFTIM))&#123;</div><div class="line">110 //.     if(0 &lt; poll(fds, noOfHandles, 5000))&#123;</div><div class="line">111 .       .       /* Identify all signalled handles and invoke the event handler associated with each one. */</div><div class="line">112 .       .       dispatchSignalledHandles(fds, noOfHandles);</div><div class="line">113 .       &#125;</div><div class="line">114 .       else&#123;</div><div class="line">115 .       .       ne_debug(REACTOR_DEBUG, &quot;Poll failure\n&quot;);</div><div class="line">116 .       .       return;</div><div class="line">117 .       &#125;</div><div class="line">118 &#125;</div><div class="line">119 </div><div class="line">120 /************************************************************</div><div class="line">121 * Definition of the local utility functions.</div><div class="line">122 ************************************************************/</div><div class="line">123 </div><div class="line">124 /**</div><div class="line">125 * Add a copy of the given handler to the first free position in registeredHandlers.</div><div class="line">126 */</div><div class="line">127 static int addToRegistry(EventHandler* handler)</div><div class="line">128 &#123;</div><div class="line">129 .       /* Identify the first free position. */</div><div class="line">130 .       int isRegistered = 0;</div><div class="line">131 .       int i = 0;</div><div class="line">132 </div><div class="line">133 .       for(i = 0; (i &lt; MAX_NO_OF_HANDLES) &amp;&amp; (0 == isRegistered); ++i) &#123;</div><div class="line">134 .       .       if(0 == registeredHandlers[i].isUsed) &#123;</div><div class="line">135 .       .       .       /* A free position found. */</div><div class="line">136 .       .       .       HandlerRegistration* freeEntry = &amp;registeredHandlers[i];</div><div class="line">137 </div><div class="line">138 .       .       .       /* Create a binding between the handle provided by the client and the events of interest. */</div><div class="line">139 .       .       .       freeEntry-&gt;handler = *handler;</div><div class="line">140 .       .       .       freeEntry-&gt;fd.fd = handler-&gt;getHandle(handler-&gt;instance);</div><div class="line">141 .       .       .       freeEntry-&gt;fd.events = POLLRDNORM;</div><div class="line">142 </div><div class="line">143 .       .       .       isRegistered = freeEntry-&gt;isUsed = 1;</div><div class="line">144 </div><div class="line">145 .       .       .       ne_debug(REACTOR_DEBUG, &quot;Reactor: Added handle with ID=%d\n&quot;, freeEntry-&gt;fd.fd);</div><div class="line">146 .       .       &#125;</div><div class="line">147 .       &#125;</div><div class="line">148 </div><div class="line">149 .       return isRegistered;</div><div class="line">150 &#125;</div><div class="line">151 </div><div class="line">152 /**</div><div class="line">153 * Identify the event handler in the registeredHandlers and remove it.</div><div class="line">154 */</div><div class="line">155 static int removeFromRegistry(EventHandler* handler)</div><div class="line">156 &#123;</div><div class="line">157 .       /* Identify the event handler in the registeredHandlers and remove it. */</div><div class="line">158 .       int i = 0;</div><div class="line">159 .       int nodeRemoved = 0;</div><div class="line">160 </div><div class="line">161 .       for(i = 0; (i &lt; MAX_NO_OF_HANDLES) &amp;&amp; (0 == nodeRemoved); ++i) &#123;</div><div class="line">162 .       .       if(registeredHandlers[i].isUsed &amp;&amp; (registeredHandlers[i].handler.instance == handler-&gt;instance)) &#123;</div><div class="line">163 .       .       .       /* The given event handler is found -&gt; mark it as unused and terminate the loop. */</div><div class="line">164 .       .       .       registeredHandlers[i].isUsed = 0;</div><div class="line">165 .       .       .       nodeRemoved = 1;</div><div class="line">166 </div><div class="line">167 .       .       .       ne_debug(REACTOR_DEBUG, &quot;Reactor: Removed event handler with ID=%d\n&quot;, registeredHandlers[i].fd.fd);</div><div class="line">168 .       .       &#125;</div><div class="line">169 .       &#125;</div><div class="line">170 </div><div class="line">171 .       return nodeRemoved;</div><div class="line">172 &#125;</div><div class="line">173 </div><div class="line">174 /**</div><div class="line">175 * Add a copy of all registered handlers to the given array.</div><div class="line">176 */</div><div class="line">177 static size_t buildPollArray(struct pollfd* fds)</div><div class="line">178 &#123;</div><div class="line">179 .       /* Add all registered handlers to the given array. */</div><div class="line">180 .       int i = 0;</div><div class="line">181 .       size_t noOfCopiedHandles = 0;</div><div class="line">182 </div><div class="line">183 .       for(i = 0; i &lt; MAX_NO_OF_HANDLES; ++i) &#123;</div><div class="line">184 .       .       if(registeredHandlers[i].isUsed) &#123;</div><div class="line">185 .       .       .       fds[noOfCopiedHandles] = registeredHandlers[i].fd;</div><div class="line">186 .       .       .       ++noOfCopiedHandles;</div><div class="line">187 .       .       &#125;</div><div class="line">188 .       &#125;</div><div class="line">189 </div><div class="line">190 .       return noOfCopiedHandles;</div><div class="line">191 &#125;</div><div class="line">192 </div><div class="line">193 /**</div><div class="line">194 * Identify the event handler corresponding to the given descriptor in the registeredHandlers.</div><div class="line">195 */</div><div class="line">196 static EventHandler* findHandler(int fd)</div><div class="line">197 &#123;</div><div class="line">198 .       EventHandler* matchingHandler = NULL;</div><div class="line">199 </div><div class="line">200 .       /* Identify the corresponding concrete event handler in the registeredHandles. */</div><div class="line">201 .       int i = 0;</div><div class="line">202 </div><div class="line">203 .       for(i = 0; (i &lt; MAX_NO_OF_HANDLES) &amp;&amp; (NULL == matchingHandler); ++i) &#123;</div><div class="line">204 .       .       if(registeredHandlers[i].isUsed &amp;&amp; (registeredHandlers[i].fd.fd == fd)) &#123;</div><div class="line">205 .       .       .       matchingHandler = &amp;registeredHandlers[i].handler;</div><div class="line">206 .       .       &#125;</div><div class="line">207 .       &#125;</div><div class="line">208 </div><div class="line">209 .       return matchingHandler;</div><div class="line">210 &#125;</div><div class="line">211 </div><div class="line">212 /**</div><div class="line">213 * Loop through all handles. Upon detection of a handle signalled by poll(), its </div><div class="line">214 * corresponding event handler is fetched and invoked.</div><div class="line">215 */</div><div class="line">216 static void dispatchSignalledHandles(const struct pollfd* fds, size_t noOfHandles)</div><div class="line">217 &#123;</div><div class="line">218 .       size_t i = 0;</div><div class="line">219 </div><div class="line">220 .       for(i = 0; i &lt; noOfHandles; ++i) &#123;</div><div class="line">221 .       .       /* Detect all signalled handles. */</div><div class="line">222 .       .       if((POLLRDNORM | POLLERR) &amp; fds[i].revents) &#123;</div><div class="line">223 .       .       .       /* This handle is signalled -&gt; find and invoke its corresponding event handler. */</div><div class="line">224 .       .       .       EventHandler* signalledHandler = findHandler(fds[i].fd);</div><div class="line">225 </div><div class="line">226 .       .       .       if(NULL != signalledHandler)&#123;</div><div class="line">227 .       .       .       .       signalledHandler-&gt;handleEvent(signalledHandler-&gt;instance);</div><div class="line">228 .       .       .       &#125;</div><div class="line">229 .       .       &#125;</div><div class="line">230 .       &#125;</div><div class="line">231 &#125;</div><div class="line">232</div></pre></td></tr></table></figure>
<h4 id="6-5、触发Reactor"><a href="#6-5、触发Reactor" class="headerlink" title="6.5、触发Reactor"></a>6.5、触发Reactor</h4><p><a id="6.5" name="6.5"> </a>  </p>
<p>反应事件轮询是Reactor的核心，其职责在于根据具体的事件处理器控制已注册事件的分离和分发。事件循环典型由main()函数调用。  </p>
<p>驱动reactor的客户端代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">13 #include &quot;base.h&quot;</div><div class="line">14 #include &quot;DiagnosticsServer.h&quot;</div><div class="line">15 #include &quot;ReactorEventLoop.h&quot;</div><div class="line">16 </div><div class="line">17 #include &quot;Error.h&quot;</div><div class="line">18 </div><div class="line">19 void reactor_test(void)</div><div class="line">20 &#123;</div><div class="line">21 .       /* </div><div class="line">22 .        * Create a server and enter an eternal event loop, watching </div><div class="line">23 .        * the Reactor do the rest. </div><div class="line">24 .        */</div><div class="line">25 </div><div class="line">26 .       const unsigned int serverPort = 0xC001;</div><div class="line">27 .       DiagnosticsServerPtr server = createServer(serverPort);</div><div class="line">28 .       if(NULL == server) &#123;</div><div class="line">29 .       .       ne_debug(REACTOR_DEBUG, &quot;Failed to create the server\n&quot;);</div><div class="line">30 .       .       return;</div><div class="line">31 .       &#125;</div><div class="line">32 </div><div class="line">33 .       /* Enter the eternal reactive event loop. */</div><div class="line">34 .       for(;;)&#123;</div><div class="line">35 .       .       HandleEvents();</div><div class="line">36 .       &#125;</div><div class="line">37 &#125;</div></pre></td></tr></table></figure>
<p>为了整体设计，需要单独为HandleEvents()创建一个文件实现，PollReactor.c，其中每个元素都将已注册事件的句柄和用于同poll()交互的结构绑定在一起。另外一种替代方案是维护两个不同的链表以确保二者的一致性。UNIX实现采用select()，定义为“一个以UNIX I/O句柄值为索引的数组，范围为0至FD_SETSIZE-1”。  </p>
<p>在本实现中，通过将poll结构和注册组合在一起，由于采用数组用于同poll()交互，因此该数组必须在每次事件轮询进入的时刻建立。  </p>
<h4 id="6-6、处理注册"><a href="#6-6、处理注册" class="headerlink" title="6.6、处理注册"></a>6.6、处理注册</h4><p><a id="6.6" name="6.6"> </a>  </p>
<p>在本文的reactor实现中，server通过创建一个新的client来响应通知，这样一来，必须注册方可再次激活。  </p>
<p>一种解决方案是维护一个单独的数组用于同同步事件分离器进行交互, 该数组在事件循环中不能被修改。  </p>
<p>而句柄的实现则依赖平台，句柄ID有可能被重用；在拷贝中的一个信号句柄有可能属于一个未注册的事件句柄，但是由于注册重用了句柄ID，新的事件处理器可能被错误触发。我们可以加入哨兵数据以标识是否重用来解决该问题。  </p>
<h4 id="6-7、事件多样性"><a href="#6-7、事件多样性" class="headerlink" title="6.7、事件多样性"></a>6.7、事件多样性</h4><p><a id="6.7" name="6.7"> </a>  </p>
<p>实例代码仅仅考虑了一种类型的事件（read事件），其类型是hardcoded。Reactor本身并未受类型限制，能够很好的支持多种类型。  </p>
<p>两种通用的事件通知分发机制：    </p>
<ul>
<li>Single-method interface：所有的事件由单个函数通知事件处理器，函数中只需传入事件类型即可(enum)，其不足之处在于加入了额外的控制逻辑，难于维护。  </li>
<li>Multi-method interface：事件处理器为每种支持的事件声明各自的函数（比如会所handleRead, handleWrite, handleTimeout）。一旦Reactor获取已发生事件的类型，它立即触发对应的事件处理函数，这样避免了通过指针重新创建事件的额外开销。  </li>
</ul>
<h3 id="7、REACTOR-vs-OBSERVER"><a href="#7、REACTOR-vs-OBSERVER" class="headerlink" title="7、REACTOR vs OBSERVER"></a>7、REACTOR vs OBSERVER</h3><p><a id="vs" name="vs"> </a>  </p>
<p>尽管用于实现二者的机制相关，但是仍存在差异，主要的不同点在于通知机制。在OBSERVER实现中，当一个Subject改变其状态时，它的所有依赖者（observers)都被通知。而在REACTOR实现中，通知的关系式一对一，即一个已探测到的事件导致Reactor通知其对应的实例（EventHandler）。  </p>
<p>另外，一个典型的OBSERVER模式下的subject是低内聚的，除了服务其核心目的，一个subject也会负责管理和通知observers。相反，一个Reactor则仅仅分发已经注册的处理器。</p>
<h3 id="8、结论"><a href="#8、结论" class="headerlink" title="8、结论"></a>8、结论</h3><p><a id="cons" name="cons"> </a>  </p>
<p>应用REACTOR模式的主要结论如下：  </p>
<ul>
<li>遵循single-responsibility原则的好处：采用REACTOR模式，每种责任被封装并相互之间解耦，导致高内聚，因此简化了后续维护。比如在事件探测中平台相关的代码可以从应用中解耦，极大的方便了单元测试。  </li>
<li>遵循open-closed原则的好处：新的责任只需创建新的事件处理器，无需影响现有代码。  </li>
<li>统一了事件处理：尽管REACTOR模式集中于句柄，但其可以扩展至其他任务。Reactor加入timer支持（平台相关，比如基于信号或者线程），当同步事件分离器触发后可以设定一个超时，以避免重入问题和竞争条件。  </li>
<li>提供了一种并行读的方案：采用REACTOR方案可以有效避免并行读事件处理中的阻塞现象，其本质是一个非抢占式的多任务模型，每个具体的事件处理器必须确保其不能执行可能导致其余事件处理器饥饿的操作。  </li>
<li>类型安全的折中：由于所有的事件处理器抽象为void *，当由void指针转化为具体的事件处理指针时，编译器并没有相应的机制处理转化错误。同样的问题在OBSERVER模式中也存在，解决方法都是一致的：为不同类型的事件处理器定义单独的通知函数，利用EventHandler绑定事件处理器和其他函数。  </li>
</ul>
<h3 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h3><p><a id="sum" name="sum"> </a>  </p>
<p>Reactor模式通过对不同责任的解耦和不同模块的封装简化了事件驱动型应用的设计。关于该模式更多的讨论可以参考面向对象的软件模式卷2。      </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文由&lt;a href=&quot;http://skypacer210.github.io/&quot;&gt;skypacer&lt;/a&gt;译自&lt;a href=&quot;http://www.adampetersen.se/Patterns%20in%20C%205,%20REACTOR.pdf&quot; target
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="design pattern" scheme="https://skypacer210.github.io/tags/design-pattern/"/>
    
      <category term="reactor" scheme="https://skypacer210.github.io/tags/reactor/"/>
    
  </entry>
  
  <entry>
    <title>基于ARM平台的AES硬件加速实现</title>
    <link href="https://skypacer210.github.io/2013/12/22/aes-acceleration-in-arm/"/>
    <id>https://skypacer210.github.io/2013/12/22/aes-acceleration-in-arm/</id>
    <published>2013-12-21T16:00:00.000Z</published>
    <updated>2017-08-09T13:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="硬件加密引擎特点"><a href="#硬件加密引擎特点" class="headerlink" title="硬件加密引擎特点"></a>硬件加密引擎特点</h2><p>硬件加速引擎的目的在于减少加解密中软件的干预，从而提高性能.该硬件加密引擎共有四个引擎，每次运行一个，支持的加密算法有：  </p>
<ul>
<li>DES(Only ECB and CBC modes) </li>
<li>3DES(ECB/CBC EDE and EEE modes)</li>
<li>AES(128/192/256):  其中AES-CBC支持IV feedback，即加密完之后密文的最后16个字节拷贝至引擎的内部SRAM中的IV位置</li>
</ul>
<p>对AES而言，首先将报文、配置信息以及密钥和初始化向量放入一连串的TDMA描述符当中，并配置chain模式，最后启动TDMA，即可连续加密。  IV是由用户配置的，后续的IV由硬件自己填充，CTR模式可以通过软件实现。<br>中断发生，会将对于位置位，通知软件取数。</p>
<p>支持的验证算法为SHA或者MD5。</p>
<p>在硬件加速实现中，CPU和加速引擎精密协作但具体分工又不尽相同。  </p>
<p>对CPU而言，主要完成三件事：</p>
<ul>
<li>直接拷贝报文至加速器的本地SRAM中（没有采用DMA的情况下）；  </li>
<li>准备一个描述符，声明所需要的操作，目前描述符在主存中分配和配置<code>struct sa_accel_sram</code>，并映射至硬件当中对应的镜像位置（偏移为<code>SRAM_CONFIG</code>, <code>SRAM_KEY</code>, <code>SRAM_DATA_IN</code>等）。</li>
<li>通过Sheeva CPU core，激活加速器。    </li>
</ul>
<p>而加速引擎的职责包括计算、与CPU交互和数据搬运，具体来说，包括CESA和TDMA两个子引擎，其中CESA负责对数据进行操作，主要流程如下：    </p>
<ul>
<li>读取描述符  </li>
<li>启动引擎 </li>
<li>开始处理报文块，一次一个</li>
<li>等待完成</li>
<li>从引擎读取数据</li>
<li>存储数据值本地SRAM    </li>
</ul>
<p>而TDMA只是负责在主存和SRAM之间拷贝数据。</p>
<h2 id="CESA配置流程"><a href="#CESA配置流程" class="headerlink" title="CESA配置流程"></a>CESA配置流程</h2><h3 id="引入加密引擎"><a href="#引入加密引擎" class="headerlink" title="引入加密引擎"></a>引入加密引擎</h3><p><strong>Access</strong></p>
<p>CPU和SEAS交替控制，但在一个时间点上只能有一个作为HOST，TDMA当中有owner位，指示出当前的HOST是TDMA设备还是CPU。  </p>
<p><strong>Control</strong></p>
<p>若干特殊的命令控制器，比如SHA-1/MD5相关的命令寄存器：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define SHA1_MD5_CTRL_REG 0x0003DD18 /	\*Set when hash complete; Clear when any write to the auth engines\*/   </div><div class="line">#define SHA1_MD5_TERM_MASK 0x1 &lt;&lt; 31) /	\*bit31\*/</div></pre></td></tr></table></figure>
<p><strong>输入</strong>  </p>
<ul>
<li>输入数据长度为64bit或者128bit</li>
<li>输入带验证数据长度为512bit </li>
<li>写数据寄存器，加载输入数据(只有DES支持多任务)</li>
<li>写密钥寄存器和IV寄存器</li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li>加密引擎返回数据长度也为64bit或者128bit</li>
<li>验证引擎返回相应的签名长度.</li>
<li>通过指定的数据寄存器访问输出数据  </li>
</ul>
<p><strong>操作原则</strong></p>
<ul>
<li>写入加密参数</li>
<li>写入数据，激活引擎</li>
<li>在指定的命令寄存器上设置终止位</li>
<li>使能中断通知CPU操作完毕</li>
<li>CPU从寄存器读取结果  </li>
</ul>
<h3 id="88AP510安全加密引擎"><a href="#88AP510安全加密引擎" class="headerlink" title="88AP510安全加密引擎"></a>88AP510安全加密引擎</h3><p><strong>地址映射</strong>   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">\* phys virt size       </div><div class="line">\* c8000000 fdb00000 1M Cryptographic SRAM     </div><div class="line">\* e0000000 @runtime 128M PCIe-0 Memory space </div><div class="line">\* e8000000 @runtime 128M PCIe-1 Memory space </div><div class="line">\* f1000000 fde00000 8M on-chip south-bridge registers </div><div class="line">\* f1800000 fe600000 8M on-chip north-bridge registers </div><div class="line">\* f2000000 fee00000 1M PCIe-0 I/O space </div><div class="line">\* f2100000 fef00000 1M PCIe-1 I/O space</div><div class="line"></div><div class="line">#define DOVE_CRYPT_PHYS_BASE. . (DOVE_SB_REGS_PHYS_BASE | 0x30000) /	\* Cryptographic Engine \*/</div></pre></td></tr></table></figure>
<p><strong>寄存器配置</strong></p>
<p>实例： 修改DOVE寄存器   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">575 . /* enable isolators */ </div><div class="line">576 . reg = MV_REG_READ(PMU_ISO_CTRL_REG); </div><div class="line">577 . reg &amp;= ~PMU_ISO_VIDEO_MASK; </div><div class="line">578 . MV_REG_WRITE(PMU_ISO_CTRL_REG, reg);</div></pre></td></tr></table></figure>
<p><strong>加密流程</strong></p>
<ul>
<li>检查 <code>aes_term</code> 是否为1，类似轮询操作；</li>
<li>配置 <code>AES_CTRL_REG</code>: 密钥长度和数据大小字节序；</li>
<li>写入密钥寄存器，总共8个，如果key不变，则无需配置；     </li>
<li>每次写入128bit的数据块: 配置AES ENC Data In/out register； 当这些寄存器填写完毕（填写顺序无所谓），加密开始；如果小于128，自动补0。   </li>
<li>轮询AES命令寄存器或者等待中断：在轮询模式下如果为1，说明结果已经准备好； 在中断模式下每次中断发生，结束位从0变为1，当中断发生后，主机向中断使能寄存器的Zint2写入0以重启它，写入1则无影响。  </li>
<li>获取AES结果：结果同样位于AES IO寄存器当中；引擎不会对字节序做任何修改。</li>
</ul>
<p><strong>解密流程</strong></p>
<p>当加密操作完成时，key发生了变化，必须根据最后的加密key生成key schedule；具体如下：  </p>
<ul>
<li>当用一个指定的key解密数据时候，主机首先加载key至解密引擎，然后设置AES解密命令寄存器为1，产生key schedule。</li>
<li>当从解密引擎中读取一个key的时候，主机必须等待AES命令寄存器的key schedule位为1，方可读取key寄存器。  </li>
</ul>
<p>其中解密密钥生成步骤：  </p>
<ol>
<li>写入AES解密key n 寄存器；</li>
<li>设置解密控制寄存器的aesDecMakekey位为1；</li>
<li>轮询直到该位设置为1；</li>
<li>从对应的解密key寄存器中读取key；</li>
<li>清空AES解密控制寄存器。</li>
</ol>
<p>主机可能会在内存中保存解密key，这样key计算可以在下次忽略（采用相同的key）:  </p>
<ol>
<li>轮询解密寄存器的终止位（类似加密过程）；  </li>
<li>为解密寄存器设置解密模式和大小端；  </li>
<li>写入生成的key；  </li>
<li>写入解密数据；   </li>
<li>轮询解密寄存器或者是等待中断发生；  </li>
<li>读取AES结果；  </li>
<li>读取key(主机必须加载一个raw key)。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><p>启用CESA，本质上是数据在DRAM和SRAM之间的拷贝，如果采用DMA，需要将DRAM和SRAM中数据的虚拟地址转化为对应的物理地址。<br>由于CESA只能处理在CESA SRAM中的报文，最大支持2KB，因此在包含其他信息的前提下（SA描述符、key、IV），实际处理的数据最大是1.75KB。  </p>
<ul>
<li>对于每个报文，至少需要1个SA描述符和4个TDMA描述符，如果数据在物理内存中有分片，则会需要更多的TDMA描述符。</li>
<li>驱动利用预定义的SA和TDMA描述符池以期获得最好的性能，池的大小可以匹配请求的size大小。  </li>
</ul>
<h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><p><strong>应用请求分发方式</strong></p>
<p>对于来自上层的应用请求（AES加解密）可以采用以下两种同步回调模式和异步回调模式。  </p>
<p>对于同步回调模式而言，同步操作较为简单，但是当请求被提交时程序会阻塞；调用同步回调函数（实现数据由软件传至硬件）即可，一旦硬件处理完毕，即可返回，流程如下：</p>
<ol>
<li>准备硬件请求；</li>
<li>发送至硬件，等待完成；</li>
<li>如果请求成功完成，用处理后的数据代替原先的数据；</li>
<li>如果该数据需要验证，需要在MAC缓冲区存储一份MAC值。</li>
</ol>
<p>而在异步回调模式下，异步请求会被加入硬件队列，同时返回，当硬件完成请求时，硬件调用另外一个处理程序返回，并送入上层协议栈，通常情况下效率更高，除了同步回调函数，必须注册另外一个回调函数（通知回调函数）以方便硬件完成操作之后调用，该回调通知函数在上层实现，主要将结果传至上层协议栈。  </p>
<ol>
<li>准备硬件请求，包括所有数据和参数，实现通知回调函数；</li>
<li>根据返回值操作，如果正确则用处理后的数据替换原始数据；获取MAC值；清空本地内存。</li>
<li>如果失败则释放内存；</li>
<li>如果有必要，准备一个包含原始数据的指针；</li>
<li>发生请求值硬件；</li>
<li>返回状态代码；</li>
<li>当硬件完成操作后，调用通知回调函数</li>
</ol>
<p>目前采用的是同步方式。</p>
<p><strong>中间层</strong></p>
<p>在硬件接口和上层接口层之间加入一个中间层，以此隔离上层对于底层调用的依赖，可以基于纯软件实现AES加解密，也可以基于硬件实现。  </p>
<p><strong>流程控制</strong>  </p>
<p>采用中断方式接收数据并进行处理。中断是硬件处理数据之后的动作，因此，触发中断需要有两级：  </p>
<ul>
<li>使能中断，此时可以写对应中断掩码  </li>
<li>写入数据，此时开始硬件处理  </li>
</ul>
<p>具体的流程如下：   </p>
<ul>
<li>建立一个进程专门处理中断，通过读取中断寄存器判断是否有中断，如果中断上来就处理收发。  </li>
<li>设置中断寄存器；  </li>
<li>本地中断寄存器和掩码寄存器，就包括了CESA单元的，可以在pic.c中为CESA定义中断向量。     </li>
</ul>
<p><strong>DMA</strong></p>
<p>在该平台的硬件引擎中，专门实现了DMA，称之为TDMA。TDMA的基本特点如下：</p>
<ul>
<li>独立的TDMA引擎，无需CPU参与可以在DDR内存和内部SRAM之间搬移大规模数据, 通过TDMA从主存中拷贝报文至安全加速引擎的本地SRAM，最大支持2KB。</li>
<li>一次最大支持2KB，可以运行于chain mode，该模式下为每个缓冲区分配一个唯一的描述符。</li>
<li>一旦TDMA激活，禁止任何软件读访问本地SRAM；</li>
<li>保存与安全加速引擎相关的加密参数值，保存在主存当中，但是必须映射至引擎的SRAM当中；  </li>
<li>在安全加速器的SRAM中准备描述符，开始加速引擎需要的操作和参数。</li>
</ul>
<p>TDMA最主要的寄存器是TMDA描述符，由四个32位寄存器组成：  </p>
<ul>
<li>Byte Count(0x800): 传输的数据字节数，最大支持64KB-1,随着数据从源地址向目的地址的拷贝递减，为0时，意味着TDMA传输完成或者终止;Own位表示CPU或者TMDA拥有该描述符;  </li>
<li>Source Address(0x810)：TDMA源地址 必须为内部SRAM地址 可以直接将内部SRAM的固定偏移地址写入;</li>
<li>Destination Address(0x820)：TDMA目的地址 必须为内部SRAM地址 提供了一种思路，遇到需要配置硬件地址的时候，可以定义一个固定偏移，这样软硬件填写方便;</li>
<li>下一个描述符指针(0x830)：为了支持chain模式，必须是16字节对齐（bit[3:0]=0）。</li>
</ul>
<p><strong>TDMA与加密引擎协调工作</strong></p>
<p>TDMA作为一种硬件内置的DMA方式，与其他硬件加速引擎配合工作，较为显著的提高了吞吐率，基本流程如下：  </p>
<p>首先设置CESA配置寄存器（0xE08）的waitforTDMA和ActiveTDMA，当TMDA和CESA协同工作的时候，CESA能独立操作DRAM，CESA有能力激活TDMA，决定其状态并提供单独的完成中断；其中软件则需要步骤（五步）：  </p>
<ul>
<li>在DRAM中配置TDMA描述符chain；</li>
<li>初始化TDMA配置寄存器；</li>
<li>在DRAM中或者SRAM中初始化CESA描述符和参数；</li>
<li>初始化CESA配置寄存器；</li>
<li>软件激活硬件加速。</li>
</ul>
<p>TDMA的基本功能和软件流程综述如下：  </p>
<ul>
<li>利用TDMA从主存DRAM中拷贝报文至CESA的本地SRAM中，对于大的报文，可以进行分片。</li>
<li>存储CESA所需的加密参数；</li>
<li>为CESA的本地SRAM准备一个描述符（MV_CESA_DESC），设定需要的操作和参数，描述符总共8个双字长；</li>
<li>通过配置CESA描述符指针寄存器（0xE04），将SRAM中MV_CESA_DESC数据域地址写入选定的session中（通过计算偏移得到）；</li>
<li>通过配置命令寄存器（0xE00）合适的位激活该session；</li>
<li>等待硬件完成，在轮询模式或者中断模式下的判断标志为寄存器（0xE0C）第0位，若为1则说明已经actived；</li>
<li>利用TDMA将完成的报文拷贝回主存。</li>
</ul>
<p>其中CESA中的SRAM内存映射如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/\*   </div><div class="line"> \* CESA SRAM Memory Map: \*  </div><div class="line"> \* +------------------------+ &lt;= sc-&gt;sc_sram_base + CESA_SRAM_SIZE   </div><div class="line"> \* |                        |   </div><div class="line"> \* |          DATA          |   </div><div class="line"> \* |                        |   </div><div class="line"> \* +------------------------+ &lt;= sc-&gt;sc_sram_base + CESA_DATA(0)    </div><div class="line"> \* | struct cesa_sa_data    |   </div><div class="line"> \* +------------------------+   </div><div class="line"> \* | struct cesa_sa_hdesc |  </div><div class="line"> \* +------------------------+ &lt;= sc-&gt;sc_sram_base   </div><div class="line"> */</div></pre></td></tr></table></figure>
<p>其中<code>CESA_SRAM_SIZE=2048</code>， <code>CESA_DATA(0)=sizeof（struct cesa_sa_hdesc）</code>，字节序则利用宏直接转化。  </p>
<p>对于分片报文，可以暂时不支持，以简化设计 CESA 的SDK支持最大报文为64 * 1024，而一次处理1600大小，因此需要分片。</p>
<p>SRAM地址可以直接返回一个全局变量：<code>MV_U32 cesaCryptEngBase = 0</code>;</p>
<p>对于SA配置，可以定义数据结构<code>sa_config</code>和相应的配置函数。</p>
<h3 id="调试小记"><a href="#调试小记" class="headerlink" title="调试小记"></a>调试小记</h3><h3 id="调试基本原则"><a href="#调试基本原则" class="headerlink" title="调试基本原则"></a>调试基本原则</h3><p>在开发前期，为了尽快试错以及避免代码注释混乱，采用switch语句定义不同的dec_key方法，并用全局变量用GUI配置，则无需重新编译即可完成正确方案的选择。而在面对时而正确时而错误的加解密情况，加入打印语句：  </p>
<ul>
<li>首先排除硬件返回超时的错误；</li>
<li>排除CESA SRAM没有初始化的错误；</li>
<li>排除状态机的锁处理问题；</li>
<li>定位至状态机的处理，很可能在处理开始之前没有正确赋给初值。</li>
</ul>
<p>基于以上分析思路，解决了数据乱码问题，定位过程如下：  </p>
<p><strong>数据拷贝流程分析</strong>  </p>
<p>分解TDMA和CESA的交互过程，逐步调试，至比如数据从主存至TDMA，是否拷贝正确； 数据处理完之后是否拷贝至主存?</p>
<ul>
<li>从cache到主存；</li>
<li>DMA读：从主存至设备；</li>
<li>DMA写： 从设备至主存；</li>
<li>主存至cache。  </li>
</ul>
<p><strong>Cache相关</strong>   </p>
<p>这里涉及两个问题：clean cache和Invalide cache:  </p>
<ul>
<li>clean cache意味着将cache中的数据强制写入主存, 即设备访问到了最新的内容，保证了设备访问CPU的数据正确性。    </li>
<li>invalide cache用来确保设备完成时，CPU可以从主存中读取到最新的内容，即保证了CPU访问设备的数据正确性。</li>
</ul>
<p><strong>DMA相关</strong>  </p>
<p>DMA要考虑页表连续性和CPU-cache。  </p>
<p>现象：  </p>
<ul>
<li>有错包出现，且大小无规律；</li>
<li>现象二：memory trap，无规律。  </li>
</ul>
<p>采用软件对比方法，对比几个方面，包括DMA-out/HW caculate,分析出错误点。硬件计算错误的原因（配置错误、密钥IV错误、源目的地址错误），排除了前二者，只能是传入了错误的物理地址给硬件。在进行虚实地址转化的时候，由于转化后的物理地址可能跨页，因此必须分页拷贝，即计算出距离页边界的偏移，判断是否跨页，如果跨了先拷贝当前页数据，在拷贝下一页数据。其中DMA和CPU-cache是两个不同的两个概念：  </p>
<ul>
<li>DMA指的是一种硬件设备，能够无须使用CPU指令实现对内存的拷贝；后者是主存和CPU之间的关系；</li>
<li>DMA在进行数据拷贝的时候，或许用到CPU-cache的参与，或许根本就不用。</li>
</ul>
<p><strong>随机问题定位</strong></p>
<p>在实际的调试中在单个进程中调用时没有问题，在多个进程调用的时候出现问题，因此可以确定可能是进程并发的问题。经过调试发现，中断会在休眠之前发生，因此在需要禁止中断。    </p>
<p>另外一个随机问题是在释放版本中发现的，硬件加速引擎偶尔出现超时，但是在开发版本中从不会超时，控制结构体中的一个描述状态的字段不太正常，后者相对前者做了编译优化，导致发生不可预期的错误，因此需要在其定义出加入volitile关键字，问题得以解决。  </p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="http://igoro.com/archive/gallery-of-processor-cache-effects/" title="http://igoro.com/archive/gallery-of-processor-cache-effects/" target="_blank" rel="external">Gallery of Processor Cache Effects</a></li>
<li><a href="http://stackoverflow.com/questions/1855896/memory-alignment-on-modern-processors" title="http://stackoverflow.com/questions/1855896/memory-alignment-on-modern-processors" target="_blank" rel="external">Memory alignment on modern processors?</a></li>
<li><a href="http://stackoverflow.com/questions/4605030/will-the-cache-line-aligned-memory-allocation-pay-off" title="http://stackoverflow.com/questions/4605030/will-the-cache-line-aligned-memory-allocation-pay-off" target="_blank" rel="external">Will the cache line aligned memory allocation pay off?</a></li>
<li><a href="http://stackoverflow.com/questions/9809140/how-correctly-wake-up-process-inside-interrupt-handlers" title="http://stackoverflow.com/questions/9809140/how-correctly-wake-up-process-inside-interrupt-handlers" target="_blank" rel="external">How correctly wake up process inside interrupt handlers</a></li>
<li><a href="http://stackoverflow.com/questions/11012406/race-condition-between-wait-event-and-wake-up?rq=1" title="http://stackoverflow.com/questions/11012406/race-condition-between-wait-event-and-wake-up?rq=1" target="_blank" rel="external">race condition between wait_event and wake_up</a></li>
<li><a href="http://stackoverflow.com/questions/6570419/linux-kernel-interrupt-handler-mutex-protection?rq=1" title="http://stackoverflow.com/questions/6570419/linux-kernel-interrupt-handler-mutex-protection?rq=1" target="_blank" rel="external">Linux kernel interrupt handler mutex protection?</a></li>
<li><a href="http://www.noise.physx.u-szeged.hu/DigitalMeasurements/DSP/Sharc/Sharc/chap06.pdf" title="http://www.noise.physx.u-szeged.hu/DigitalMeasurements/DSP/Sharc/Sharc/chap06.pdf" target="_blank" rel="external">DSP DMA</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;硬件加密引擎特点&quot;&gt;&lt;a href=&quot;#硬件加密引擎特点&quot; class=&quot;headerlink&quot; title=&quot;硬件加密引擎特点&quot;&gt;&lt;/a&gt;硬件加密引擎特点&lt;/h2&gt;&lt;p&gt;硬件加速引擎的目的在于减少加解密中软件的干预，从而提高性能.该硬件加密引擎共有四个
    
    </summary>
    
      <category term="technology" scheme="https://skypacer210.github.io/categories/technology/"/>
    
    
      <category term="ARM" scheme="https://skypacer210.github.io/tags/ARM/"/>
    
      <category term="AES" scheme="https://skypacer210.github.io/tags/AES/"/>
    
      <category term="Acceleration" scheme="https://skypacer210.github.io/tags/Acceleration/"/>
    
  </entry>
  
</feed>
