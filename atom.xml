<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>skypacer的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-06T11:25:43.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>skypacer210</name>
    <email>yangyongbupt168@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cloud Application设计模式之Event Sourcing Pattern</title>
    <link href="http://yoursite.com/2014/12/31/event-sourcing-pattern/"/>
    <id>http://yoursite.com/2014/12/31/event-sourcing-pattern/</id>
    <published>2014-12-30T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对Event Sourcing Pattern的设计细节做一个粗略介绍~  </p>
<p>原文链接<a href="http://msdn.microsoft.com/en-us/library/dn589792.aspx/" target="_blank" rel="external">Event Sourcing Pattern</a>  </p>
<hr>
<h2 id="1、问题提出："><a href="#1、问题提出：" class="headerlink" title="1、问题提出："></a>1、问题提出：</h2><p>大多数的应用处理数据，典型的操作就是通过更新用户的数据维护当前的状态。比如CRUD数据操作模式，即创建、读、更新和删除数据，一般的做法是从数据仓库读取数据，对数据进行修改，然后用最新的值更新数据状态，上述操作往往通过锁实现。<br>CURD方式的不足之处：  </p>
<ul>
<li>CRUD系统直接对数据仓库进行更新操作会导致性能降低、而且不利于系统扩展。  </li>
<li>在一个协作系统里面，多个并发用户在进行数据更新的时候会发生冲突  </li>
<li>从审计的角度考虑，每个操作记录在单独的日志中，丢失了历史信息。  </li>
</ul>
<h2 id="2、解决思路："><a href="#2、解决思路：" class="headerlink" title="2、解决思路："></a>2、解决思路：</h2><p>事件源模式（event souring pattern）定义了一种对序列化事件驱动数据的操作方法，每个事件都是以累加方式（append-only）进行存储。APP代码发送一系列事件至数据存储，以命令式方式描述每一个动作。同时，数据一致性在数据存储中完成。每个事件代表了对数据的一个属性的改变。<br>完成一致性处理的事件存储在event store，作为数据当前状态的信任源或系统记录（或者称之为已授权数据源中的给定元素或信息片段）。典型地，Event store发布这些事件，这样能够通知到消费者并做相应的处理。作为消费者也可以对其他系统应用执行事件群的动作，或者是完成该操作所需的关联动作。我们可以看到用于产生事件的APP代码与注册了事件的系统之前是解耦的。<br>通过Event store发布事件的一个典型应用就是当APP改变目录行为后对物化视图的维护，并且能够与外部系统集成。比如一个显示了所有客户订单的物化视图，用于产生UI的部分组件。当APP添加或者删除订单时，描述上述行为的事件能够被处理，以更新物化视图。    </p>
<p><img src="/assets/images/Event_Sourcing_Pattern_1.jpg" alt="图片"></p>
<p>The Event Sourcing pattern provides many advantages, including the following:  </p>
<ul>
<li>Events are immutable and so can be stored using an append-only operation. The user interface, workflow, or process that initiated the action that produced the events can continue, and the tasks that handle the events can run in the background. This, combined with the fact that there is no contention during the execution of transactions, can vastly improve performance and scalability for applications, especially for the presentation level or user interface.</li>
<li>Events are simple objects that describe some action that occurred, together with any associated data required to describe the action represented by the event. Events do not directly update a data store; they are simply recorded for handling at the appropriate time. These factors can simplify implementation and management.</li>
<li>Events typically have meaning for a domain expert, whereas the complexity of the object-relational impedance mismatch might mean that a database table may not be clearly understood by the domain expert. Tables are artificial constructs that represent the current state of the system, not the events that occurred.</li>
<li>Event sourcing can help to prevent concurrent updates from causing conflicts because it avoids the requirement to directly update objects in the data store. However, the domain model must still be designed to protect itself from requests that might result in an inconsistent state.</li>
<li>The append-only storage of events provides an audit trail that can be used to monitor actions taken against a data store, regenerate the current state as materialized views or projections by replaying the events at any time, and assist in testing and debugging the system. In addition, the requirement to use compensating events to cancel changes provides a history of changes that were reversed, which would not be the case if the model simply stored the current state. The list of events can also be used to analyze application performance and detect user behavior trends, or to obtain other useful business information.</li>
<li>The decoupling of the events from any tasks that perform operations in response to each event raised by the event store provides flexibility and extensibility. For example, the tasks that handle events raised by the event store are aware only of the nature of the event and the data it contains. The way that the task is executed is decoupled from the operation that triggered the event. In addition, multiple tasks can handle each event. This may enable easy integration with other services and systems that need only listen for new events raised by the event store. However, the event sourcing events tend to be very low level, and it may be necessary to generate specific integration events instead.</li>
</ul>
<h2 id="2、适用场景"><a href="#2、适用场景" class="headerlink" title="2、适用场景"></a>2、适用场景</h2><p><img src="/assets/images/Event_Sourcing_Pattern_2.jpg" alt="图片"></p>
<h2 id="3、应用实例"><a href="#3、应用实例" class="headerlink" title="3、应用实例"></a>3、应用实例</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对Event Sourcing Pattern的设计细节做一个粗略介绍~  &lt;/p&gt;
&lt;p&gt;原文链接&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dn589792.aspx/&quot; target=&quot;_blank&quot; rel
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="Cloud Design Patterns" scheme="http://yoursite.com/tags/Cloud-Design-Patterns/"/>
    
      <category term="Event-Driven" scheme="http://yoursite.com/tags/Event-Driven/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu上安装NS-3实践</title>
    <link href="http://yoursite.com/2014/12/26/building-ns-3-on-ubuntu/"/>
    <id>http://yoursite.com/2014/12/26/building-ns-3-on-ubuntu/</id>
    <published>2014-12-25T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>##1 概述 ##  </p>
<p>本文记录了NS-3模拟器在Ubuntu12.04桌面版上的完整安装记录。  </p>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h2><p>NS-3的安装方法有两种，一种是利用bake工具自动化安装，另一种是手动安装，安装包的下载可以通过Mercurial或则是直接下载tar包。<br>由于Bake工具安装陷入超时，因此直接采用基于Mercurial的手动安装。</p>
<h3 id="2-1-依赖软件包安装"><a href="#2-1-依赖软件包安装" class="headerlink" title="2.1 依赖软件包安装"></a>2.1 依赖软件包安装</h3><p>Bake本身提供依赖包检测，这里直接将所需包安装成功。  </p>
<pre><code>
apt-get install mercurial
apt-get install qt4-dev-tools
apt-get install gdb valgrind
apt-get install gsl-bin libgsl0-dev libgsl0ldbl
apt-get install flex bison libfl-dev
apt-get install tcpdump
apt-get install sqlite sqlite3 libsqlite3-dev
apt-get install libxml2 libxml2-dev
apt-get install libgtk2.0-0 libgtk2.0-dev
apt-get install vtun lxc
apt-get install uncrustify
apt-get install doxygen graphviz imagemagick
apt-get install python-sphinx dia
apt-get install python-pygraphviz python-kiwi python-pygoocanvas libgoocanvas-dev
apt-get install libboost-signals-dev libboost-filesystem-dev
apt-get install openmpi-bin openmpi-common openmpi-doc libopenmpi-dev
</code></pre>


<h4 id="2-2-建立工作目录"><a href="#2-2-建立工作目录" class="headerlink" title="2.2 建立工作目录"></a>2.2 建立工作目录</h4><pre><code>
mkdir workspace
cd workspace
mkdir repos
cd repos
hg clone http://code.nsnam.org/ns-3-allinone
</code></pre>

<p>过程：</p>
<pre><code>
requesting all changes
adding changesets
adding manifests
adding file changes
</code></pre>

<p>最终生成ns-3-allinone目录。</p>
<h3 id="2-3-利用Mercurial下载ns-3-dev"><a href="#2-3-利用Mercurial下载ns-3-dev" class="headerlink" title="2.3 利用Mercurial下载ns-3-dev"></a>2.3 利用Mercurial下载ns-3-dev</h3><pre><code>
./download.py -n ns-3-dev
</code></pre>

<p>下载过程：  </p>
<pre><code>
    #
    # Get NS-3
    #

Cloning ns-3 branch
 =>  hg clone http://code.nsnam.org/ns-3-dev ns-3-dev
requesting all changes
adding changesets
adding manifests
adding file changes
...
added 11117 changesets with 52385 changes to 7390 files
updating to branch default
2998 files updated, 0 files merged, 0 files removed, 0 files unresolved

    #
    # Get PyBindGen
    #

Required pybindgen version:  0.17.0.886
Trying to fetch pybindgen; this will fail if no network connection is available.  Hit Ctrl-C to skip.
 =>  bzr checkout -rrevno:886 https://launchpad.net/pybindgen pybindgen
Fetch was successful.                                                                                         

    #
    # Get NetAnim
    #

Required NetAnim version:  netanim-3.105
Retrieving NetAnim from http://code.nsnam.org/netanim
 =>  hg clone http://code.nsnam.org/netanim netanim
requesting all changes
adding changesets
adding manifests
adding file changes
added 275 changesets with 1533 changes to 228 files
updating to branch default
196 files updated, 0 files merged, 0 files removed, 0 files unresolved

    #
    # Get bake
    #

Retrieving bake from http://code.nsnam.org/bake
 =>  hg clone http://code.nsnam.org/bake
destination directory: bake
requesting all changes
adding changesets
adding manifests
adding file changes
added 333 changesets with 790 changes to 63 files
updating to branch default
45 files updated, 0 files merged, 0 files removed, 0 files unresol
</code></pre>

<h3 id="2-4-编译"><a href="#2-4-编译" class="headerlink" title="2.4 编译"></a>2.4 编译</h3><p>NS-3的编译借助build.py脚本工具。</p>
<pre><code>
./build.py
</code></pre>

<p>但是会碰到如下错误：  </p>
<pre><code>
[1459/1770] cxx: src/lte/model/lte-ffr-sap.cc -> build/src/lte/model/lte-ffr-sap.cc.1.o
[1460/1770] cxx: src/lte/model/lte-fr-no-op-algorithm.cc -> build/src/lte/model/lte-fr-no-op-algorithm.cc.1.o
[1461/1770] cxx: src/lte/model/lte-ffr-soft-algorithm.cc -> build/src/lte/model/lte-ffr-soft-algorithm.cc.1.o
[1462/1770] cxx: src/lte/model/lte-ue-power-control.cc -> build/src/lte/model/lte-ue-power-control.cc.1.o
[1463/1770] cxx: build/src/lte/bindings/ns3module.cc -> build/src/lte/bindings/ns3module.cc.7.o
g++: internal compiler error: Killed (program cc1plus)
Please submit a full bug report,
with preprocessed source if appropriate.
See <file: usr="" share="" doc="" gcc-4.6="" readme.bugs=""> for instructions.
Waf: Leaving directory `/home/fyang/project/workspace/repos/ns-3-allinone/ns-3-dev/build'
Build failed
 -> task in 'ns3module_lte' failed (exit status 4): 
    {task 159048492: cxx ns3module.cc -> ns3module.cc.7.o}
['/usr/bin/g++', '-O0', '-ggdb', '-g3', '-Wall', '-Werror', '-Wno-error=deprecated-declarations', '-fstrict-alid', '-fno-strict-aliasing', '-fwrapv', '-fstack-protector', '-fno-strict-aliasing', '-fvisibility=hidden', '-Wn, '-I..', '-Isrc/lte/bindings', '-I../src/lte/bindings', '-I/usr/include/python2.7', '-I/usr/include/gtk-2.0', -I/usr/include/atk-1.0', '-I/usr/include/cairo', '-I/usr/include/gdk-pixbuf-2.0', '-I/usr/include/pango-1.0', 'glib-2.0', '-I/usr/lib/i386-linux-gnu/glib-2.0/include', '-I/usr/include/pixman-1', '-I/usr/include/freetype2',bxml2', '-DNS3_ASSERT_ENABLE', '-DNS3_LOG_ENABLE', '-DHAVE_SYS_IOCTL_H=1', '-DHAVE_IF_NETS_H=1', '-DHAVE_NET_ETTE3=1', '-DHAVE_IF_TUN_H=1', '-DHAVE_GSL=1', '-DNS_DEPRECATED=', '-DNS3_DEPRECATED_H', '-DNDEBUG', 'src/lte/binings/ns3module.cc.7.o']
Traceback (most recent call last):
  File "./build.py", line 170, in <module>
    sys.exit(main(sys.argv))
  File "./build.py", line 161, in main
    build_ns3(config, build_examples, build_tests, args, build_options)
  File "./build.py", line 81, in build_ns3
    run_command([sys.executable, "waf", "build"] + build_options)
  File "/home/fyang/project/workspace/repos/ns-3-allinone/util.py", line 24, in run_command
    raise CommandError("Command %r exited with code %i" % (argv, retval))
util.CommandError: Command ['/usr/bin/python', 'waf', 'build'] exited with code 1
</module></file:></code></pre>

<p>似乎是g++编译器自身的问题，解决办法是利用swap:  </p>
<pre><code>
sudo dd if=/dev/zero of=/swapfile bs=64M count=16
sudo mkswap /swapfile
sudo swapon /swapfile
</code></pre>

<p>编译完成后删除：  </p>
<pre><code>
sudo swapoff /swapfile
sudo rm /swapfile
</code></pre>

<p>如果成功，则显示：  </p>
<pre><code>
Waf: Leaving directory `/home/fyang/project/workspace/repos/ns-3-allinone/ns-3-dev/build'
'build' finished successfully (7m31.696s)
Modules built:
antenna                   aodv                      applications             
bridge                    buildings                 config-store             
core                      csma                      csma-layout              
dsdv                      dsr                       energy                   
fd-net-device             flow-monitor              internet                 
lr-wpan                   lte                       mesh                     
mobility                  mpi                       netanim (no Python)      
network                   nix-vector-routing        olsr                     
point-to-point            point-to-point-layout     propagation              
sixlowpan                 spectrum                  stats                    
tap-bridge                test (no Python)          topology-read            
uan                       virtual-net-device        visualizer               
wave                      wifi                      wimax                    

Modules not built (see ns-3 tutorial for explanation):
brite                     click                     openflow                 

Leaving directory `./ns-3-dev
</code></pre>

<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h2><h3 id="3-1-添加实例程序"><a href="#3-1-添加实例程序" class="headerlink" title="3.1 添加实例程序"></a>3.1 添加实例程序</h3><p>Waf工具用于脚本运行，并保证共享库在运行时处在正确位置。 通过修改Waf程序配置，添加实例程序：</p>
<pre><code>
$ ./waf clean
$ ./waf configure --enable-examples --enable-tests --enable-modules=core
$ ./waf build
</code></pre>

<h3 id="3-2-单元测试"><a href="#3-2-单元测试" class="headerlink" title="3.2 单元测试"></a>3.2 单元测试</h3><p>NS-3自带单元测试功能，有了上述实程序之后，进行验证：    </p>
<pre><code>
fyang@fyang-virtual-machine:~/project/workspace/repos/ns-3-allinone/ns-3-dev$ ./test.py 
Waf: Entering directory `/home/fyang/project/workspace/repos/ns-3-allinone/ns-3-dev/build'
Waf: Leaving directory `/home/fyang/project/workspace/repos/ns-3-allinone/ns-3-dev/build'
'build' finished successfully (0.210s)

Modules built:
core                     

Modules not built (see ns-3 tutorial for explanation):
brite                     click                     openflow                 

PASS: TestSuite attributes
PASS: TestSuite callback
PASS: TestSuite command-line
PASS: TestSuite config
PASS: TestSuite global-value
PASS: TestSuite int64x64
PASS: TestSuite object-name-service
PASS: TestSuite object
PASS: TestSuite ptr
PASS: TestSuite event-garbage-collector
PASS: TestSuite sample
PASS: TestSuite simulator
PASS: TestSuite time
PASS: TestSuite timer
PASS: TestSuite traced-callback
PASS: TestSuite type-traits
PASS: TestSuite watchdog
PASS: TestSuite hash
PASS: TestSuite type-id
PASS: TestSuite threaded-simulator
PASS: TestSuite random-number-generators
PASS: TestSuite random-variable-stream-generators
PASS: Example examples/tutorial/hello-simulator
PASS: Example examples/tutorial/fourth
PASS: Example src/core/examples/main-callback
PASS: Example src/core/examples/sample-simulator
PASS: Example src/core/examples/main-ptr
PASS: Example src/core/examples/sample-random-variable
PASS: Example src/core/examples/sample-simulator.py
</code></pre>  

<h3 id="3-3-运行测试"><a href="#3-3-运行测试" class="headerlink" title="3.3 运行测试"></a>3.3 运行测试</h3><p>运行模拟器：  </p>
<pre><code>
./waf --run hello-simulator
</code></pre> 
结果：    
<pre><code>  
Waf: Entering directory `/home/fyang/project/workspace/repos/ns-3-allinone/ns-3-dev/build'
Waf: Leaving directory `/home/fyang/project/workspace/repos/ns-3-allinone/ns-3-dev/build'
'build' finished successfully (0.202s)
Hello Simulator
</code></pre>


<h2 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4 参考文献"></a>4 参考文献</h2><ol>
<li><a href="http://www.roguelynn.com/words/explain-like-im-5-kerberos/" target="_blank" rel="external">explain-like-im-5-kerberos</a> </li>
<li><a href="https://cryptocointalk.com/topic/14840-how-to-solve-g-internal-compiler-error-killed-program-cc1plus/" target="_blank" rel="external">g++ error</a></li>
<li><a href="https://www.nsnam.org/wiki/HOWTO_enable/disable_examples_and_tests_in_ns-3" target="_blank" rel="external">使能测试程序1</a></li>
<li><a href="http://www.nsnam.org/docs/manual/html/enable-modules.html" target="_blank" rel="external">使能测试程序2</a><br><a href="http://www.nsnam.org/docs/release/3.10/tutorial/html/getting-started.html" target="_blank" rel="external">getting-started</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##1 概述 ##  &lt;/p&gt;
&lt;p&gt;本文记录了NS-3模拟器在Ubuntu12.04桌面版上的完整安装记录。  &lt;/p&gt;
&lt;h2 id=&quot;2-安装&quot;&gt;&lt;a href=&quot;#2-安装&quot; class=&quot;headerlink&quot; title=&quot;2 安装&quot;&gt;&lt;/a&gt;2 安装&lt;/h2&gt;
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="NS-3" scheme="http://yoursite.com/tags/NS-3/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Token VS Cookie</title>
    <link href="http://yoursite.com/2014/12/16/token-vs-cookie/"/>
    <id>http://yoursite.com/2014/12/16/token-vs-cookie/</id>
    <published>2014-12-15T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>#1 概述<br>Client请求server端应用时，server端的验证方法有两种：  </p>
<ol>
<li>最常见的cookie-based Authentication：  Serve端发送给client的cookie，这样client每次登陆的时候server只需验证cookie即可。Cookie可以存在内存或者硬盘中。  </li>
<li>基于token的验证：<br>client收到签发的token之后，以后每次登陆需要发送至server端。</li>
</ol>
<p>#2 Token相比于cookie的优点</p>
<ul>
<li>Cross-domain/CORS:<br>Cookie + CORS 在不同的域之间工作的不是很好，token方法允许你利用AJAX调用至任何server和任何域，因为你利用HTTP头传递用户信息。<br>比如说SAML Tokens, SAML(Security Assertion Markup Language) tokens是一种标准化的基于XML的token，可以提供跨平台交互，而且client和server无需再同一个安全域内。  </li>
<li>无状态：<br>Server端无需维护一个session的存储，token本身是一个包含所有用户信息的实体。Cookie则存在状态，并且必须保存在client端。</li>
<li>CDN：<br>Sever端可以提供所有的APP特性，只需通过API访问CDN即可。</li>
<li>解耦：<br>无需绑定某个特定的验证方案，token可以在任何地方产生，因为你能够在任何地方以一种方式调用这些API。  </li>
<li>性能<br>计算HMAC-SHA256似乎效率更高</li>
<li>标准化：<br>你的API可以接受标准的JWT(JSON Web Token)。</li>
</ul>
<p>#3 Token存储<br>Token可以存储在三个地方：session storage/local storage/client side cookie。 如果存储在cookie中，利用了cookie的存储机制，而不是验证机制。  </p>
<p>#4 Token的生命周期<br>Token和cookie都有生命周期。  </p>
<ol>
<li>对于cookie而言，控制器生命周期有如下选择：  </li>
</ol>
<ul>
<li>Session cookie在浏览器关闭后被销毁；  </li>
<li>可以实现一个server端的检查，避免过期；  </li>
<li>Cookie可以在生命周期内是永久的，即浏览器关闭后不销毁。  </li>
</ul>
<ol>
<li>对Token而言，一旦token过期，你需要一个新的，可以用如下的更新机制：  </li>
</ol>
<ul>
<li>验证留的token；  </li>
<li>检查用户是否仍旧存在或者访问权限被吊销；  </li>
<li>签发一个更新了有效期的token</li>
</ul>
<p>#5 Token缺点</p>
<ol>
<li>对于大公司而言，token可能变得很大  </li>
<li>开发者的APP或者API变得更加复杂  </li>
<li>维护的时间成本较高<br>#6 Token VS Certificate VS Ticket<br>三者都是引入了第三方机构,以window的验证模式为例：  </li>
<li>Token：SAML Token，引入STS(Security Token Service)作为第三方机构  </li>
<li>Certificate：引入CA，即X.509 PKI架构  </li>
<li>Ticket：基于Kerberos的验证架构，引入TGS和AS作为KDC  </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#1 概述&lt;br&gt;Client请求server端应用时，server端的验证方法有两种：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最常见的cookie-based Authentication：  Serve端发送给client的cookie，这样client每次登陆的时候serve
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="token" scheme="http://yoursite.com/tags/token/"/>
    
      <category term="cookie" scheme="http://yoursite.com/tags/cookie/"/>
    
      <category term="http authentication" scheme="http://yoursite.com/tags/http-authentication/"/>
    
  </entry>
  
  <entry>
    <title>客户端证书与服务端证书</title>
    <link href="http://yoursite.com/2014/12/08/client-certificate-vs-server-certificate/"/>
    <id>http://yoursite.com/2014/12/08/client-certificate-vs-server-certificate/</id>
    <published>2014-12-07T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Server-Certificate"><a href="#Server-Certificate" class="headerlink" title="Server Certificate"></a>Server Certificate</h2><p>服务器端证书用于标识一个Server，典型地被签发给主机名，比如机器名或者host-header(www.baidu.com)。对Server证书而言，”Issued to”域意味着选择哪个签发的hostname。  </p>
<p><img src="/assets/images/server_certificate.png" alt="图片">    </p>
<ol>
<li>目的：加密和解密内容</li>
<li>真实世界里只有ROOT CA有自签名证书</li>
<li>存储：对于window IIS，Server certificates are stored in the Personal store of the “Local Computer” account</li>
<li>证书可以存储在用户账户对应的个人存储目录下，也是IIS缺省的搜索路径</li>
</ol>
<h2 id="Client-Certificate"><a href="#Client-Certificate" class="headerlink" title="Client Certificate"></a>Client Certificate</h2><p>服务器端证书用于标识一个Client或者user，意味着向Server验证Client，”Issued to”域采用用户的名字。  </p>
<p><img src="/assets/images/client_certificate.png" alt="图片">      </p>
<ol>
<li>目的：仅用于标识身份</li>
<li>真实世界里只有ROOT CA有自签名证书</li>
<li>Client certificate and private key的角色：</li>
</ol>
<ul>
<li>Client证书的证书和私钥作用就是为了在Client authentication中提供Client的数字签名。</li>
<li>crt后缀名文件仅仅包含证书，证书和私钥一般包含在.p12或者.pfx文件中(PKCS12格式)。</li>
<li>私钥如果单独存放，一般为.pem后缀名。</li>
<li>Server端需要client端的数字签名，然后发送至Server，Server利用client的证书（即公钥）解密，以确认client端的身份。其中Client端的数字签名生成过程如下：首先对SSL交互中的随机值进行HASH，然后用client的私钥进行加密。  </li>
</ul>
<h2 id="HTTPS下虚拟主机"><a href="#HTTPS下虚拟主机" class="headerlink" title="HTTPS下虚拟主机"></a>HTTPS下虚拟主机</h2><p>在HTTP下有虚拟主机这一概念，其目的是为了在服务端用单个IP支持多个主机名；对应到HTTPS，客户端验证服务器为不同主机配置多个证书，但是客户端需要检查服务器证书的common name,当客户端请求服务器证书的时候，服务器需要决定提供哪个证书，SNI应用而生，其原理如下图：  </p>
<p><img src="/assets/images/SNI.jpg" alt="图片">  </p>
<h2 id="中间人攻击与证书"><a href="#中间人攻击与证书" class="headerlink" title="中间人攻击与证书"></a>中间人攻击与证书</h2><p>SSL中间人攻击的形式主要有三种：SSL downgrading，SSL stripping和fake of SSL certs。<br>在SSL协议中，证书是用来进行身份验证的，这里有两个关键的检查点：  </p>
<ul>
<li>第一个是CA验证，对于客户端而言，验证服务器端证书依赖与本地的trust store，如果本地的trust  store被人篡改，那么避免中间人攻击则无从谈起，事实上这也正是PKI体系的弱点所在。  </li>
<li>第二个是hostname检查，用来确保所连接的服务器就是其声称的，如果有人劫持了DNS服务器，即利用DNS cache poisoning攻击让你的地址栏看起来很正常，这个时候劫持者就可以让此项检查通过。  </li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="http://www.windowsecurity.com/articles-tutorials/authentication_and_encryption/Understanding-Man-in-the-Middle-Attacks-ARP-Part4.html" target="_blank" rel="external">Understanding Man-In-The-Middle Attacks - Part 4: SSL Hijacking</a></li>
<li><a href="https://blog.cloudflare.com/introducing-strict-ssl-protecting-against-a-man-in-the-middle-attack-on-origin-traffic/" target="_blank" rel="external">Introducing Strict SSL</a></li>
<li><a href="https://devcentral.f5.com/articles/ssl-profiles-part-7-server-name-indication" target="_blank" rel="external">SNI for TLS</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Server-Certificate&quot;&gt;&lt;a href=&quot;#Server-Certificate&quot; class=&quot;headerlink&quot; title=&quot;Server Certificate&quot;&gt;&lt;/a&gt;Server Certificate&lt;/h2&gt;&lt;p&gt;服务器端证书
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="Certificate" scheme="http://yoursite.com/tags/Certificate/"/>
    
  </entry>
  
  <entry>
    <title>OAuth 2.0初探</title>
    <link href="http://yoursite.com/2014/12/08/authorization-code-flow-in-oauth-20/"/>
    <id>http://yoursite.com/2014/12/08/authorization-code-flow-in-oauth-20/</id>
    <published>2014-12-07T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OAuth解决什么问题"><a href="#OAuth解决什么问题" class="headerlink" title="OAuth解决什么问题"></a>OAuth解决什么问题</h3><h3 id="1、场景"><a href="#1、场景" class="headerlink" title="1、场景"></a>1、场景</h3><p>某孕妇Mrs.Lily向她的私人医生Dr.Michael申请做胎心监护，Dr.Michael了解到Mrs.Lily在医院A.Hospital做过类似的检查，因此Dr.Michael希望访问A.Hospital的在线系统获取Mrs.Lily的相关数据，最直接的方法就是向Mrs.Lily索要其在A.Hospital在线系统用户名和密码。<br>那么问题来了，该方法会造成哪些潜在安全威胁？    </p>
<ul>
<li>Dr.Michael会保存用户Mrs.Lily的密码，很不安全  </li>
<li>Dr.Michael拥有了获取用户Mrs.Lily在A.Hospital在线系统的所有资料的权利，这样用户无法限制Dr.Michael的授权范围和时间  </li>
<li>Mrs.Lily只有修改其密码，才能收回赋予Dr.Michael的权力，但同时也使得其他获得Mrs.Lily授权的访问应用失效  </li>
</ul>
<h3 id="2、OAuth的特点"><a href="#2、OAuth的特点" class="headerlink" title="2、OAuth的特点"></a>2、OAuth的特点</h3><p>OAuth解决了上述问题，即定义了一种允许一个APP访问用户相关的其他APP的验证机制，比如用户可以利用QQ账号登陆其他APP。基本思路如下：   </p>
<ol>
<li>OAuth在“客户端”与“服务提供商”之间，设置了一个授权层（authorization layer）。 “客户端”不能直接登陆和访问“服务提供商”，只能登陆授权层，这样就把用户和客户端分隔开来。  </li>
<li>“客户端”不在使用密码，而是令牌(token),可以在登陆的时候指定授权范围和有效期限。  </li>
<li>“客户端”登陆授权层之后，“服务提供商”根据令牌的授权范围和有效期限，以决定向客户开放哪些信息。  </li>
</ol>
<h3 id="OAuth工作流程"><a href="#OAuth工作流程" class="headerlink" title="OAuth工作流程"></a>OAuth工作流程</h3><p>待续。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="http://architecture-soa-bpm-eai.blogspot.com/2012/08/oauth-20-for-my-ninth-grader.html" target="_blank" rel="external">oauth-20-for-my-ninth-grader</a>  </li>
<li><a href="http://liboauth.sourceforge.net/" target="_blank" rel="external">liboauth in C</a></li>
</ol>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;OAuth解决什么问题&quot;&gt;&lt;a href=&quot;#OAuth解决什么问题&quot; class=&quot;headerlink&quot; title=&quot;OAuth解决什么问题&quot;&gt;&lt;/a&gt;OAuth解决什么问题&lt;/h3&gt;&lt;h3 id=&quot;1、场景&quot;&gt;&lt;a href=&quot;#1、场景&quot; class=&quot;
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="OAuth" scheme="http://yoursite.com/tags/OAuth/"/>
    
      <category term="Authorization" scheme="http://yoursite.com/tags/Authorization/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议栈中的数据收发</title>
    <link href="http://yoursite.com/2014/12/02/little-on-tcpip-stack/"/>
    <id>http://yoursite.com/2014/12/02/little-on-tcpip-stack/</id>
    <published>2014-12-01T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文将对TCP/IP的数据收发做一个粗略总结~    </p>
<hr>
<h3 id="1、TCP-IP基本特点"><a href="#1、TCP-IP基本特点" class="headerlink" title="1、TCP/IP基本特点"></a>1、TCP/IP基本特点</h3><p>TCP/IP总的设计目的就是保证数据的快速有序的传输，且无丢失，基本特点如下：  </p>
<ul>
<li><strong>面向连接</strong>：两端组成一个连接，每端以五元组为标识</li>
<li><strong>双工字节流</strong>： 采用字节流进行双工数据通信</li>
<li><strong>有序发送</strong>：利用序列号保证发送的有序性</li>
<li><strong>可靠性</strong>：利用ACK保证数据的可靠性</li>
<li><strong>流控</strong>：接收方利用接收窗口通告发送方</li>
<li><strong>拥塞控制</strong>：接收方利用拥塞窗口通告发送方  </li>
</ul>
<h3 id="2、报文发送过程"><a href="#2、报文发送过程" class="headerlink" title="2、报文发送过程"></a>2、报文发送过程</h3><p>TCP/IP网络协议栈包含多个层次，下图以一个TCP连接中的报文发送过程简述其基本流程：</p>
<p><img src="/assets/images/TCP/tx.jpg" alt="图片">  </p>
<center>Figure 1: TX flow</center>

<ol>
<li>用户层创建数据，调用write系统调用发送数据。</li>
<li>一旦执行系统调用，系统则进入内核层。对于类Linux系统，通过文件描述符关联socket和应用，内核中socket包含收发两块buffer。</li>
<li>在系统调用执行数据将被拷贝至内核memory当中，然后添加至发送buffer尾部，即按序发送。</li>
<li>在TCP层，TCB(TCP Control Block) 关联socket，如果TCP允许数据发送，内核创建TCP segment。否则，由于规则或者流量控制会将该报文丢弃。至于TCP segment报文格式，无外乎一个header加payload，还有个checksum。TCP校验和往往由网卡进行计算。</li>
<li>继续在TCP segment上封装IP层，再算下IP校验和，就可以扔给网络层了，比如以太网层。</li>
<li>以太网层开始查找下一跳IP的MAC地址，一旦完成将继续封装Etherent头，最终送往driver层，这里往往也是各大抓包工具进行数据拷贝的地方，比如tcpdump/wirshark，或者是自己写的抓包工具；流量整形也往往在这一层完成。</li>
<li>driver层在收到发送请求之后，通过DMA将该主存中的数据拷贝至内部RAM之中。在数据拷贝中，同时加入符合以太网协议的相关header，IFG、前导符和CRC。对于以太网网络，物理层发送采用CSMA/CD,即在发送过程中侦听链路冲突；而对于Wi-Fi网络，则采用CSMA/CA，其基本思想是要想占用channel并发言，首先做好聆听（也是做人哲学之一），对于需要ACK的报文，一旦在规定时间内搜不到ACK，则重传该报文。</li>
<li>一旦网卡完成报文发送，将产生中断通知CPU。</li>
</ol>
<p>对于报文发送过程而言，上层协议栈是生产者，驱动层为消费者。  </p>
<p>下面以无线网卡驱动为例详述整个报文发送流程的实现细节：      </p>
<ul>
<li>上层协议栈（三层及以上）和驱动层之间的数据传递采用队列，一个网络接口绑定一个三层报文发送队列。802.11 MAC层从网络接口的发送队列中拿到三层报文，添加LLC层和802.11 header，此时二层报文已经组好。  </li>
<li>驱动层同样采用一个二层报文发送队列，可以将上一步组好的二层报文放入该队列。驱动的任务就是把二层报文送入无线网卡的硬件FIFO，最终转为射频信号发送。软硬件交互通过一个循环缓冲区完成，具体而言，首先主存中定义一个TX Ring，包括多个TFD（发送描述符），其中一个TFD可以由多个TB（发送缓冲区）组成，里面除了包含要发送的数据，还包含了发送相关的控制信息；数据在DRAM和硬件FIFO之间的搬迁由DMA完成，搬迁的数量通过TX Ring的两个指针完成，一个是写指针，由软件更新，告诉硬件我已经把这个位置的TFD准备好，你可以拿了，另一个是读指针，由硬件拿走数据后更新该指针，通过中断告诉软件我已经取走数据，你可以继续在该TFD上更新数据。</li>
</ul>
<h3 id="3、报文的接收过程"><a href="#3、报文的接收过程" class="headerlink" title="3、报文的接收过程"></a>3、报文的接收过程</h3><p><img src="/assets/images/TCP/rx.jpg" alt="图片">  </p>
<center>Figure 2: RX flow</center>

<ol>
<li>网卡对报文进行CRC检查，如果合法就写入主存（一般通过DMA完成）。一旦完成写入，网卡发送中断通知CPU。</li>
<li>驱动层对报文进行检查，在发送至上层协议栈之前，必须封装成OS相关的数据结构，比如Linux对应sk_buff，BSD对应mbuf。</li>
<li>以太网层同样对报文进行合法性检查，然后发送至网络层，交给不同的协议处理模块，对于IP报文交给IP层，而对于ARP报文则送至ARP模块。</li>
<li>IP层继续检查报文合法性，判断其是进行IP路由还是本地处理。根据IP头的协议字段，上发至上层，比如6对应TCP层。</li>
<li>TCP层同样检查TCP检验和，往往由网卡计算完成，而不是内核。</li>
<li>以TCP报文的五元组作为关键字进行连接查找，查看是否匹配该层的规则，如果符合，则加入接收缓冲区。</li>
</ol>
<h3 id="4、不是结束语"><a href="#4、不是结束语" class="headerlink" title="4、不是结束语"></a>4、不是结束语</h3><p>理解问题需从根上抓起，TCP/IP也一样，仍有许多细节需要在工作实践中反复体会。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本文将对TCP/IP的数据收发做一个粗略总结~    &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1、TCP-IP基本特点&quot;&gt;&lt;a href=&quot;#1
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>一张物联网框图</title>
    <link href="http://yoursite.com/2014/11/20/iot-technology-stack/"/>
    <id>http://yoursite.com/2014/11/20/iot-technology-stack/</id>
    <published>2014-11-19T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>#IOT  </p>
<p><img src="/assets/images/IOT.png" alt="图片">  </p>
<center>IOT technology stack</center>  ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#IOT  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/IOT.png&quot; alt=&quot;图片&quot;&gt;  &lt;/p&gt;
&lt;center&gt;IOT technology stack&lt;/center&gt;  
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="IOT" scheme="http://yoursite.com/tags/IOT/"/>
    
      <category term="物联网" scheme="http://yoursite.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>OOP小记</title>
    <link href="http://yoursite.com/2014/10/25/oop-review/"/>
    <id>http://yoursite.com/2014/10/25/oop-review/</id>
    <published>2014-10-24T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OOP中的类"><a href="#OOP中的类" class="headerlink" title="OOP中的类"></a>OOP中的类</h2><ul>
<li><strong>类即数据结构</strong>：实现新的类库就是定义了新的数据结构。  </li>
<li><strong>广义的生产者和消费者</strong>：类创建者对应生产者，类使用者即客户端程序员。  </li>
<li><strong>对象即服务</strong>：关注于该对象能提供给用户那些服务，而不关注其内部实现。  </li>
<li><strong>类关系表达方法</strong>：基类开始由上至下。  </li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态用到的技术即后期绑定，由JAVA内部一段程序实现；相反，前期绑定则通过绝对地址调用实现。C++需要用virtual显示声明,JAVA默认支持。</p>
<h2 id="容器与迭代器"><a href="#容器与迭代器" class="headerlink" title="容器与迭代器"></a>容器与迭代器</h2><p>容器本质提供了各种数据类型的抽象，JAVA中包括List类，MAP类，以及队列、树堆栈等。迭代则提供了对容器成员的抽象化访问，比如设值、取值和遍历等。在C语言中可以利用<strong>函数指针</strong>进行迭代器的设计。</p>
<h2 id="单根继承结构"><a href="#单根继承结构" class="headerlink" title="单根继承结构"></a>单根继承结构</h2><p>所有对象都具备相同的接口，好处是垃圾回收器可以方便的发送适当的消息给系统中的每一个对象。</p>
<h2 id="向上转型向下转型"><a href="#向上转型向下转型" class="headerlink" title="向上转型向下转型"></a>向上转型向下转型</h2><p>有待理解。</p>
<h2 id="真并发与伪并发"><a href="#真并发与伪并发" class="headerlink" title="真并发与伪并发"></a>真并发与伪并发</h2><p>前者即多个线程运行在多个处理器上，后者是多个线程分时复用一个CPU。程序写得不好，会造成在多处理器中出现线程总运行与某个处理器之上。</p>
<h2 id="为什么会有WEB客户端编程"><a href="#为什么会有WEB客户端编程" class="headerlink" title="为什么会有WEB客户端编程"></a>为什么会有WEB客户端编程</h2><p>WEB客户端编程设计初衷就是期望减轻服务器端压力，将计算和逻辑控制过程置于客户端运行。具体方法包括插件、脚本语言比如JAVAScript、VBScript等、JAVA（利用applet）。相比脚本语言。JAVA applet和前者的本质区别在于其本身是以被编译过的形式存在的，并且利用<strong>数字签名</strong>保障安全性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;OOP中的类&quot;&gt;&lt;a href=&quot;#OOP中的类&quot; class=&quot;headerlink&quot; title=&quot;OOP中的类&quot;&gt;&lt;/a&gt;OOP中的类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类即数据结构&lt;/strong&gt;：实现新的类库就是定义了新的数据结构。  &lt;/li
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="OOP" scheme="http://yoursite.com/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议与Web开发</title>
    <link href="http://yoursite.com/2014/10/19/web-application-layer/"/>
    <id>http://yoursite.com/2014/10/19/web-application-layer/</id>
    <published>2014-10-18T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-Basic"><a href="#HTTP-Basic" class="headerlink" title="HTTP Basic"></a>HTTP Basic</h2><h3 id="HTTP资源"><a href="#HTTP资源" class="headerlink" title="HTTP资源"></a>HTTP资源</h3><p>HTTP用于获取服务器的资源，资源的种类称为MIME，资源的表达方式URI（统一资源标识符）。URI有两种形式，URL和URN：      </p>
<ul>
<li>URL精确说明了资源的位置及如何访问它，包括方案（HTTP、FTP），服务器因特网地址和WEB服务器上的某个资源。  </li>
<li>URN（统一资源名）目的是为了使用同一个名字通过多种网络协议来访问资源。URI几乎都是URL。</li>
</ul>
<h3 id="HTTP事务"><a href="#HTTP事务" class="headerlink" title="HTTP事务"></a>HTTP事务</h3><p>一个事务包含一条请求加响应的响应。HTTP方法：    </p>
<ul>
<li>GET：从服务器向客户端发送命令资源     </li>
<li>POST：将客户端数据发送至一个服务器网关应用程序；  </li>
<li>PUT：将来自客户端的数据存储至一个命名的服务器资源中去；  </li>
<li>DELETE：从服务器张删除命名资源。  </li>
</ul>
<p>HTTP客户端的应用程序为了完成某项任务可以发布多个HTTP事务，而请求的资源可以位于不同的HTTP服务器端。比如JAVA小程序、图像等。</p>
<h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>HTTP报文都是纯文本，不是二进制，包含三部分：     </p>
<ul>
<li>起始行（start lines）： 典型首部字段比如Content-Type: text/html; charset=utf-8    </li>
<li>首部 (Header)   </li>
<li>主体 (entity body)</li>
</ul>
<h3 id="HTTP报文传输"><a href="#HTTP报文传输" class="headerlink" title="HTTP报文传输"></a>HTTP报文传输</h3><p>基于TCP/IP传输，因此需要目的IP地址和端口号。HTTP通过URL告诉TCP层IP地址和端口号。其中URL可以直接包含IP地址或者通过DNS查询得到，端口号默认为80。<br>TCP为HTTP提供了一条可靠的比特传输通道，从TCP一端填入的字节会从另外一端以原有顺序、正确的传送出来。  </p>
<p><img src="/assets/images/tcp_http.jpg" alt="图片"></p>
<p>HTTP事务的性能在很大程度上决定上取决于底层TCP通道的性能。HTTP时延主要由TCP时延引起。需要考虑如下因素：  </p>
<ul>
<li>TCP连接建立握手；  </li>
<li>TCP慢启动拥塞控制；  </li>
<li>数据汇聚的Nagle算法；  </li>
<li>用于捎带确认的TCP延迟确认算法；    </li>
</ul>
<h3 id="HTTP连接管理"><a href="#HTTP连接管理" class="headerlink" title="HTTP连接管理"></a>HTTP连接管理</h3><p>在HTTP层的优化方法：      </p>
<ul>
<li>并行化连接：HTTP客户端打开多个连接，并行执行HTTP事务，即每个事务对应自己的。  </li>
<li>持久化连接：通过头部的connection字段完成，client填充keep-alive，如果server同意，就会回复同样的字段和数据内容。  </li>
<li>管道化连接  </li>
</ul>
<h3 id="HTTP验证框架"><a href="#HTTP验证框架" class="headerlink" title="HTTP验证框架"></a>HTTP验证框架</h3><p><strong>Secruity Realm</strong>  </p>
<p>server通过安全域告诉client授权范围限定在该域内。        </p>
<p><strong>HTTP Basic Authentication</strong>           </p>
<p>HTTP的验证框架基于Challenge/Response验证，一般仅用于测试可用性。具体而言，基本的HTTP验证通过GET方法，在首部利用WWW-Authentication字段（GET Response）和Authorization字段（GET Request）完成交互。 </p>
<p><img src="/assets/images/http_auth.jpg" alt="图片"></p>
<p>根据client在Authorization字段的对身份凭证（比如用户名密码）的处理方式不同，可以引申出诸多验证方式。    </p>
<ul>
<li>基于BASE64编码的基本认证；  </li>
<li>基于HASH算法的摘要认证；  </li>
<li>另外，为了防止重放攻击，可以再客户端和服务器端都引入随机数。    </li>
</ul>
<p>但是其其缺点也很明显：  </p>
<ul>
<li>缺乏对客户端的认证；  </li>
<li>缺乏对服务器端的认证；  </li>
<li>无法保证客户端和服务器端数据的完整性；  </li>
<li>无法保证客户端和服务器端之间数据的私密性；  </li>
</ul>
<p>HTTPS应运而生。    </p>
<p><strong>Token-based HTTP Authentication</strong></p>
<p>该种验证方式适合于桌面系统和移动设备客户端。</p>
<p><strong>Session backend for authentication</strong>  </p>
<p><strong>OAuth-based Authentication</strong>  </p>
<h2 id="Web应用的层次结构"><a href="#Web应用的层次结构" class="headerlink" title="Web应用的层次结构"></a>Web应用的层次结构</h2><p>Web的基本原理即client向server发起HTTP Requst, server向client回应HTTP Response。client不仅仅局限于浏览器，也不限于人，更一般的情况下client向第三方发起HTTP Requst,得到第三方的HTTP Response。</p>
<h3 id="Static-website"><a href="#Static-website" class="headerlink" title="Static website"></a>Static website</h3><p>nginx 1.5 + modsecutity + openssl + bootstrap 2</p>
<h3 id="Background-workers"><a href="#Background-workers" class="headerlink" title="Background workers"></a>Background workers</h3><p>Phython 3.0 + celery + pyedis + libcurl + ffmpeg + libopencv + nodejs + phantomjs</p>
<h3 id="User-DB"><a href="#User-DB" class="headerlink" title="User DB"></a>User DB</h3><p>postgresql + pgv8 + v8  </p>
<h3 id="Anaytics-DB"><a href="#Anaytics-DB" class="headerlink" title="Anaytics DB"></a>Anaytics DB</h3><p>hadoop + hive + thrift + OpenJDK  </p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>随着HTTP交互的数据量增长，不可避免会出现请求无法响应的情况，例如Twitter的在宕机时会出现fail whale图片。为了解决这个问题，引入消息队列。    </p>
<ul>
<li>可以向第三方应用发送HTTP Request;  </li>
<li>可以更快的响应浏览器；  </li>
<li>如果第三方应用失败，不会影响到client；  </li>
<li>还可以发起重试；  </li>
<li>可以向对个第三方应用推送数据。  </li>
</ul>
<p>目前的消息队列库的实现可以基于多种语言，包括Ruby、Python、Java、Erlang、Scala、C#、Lua、 PHP 等等。  </p>
<p>消息队列遵循的协议有STOMP、AMQP和Memcache。  </p>
<p>消息队列相关的软件包括RabbitMQ、Stompserver、ZeroMQ、Morbid、ApacheMQ、Starling、Beanstalk、Kestrel以及MemcacheQ。  </p>
<p>Redis + redis-sentinel</p>
<ol>
<li>Kafka: A Distributed Messaging System</li>
<li>Redis: A Simple Key-Value Store</li>
</ol>
<h3 id="API-endpooint"><a href="#API-endpooint" class="headerlink" title="API endpooint"></a>API endpooint</h3><p>Python 2.7 + Flask + pyredis + celery + psycop + postgresql-client</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP-Basic&quot;&gt;&lt;a href=&quot;#HTTP-Basic&quot; class=&quot;headerlink&quot; title=&quot;HTTP Basic&quot;&gt;&lt;/a&gt;HTTP Basic&lt;/h2&gt;&lt;h3 id=&quot;HTTP资源&quot;&gt;&lt;a href=&quot;#HTTP资源&quot; class=&quot;
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux下802.11n TX aggregation实现框图</title>
    <link href="http://yoursite.com/2014/10/10/80211n-tx-aggregation-in-linux/"/>
    <id>http://yoursite.com/2014/10/10/80211n-tx-aggregation-in-linux/</id>
    <published>2014-10-09T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小引"><a href="#小引" class="headerlink" title="##小引"></a>##小引</h2><h2 id="正文"><a href="#正文" class="headerlink" title="##正文"></a>##正文</h2><p>本文研究了Linux下802.11n TX aggregation过程。</p>
<p>###1、MAC80211 Framework  </p>
<p>Linux协议栈中mac80211的整体架构如下图所示：      </p>
<p><img src="/assets/images/mac80211_framework.png" alt="图片">  </p>
<center>Figure 1: mac80211 framework</center>

<p>###2、Transmission: kernel-&gt;mac80211-&gt;iwlwifi  </p>
<p>kernel-&gt;mac80211-&gt;iwlwifi的具体层次如下图所示：      </p>
<p><img src="/assets/images/tx_agg_1.png" alt="图片">  </p>
<center>Figure 1: kernel-&gt;mac80211-&gt;iwlwifi flow</center>


<p>###3、Transmission: iwlwifi-&gt;hardware  </p>
<p>iwlwifi-&gt;hardware的具体层次如下图所示：      </p>
<p><img src="/assets/images/tx_agg_1.png" alt="图片">  </p>
<center>Figure 1: kernel-&gt;mac80211-&gt;iwlwifi flow</center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;小引&quot;&gt;&lt;a href=&quot;#小引&quot; class=&quot;headerlink&quot; title=&quot;##小引&quot;&gt;&lt;/a&gt;##小引&lt;/h2&gt;&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;##正文&quot;&gt;&lt;/a&gt;##正文&lt;/h
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="TX Aggregation" scheme="http://yoursite.com/tags/TX-Aggregation/"/>
    
      <category term="mac80211" scheme="http://yoursite.com/tags/mac80211/"/>
    
  </entry>
  
  <entry>
    <title>LCRS树在证书管理中的应用</title>
    <link href="http://yoursite.com/2014/05/16/lcrs-and-certificate-store/"/>
    <id>http://yoursite.com/2014/05/16/lcrs-and-certificate-store/</id>
    <published>2014-05-15T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works"></a>How it works</h2><h3 id="1-LCRS"><a href="#1-LCRS" class="headerlink" title="1. LCRS"></a>1. LCRS</h3><p>LCRS, 即left-child, right-sibling representation is a way of encoding a multi-way tree using a binary tree  </p>
<ul>
<li>树的本质在于用继承性的关系描述数据结构，只需理解继承性即可理解树</li>
<li>Binary Tree：意味着每个节点最多有两个孩子</li>
<li>Multi-way tree: 意味着每个节点有任意数目的孩子</li>
<li>LCRS仅仅是一种编码形式  </li>
</ul>
<h3 id="2-为什么要用到LCRS-Tree"><a href="#2-为什么要用到LCRS-Tree" class="headerlink" title="2. 为什么要用到LCRS Tree"></a>2. 为什么要用到LCRS Tree</h3><p>传统的Mutil-way Tree  </p>
<pre><code>
                    A       
                 //|\ \
               / / | \  \
              B C  D  E  F
              |   /|\   / \
              G  H I J K   L
</code></pre>  

<p><strong>数据结构表达</strong>  </p>
<pre><code>
struct Node {
    DataType value;
    std::vector<node*> children;  /*用到多个孩子指针*/
};
</node*></code></pre> 

<p>每个节点存储一个是leftmost child，另外一个指针指向其右兄弟节点，形式变化如下：  </p>
<pre><code>
            A
           /
          /
         /
        B -> C -> D -> E -> F
       /         /           /
      G         H->I->J   K->L
</code></pre>

<p>层次和结构不变，变的是存储方式。可以理解为double chained  tree:</p>
<ul>
<li>每个节点的leftmost child都链接在单链表里， 用child域存储下一个child，在tree的层次逐层增加；</li>
<li>每个节点的兄弟节点都链接在另外一个单链表里，用sibling域存储该节点的兄弟节点，在tree中的层次是一样的</li>
</ul>
<p><strong>遍历</strong></p>
<p>From a parent node to its kth child (zero-indexed):</p>
<p>Descend至当前节点的leftmost child,即child向右遍历该节点的兄弟节点k次返回节点,<br>数据结构描述相应变为：</p>
<pre><code>  
struct Node {    
    DataType data;
    Node* leftChild;/**/
    Node* rightSibling; /*存储着*/
};  
</code></pre> 

<p><strong>Multi-way tree VS LCSR tree</strong>  </p>
<ul>
<li>内存空间：后者比前者节省大约40%    </li>
<li>时间：如果分叉因子很多，即每层的节点很多，前者查询节点只需找到对应的子节点指针即可，后者则需进行单链表遍历（树退化为链表），导致时间变长  </li>
</ul>
<h3 id="3-LCRS适用场景"><a href="#3-LCRS适用场景" class="headerlink" title="3. LCRS适用场景"></a>3. LCRS适用场景</h3><ul>
<li>Memory is extremely scarce: 如果在主存中存储一颗巨大多路树，LCRS会合适</li>
<li>Random access of a node’s children is not required  </li>
</ul>
<p>在构建某些特定的数据结构是，比如Heap data structures ，采样LCRS可以优化空间，而最常见操作集中如下：删除tree的根节点和处理一个孩子；合并两颗树，而这二者对于LCRS易于完成，对于certificate存储系统，该操作常见。</p>
<h2 id="LCRS在证书系统中的应用"><a href="#LCRS在证书系统中的应用" class="headerlink" title="LCRS在证书系统中的应用"></a>LCRS在证书系统中的应用</h2><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><pre><code>
#define CTREE_CLASS_CERT.       0
#define CTREE_C_SCLASS_PUBLIC.  0x0001.
#define CTREE_C_SCLASS_PRIVATE. 0x0002.
#define CTREE_C_SCLASS_BOTH.    0x0003.
#define CTREE_CLASS_ROOT.       1
#define CTREE_CLASS_FOLDER.     2.     
#define CTREE_F_SCLASS_COMMON.  0x0020.
#define CTREE_F_SCLASS_UNKNOWN. 0x0021

struct tree {
    struct tree *parent;
    struct tree *child;    /*leftmost child, as the sibling’s list head*/
    struct tree *sibling;    /*link to child in single list structure*/
    uchar.  name[64];        /*file name, eg certificate name*/
    uint .  id;    /* Must be > 0 */
    ushort. type, subtype;    /* both for reserved */
    ushort .iclass, subclass;    /*cert/root/folder; private key/public key*/
    uchar.  num_child, level, unused[2];    /*tree level*/
    uint .  capability;    /*reserved*/
    pBmp.   EBmp, CBmp;    /*Icon*/
    void.   *iprivate;    /*for unkown CA folder and private info*/
};   

</code></pre>   

<h3 id="2-API"><a href="#2-API" class="headerlink" title="2. API"></a>2. API</h3><p><strong>Insert node</strong>  </p>
<p><strong>remove node</strong>  </p>
<pre><code>
STATIC void

ctree_remove_node(struct tree *troot, uchar *filename)
{
        struct tree *delte, *parent, *child, *lost, *lastchild;
        delte = tree_find_node_by_name(troot, filename, 1);/*获取要删除的节点*/

        if (delte == 0)
                return;

        parent = delte->parent;         /*取得被删节点的父指针*/
        child = parent->child;          /*取得leftmost child指针*/

        if (parent->child == delte)     /*Case1: 被删节点就是leftmost child*/
                parent->child = delte->sibling; /* 修改leftmost child指向被删节点的兄弟*/
        else {  /*Case1: 被删节点是sibling节点*/
                child = parent->child;  /*以leftmost child为单链表头遍历，获取要删除的sibling节点 */
                while (child->sibling != delte)
                        child = child->sibling;
                ASSERT(child->sibling == delte);
                if (child->sibling != delte)
                        return;
                child->sibling = delte->sibling;
        }

        delte->parent = 0;
        delte->sibling = 0;
        if (delte->child == 0)  /*如果被删节点没有孩子，则直接返回*/
                return;

        lost = (struct tree *) troot->iprivate; /*重新连接整个子树至unkown CA*/

        //re-link child
        child = delte->child;

        do {    /*将该层所有的孩子节点的父指针修改为lost,即unkown CA*/
                child->parent = lost;
                lastchild = child; /*记录该层最后一个孩子节点*/
                child = child->sibling;/*单链表遍历*/
        } while (child);

        lastchild->sibling = lost->child; /*最后一个孩子节点的next指针(sibling)指向lost的leftmost child*/

        lost->child = delte->child; /*修改lost的leftmost child为被删节点的leftmost child*/

        delte->child = 0;

        ctree_free_node(delte);

        tree_update_order(lost); /*更新以lost为root的子树*/
}

</code></pre>


<p><strong>update subtree</strong>     </p>
<pre><code>  
void tree_update_order(struct tree *parent)
{    
    struct tree *child;
    uint.   previd = 0;.   

    PRINTF("TW: parent update [%s] (lv %d, id %x)\n", parent->name, parent->level, parent->id);

    parent->num_child = 0;

    while (child = tree_next_child(parent, previd)) { /*获取该层的所有孩子*/
        child->level = parent->level + 1; /*孩子的层是父亲层加1*/
        child->id = tree_calc_orderid(parent);
        PRINTF("TW: child [%s] lv %d id %x\n", child->name,  child->level, child->id);

        tree_update_order(child); /*child作为子树root递归调用*/
        previd = child->id; /*更新前一个id*/
        child = child->sibling; /*单链表遍历*/
    }

    PRINTF("TW: [%s] return \n", parent->name);
}  

</code></pre>  

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;How-it-works&quot;&gt;&lt;a href=&quot;#How-it-works&quot; class=&quot;headerlink&quot; title=&quot;How it works&quot;&gt;&lt;/a&gt;How it works&lt;/h2&gt;&lt;h3 id=&quot;1-LCRS&quot;&gt;&lt;a href=&quot;#1-LCRS&quot;
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="LCRS" scheme="http://yoursite.com/tags/LCRS/"/>
    
      <category term="certificate" scheme="http://yoursite.com/tags/certificate/"/>
    
      <category term="data structure" scheme="http://yoursite.com/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>LDAP那些事儿</title>
    <link href="http://yoursite.com/2014/04/24/ldap-those-things/"/>
    <id>http://yoursite.com/2014/04/24/ldap-those-things/</id>
    <published>2014-04-23T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LDAP-概述"><a href="#LDAP-概述" class="headerlink" title="LDAP 概述"></a>LDAP 概述</h2><p>由DAP发展而来，相比DAP，其基于TCP/IP，在功能上有所减少。LDAP本质上就是一种定义了如何访问目录数据的方法的协议，同时定义了在目录服务中数据是如何表达的。<br>对于数据操作，LDAP只定义了数据如何加载至目录服务和如何从目录服务导出数据，并未定义如何存储数据和操作，厂家可以有自己的back-end的具体实现，比如OpenLDAP提供了选择back-end数据库的支持。事实上很多商业DB都提供了LDAP视图。  </p>
<p>###1. LDAP与DB  </p>
<p>LDAP可以看做是一种读优化的数据库。LDAP Server可以基于multi-master架构，也可以基于Multi-master架构。  </p>
<ol>
<li>LDAP提供了一种标准化的远程和本地数据的访问方法。可以在不影响外部数据访问接口的前提下替换LDAP的实现。  </li>
<li>由于标准化了数据访问，LDAP客户端和服务器端可以独立开发。  </li>
<li>可以不影响外部数据访问的前提下转移数据至多个地点。  </li>
</ol>
<p>###2. LDAP信息模式  </p>
<p>LDAP是面向对象的数据库，定义了基础原语（read/delete/modify），以继承性对象的方式表示数据。  </p>
<p>###3. LDAP与AD  </p>
<p>LDAP提供了一种可以查询和修改目录服务的应用协议。AD本质就是一种数据库的系统，在window环境中提供验证、目录、策略和其他服务。<br>LDAP是一个标准，AD则是微软的基于目录服务器的一中LDAP实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LDAP-概述&quot;&gt;&lt;a href=&quot;#LDAP-概述&quot; class=&quot;headerlink&quot; title=&quot;LDAP 概述&quot;&gt;&lt;/a&gt;LDAP 概述&lt;/h2&gt;&lt;p&gt;由DAP发展而来，相比DAP，其基于TCP/IP，在功能上有所减少。LDAP本质上就是一种定义了如何
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="LDAP" scheme="http://yoursite.com/tags/LDAP/"/>
    
      <category term="AD" scheme="http://yoursite.com/tags/AD/"/>
    
      <category term="database" scheme="http://yoursite.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Kerberos那些事</title>
    <link href="http://yoursite.com/2014/04/09/kerberos-those-thing/"/>
    <id>http://yoursite.com/2014/04/09/kerberos-those-thing/</id>
    <published>2014-04-08T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对kerberos的协议细节做一个粗略介绍~  </p>
<p>原文链接<a href="http://www.roguelynn.com/words/explain-like-im-5-kerberos/" target="_blank" rel="external">explain-like-im-5-kerberos</a>  </p>
<hr>
<p>##1、Nutshell  </p>
<p>Kerberos源自古希腊神话中的三头狗，对应引入了第三方验证系统。</p>
<p>Kerberos有如下特点：  </p>
<ul>
<li>一种验证协议</li>
<li>采用ticket进行验证</li>
<li>密码通过网络进行传递，避免了本地存储</li>
<li>需要引入第三方机构</li>
<li>基于对称加密算法  </li>
</ul>
<p>一个ticket意味着用特定服务请求所对应的key加密后的身份证明，如果其有效，你可以在一个kerberos域内访问该服务。</p>
<p>Ticket由很多信息组成，以保证特定服务授权的针对性和实效性。<br>Keberos其目的仍是保证client和client所请求的服务或者主机之间的session key。  </p>
<p>典型实例：<br>访问内网的工资系统，每次重新输入user/password的时候或者在终端运行kinit USER的时候，用户的ticket会更新。  </p>
<p>##2、Kerberos Realm </p>
<p>管理员创建realm，囊括了所有可能的访问，即定义了不同服务和主机的访问策略和授权，其本质为依据谁能够访问什么的原则定义了Kerberos的管理内容。  </p>
<p>用户主机位于该realm,同时也包括了所期望访问的服务、KDC(Key Distribution Center)。  </p>
<p>KDC可以分为Authentication Server 和Ticket Granting Server。  </p>
<p><img src="/assets/images/kerberos/Kerb.001.jpg" alt="图片"></p>
<p>##3、Kerberos那些事  </p>
<p>当访问一个服务或者主机时，存在着三种交互：  </p>
<ul>
<li>Client 和Authentication Server</li>
<li>Client 和Ticket Granting Server</li>
<li>Client和服务器</li>
</ul>
<p>其他要点如下：</p>
<ul>
<li>每次交互client可以收到两条消息，一条是可以解密的，一条是无法解密的；</li>
<li>Client期望访问的服务或者主机从不直接与KDC通信；</li>
<li>KDC存储了其数据库下所有主机和服务的密钥；</li>
<li>密钥由密码加上一组随机数的哈希值，哈希算法由Kerberos的具体实现选择。对于服务和主机而言，其本身是没有密码的。一个密码实际上是由管理员的初始启动时产生和存储于服务和主机中的；</li>
<li>所有密钥存储于KDC数据库；</li>
<li>KDC本身由主密钥加密；</li>
<li>已经存在Kerberos的配置和实现采用公钥加密。</li>
</ul>
<p>上述定义的消息和内容并未反映他们在TCP、UDP发送中的实际顺序。<br>下面描述如果访问一个内部的HTTP服务，将会发生什么。</p>
<p>###3.1、You and the Authentication Server  </p>
<p>在访问HTTP服务之前，client必须向authentication server介绍自己。当登陆系统或者运行kinit USERNAME的时候，通过一个明文请求TGT(Ticket Granting Ticket)。其具体内容包括：</p>
<ul>
<li>Name/ID</li>
<li>服务ID(有很多的服务ID？)</li>
<li>网络地址</li>
<li>合法TGT的请求生命周期</li>
</ul>
<p><img src="/assets/images/kerberos/Kerb.002.jpg" alt="图片"></p>
<p>Authentication server仅仅检查是否存在于KDC数据库，无需密码。</p>
<p><img src="/assets/images/kerberos/Kerb.003.jpg" alt="图片"></p>
<p>Authentication server回复两条消息：<br>消息一，即用TGS的密钥(TGS和Authenticator都知道各自的密钥？)加密的ticket, 即TGT，这个TGT包括如下：</p>
<ul>
<li>Client name/ID；</li>
<li>TGS name/ID,即ticket服务器也自报家门；</li>
<li>时间戳；</li>
<li>Client的网络地址；</li>
<li>TGT生命周期，即ticket的生命周期；</li>
<li>TGS session Key，即会话密钥。  </li>
</ul>
<p>消息二，即client密钥加密的TGS会话密钥等：  </p>
<ul>
<li>TGS name/ID;</li>
<li>Timestamp;</li>
<li>生命周期；</li>
<li>TGS session key;</li>
</ul>
<p>TGS session key就是client和TGS之间的共享密钥。  </p>
<p><img src="/assets/images/kerberos/Kerb.004.jpg" alt="图片"></p>
<p>Client 密钥通过提示client输入密码，再加上一个随机串，最后对整个进行哈希得到。可以用该密钥解密TGS发送过来的第二条消息，以获取TGS 会话密钥。显然，如果密码错误，client 将无法解密该条消息。实际上是完成了对client password的隐性验证。   </p>
<p><img src="/assets/images/kerberos/Kerb.005.jpg" alt="图片"> </p>
<p>由于不知道TGS 密钥，无法解密TGT，将此加密的TGT存储于credential cache当中。</p>
<p>###3.2、You and the Ticket Granting Server</p>
<p>此时，client拥有TGS session key，但是没有TGS密钥。<br>现在轮到client发送两条消息了：  </p>
<p>第一条消息为Authenticator 准备，用TGS会话密钥加密如下信息：<br>Client name/ID + timestamp  </p>
<p>第二条消息是明文，包含请求的HTTP服务名称和HTTP服务的ticket生命周期同时还有加密的Authenticator和TGT。   </p>
<p><img src="/assets/images/kerberos/Kerb.006.jpg" alt="图片"></p>
<p>TGS收到这两个消息后，首先检查KDC数据库中是否存在所请求的HTTP服务。  </p>
<p><img src="/assets/images/kerberos/Kerb.007.jpg" alt="图片"></p>
<p>如果存在，TGS用TGS密钥解密TGT。因为解密后的TGT包含TGS会话密钥，因此TGS可以解密client所发送的Authenticator。    </p>
<p><img src="/assets/images/kerberos/Kerb.008.jpg" alt="图片"></p>
<p>TGS然后将作如下操作：  </p>
<ul>
<li>比较authenticator中包含的client ID和TGT中包含的；</li>
<li>比较两者之间的时间戳，误差一般可容忍2分钟；</li>
<li>通过生命周期字段检查TGT是否过期；</li>
<li>检查authenticator已经不在TGS的cache当中。</li>
<li>如果原始请求中的网络地址不为NULL，比较其中的IP地址与TGT中的；</li>
</ul>
<p>此时，TGS开始随机产生client所请求的HTTP服务的会话密钥，准备HTTP服务ticket，包含如下信息：  </p>
<ul>
<li>Client name/ID;</li>
<li>HTTP服务name/ID;</li>
<li>Client的网络地址；</li>
<li>时间戳；</li>
<li>Ticket的生命周期；</li>
<li>HTTP服务session key;  </li>
</ul>
<p>上述信息由HTTP服务密钥加密。  </p>
<p><img src="/assets/images/kerberos/Kerb.009.jpg" alt="图片"></p>
<p>然后TGS向client发送两条信息：  </p>
<p>第一条是由HTTP服务密钥加密的HTTP服务ticket；  </p>
<p>第二条是由TGS session key加密的信息：  </p>
<ul>
<li>HTTP服务name/ID;</li>
<li>时间戳；</li>
<li>Ticket的生命周期；</li>
<li>HTTP服务session key。  </li>
</ul>
<p>Client利用cached的TGS session key解密第二条消息，以获取HTTP服务session key。而无法解密第一条消息，因为其没有HTTP服务密钥。</p>
<p><img src="/assets/images/kerberos/Kerb.010.jpg" alt="图片"></p>
<p>###3.3、 You and the HTTP Service  </p>
<p>为了访问HTTP服务，client准备了另外的Authenticator消息，包括：  </p>
<ul>
<li>Client name/ID;</li>
<li>时间戳。  </li>
</ul>
<p>用HTTP服务session key加密后发送给HTTP服务，同时也发送未解密的HTTP服务ticket。  </p>
<p><img src="/assets/images/kerberos/Kerb.011.jpg" alt="图片"></p>
<p>HTTP服务在收到消息后用HTTP服务密钥解密消息二，获取HTTP服务session key。然后用该Key解密client发送的第一条authenticator消息。    </p>
<p><img src="/assets/images/kerberos/Kerb.012.jpg" alt="图片"></p>
<p>类似于TGS，HTTP服务器也要做如下校验：    </p>
<ul>
<li>Client ID;</li>
<li>时间戳；</li>
<li>ticket是否过期；</li>
<li>避免反重放攻击，查看HTTP服务器的cache是否包含authenticator；</li>
<li>网络地址比较。  </li>
</ul>
<p>如果通过校验，HTTP服务然后发送一条Authenticator消息，该消息包含其服务ID及时间戳，由HTTP服务session key加密。  </p>
<p><img src="/assets/images/kerberos/Kerb.013.jpg" alt="图片"></p>
<p>Client收到HTTP服务发送的加密信息，用cache的HTTP 服务session key解密，由此接收到一条HTTP服务ID和时间戳的明文信息。  </p>
<p>此时client已经验证通过使用HTTP服务，将来的请求利用cached的HTTP服务ticket，前提是在定义的生命周期内。    </p>
<p><img src="/assets/images/kerberos/Kerb.014.jpg" alt="图片"></p>
<p>这里有个前提，HTTP服务本身必须支持Kerberos。同时，client必须要有一个支持SPNEGO/Negotiate的浏览器。  </p>
<p><img src="/assets/images/kerberos/Kerb.015.jpg" alt="图片"></p>
<p>##4、后续</p>
<p>token VS ticket</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对kerberos的协议细节做一个粗略介绍~  &lt;/p&gt;
&lt;p&gt;原文链接&lt;a href=&quot;http://www.roguelynn.com/words/explain-like-im-5-kerberos/&quot; target=&quot;_blank&quot; rel=&quot;external
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="ACCESS CONTROLS" scheme="http://yoursite.com/tags/ACCESS-CONTROLS/"/>
    
  </entry>
  
  <entry>
    <title>《APIs with an Appetite》读后感</title>
    <link href="http://yoursite.com/2014/01/30/c-api-design/"/>
    <id>http://yoursite.com/2014/01/30/c-api-design/</id>
    <published>2014-01-29T16:00:00.000Z</published>
    <updated>2017-08-06T11:30:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>##问题提出  </p>
<p>设计一个数据库的API，可供不同的WEB前端服务存储和获取数据。一些存储图像，一些存储文本、声音、图像等，如何控制API对数据的上述访问方法？  </p>
<p>##解决方案  </p>
<p>###1、瘦API  </p>
<p>void <em>do_as_i_say(…)  ，其参数是void </em>  </p>
<p>函数的目的在于提高访问复杂软件的接口，通过隐藏复杂性，提高软件的易用性, 但是该API并不能直观的告诉调用者如何使用。</p>
<p>###2、Fat APIs  </p>
<pre><code>
int store_jpeg_image(string name, image data);
image get_jpeg_image(string name); 
int delete_jpeg_image(string name); 
int store_gif_image(string name, image data); 
image get_gif_image(string name); 
int delete_gif_ image(string name); 
int store_tiff_image(string name, image data); 
image get_tiff_image(string name); 
int delete_tiff_image(string name); 
int store_text(string name, string data); 
string get_text(string name); 
int delete_text(string name);
</code></pre><p>这里走向了另外一个极端，这里有几个问题：</p>
<ul>
<li>很多信息应该作为参数，而不是一个个罗列为API</li>
<li>尽量提供少的名字和用法，因为人类的记忆有限，不可靠记住如此多的用法</li>
</ul>
<p>###3、Good Example<br>Unix的文件IO操作为我们提供了一个良好的示例，该接口只有五个API：open、close、read、write、ioctl，其中最重要的API是ioctl,它为程序提供了访问系统底层的能力，以备为设计者预先没有想到的需要，相当于提供了一个后门。  </p>
<p>##奇淫巧计  </p>
<p>###1、instance  </p>
<p>该概念类似面向对象设计中的对象，用于维护一个实体，即可以创建、查找、销毁一个Instance。</p>
<p>###2、Cookie  </p>
<p>cookie的含义很广，在分层设计中，cookie可以用于保存上层的数据，包括配置数据和配置行为(往往通过回调函数定义)，这样底层可以无需知道上层的配置细节，直接调用其配置方法即可。  </p>
<p>###3、Callback  </p>
<ul>
<li><p>Callback可以实现底层调用上层，这里无需赘述  </p>
</li>
<li><p>Callback可以用于实现异步通知机制，比如在一个异步事件通知系统中，可以将事件处理方法和ID组成事件对象加入事件队列，其中事件处理方法采用callback函数，在事件注册时定义，实现处理系统轮询该事件队列，逐个调用，当然也可以加入优先级以改变响应次序。</p>
</li>
</ul>
<p>##结论  </p>
<p>API设计应该是一个迭代的过程，首先你提供你认为用户需要的，同时流出后门。然后观察用户在使用过程中利用后门所做的操作，再在API全集中添加给API，依次类推。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##问题提出  &lt;/p&gt;
&lt;p&gt;设计一个数据库的API，可供不同的WEB前端服务存储和获取数据。一些存储图像，一些存储文本、声音、图像等，如何控制API对数据的上述访问方法？  &lt;/p&gt;
&lt;p&gt;##解决方案  &lt;/p&gt;
&lt;p&gt;###1、瘦API  &lt;/p&gt;
&lt;p&gt;void 
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="Design Pattern" scheme="http://yoursite.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>代码之美读后感之《设计XML验证器之经验》</title>
    <link href="http://yoursite.com/2014/01/19/Reading-about-XML-validator/"/>
    <id>http://yoursite.com/2014/01/19/Reading-about-XML-validator/</id>
    <published>2014-01-18T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>两大基本需求：  </p>
<ul>
<li>读入XML文档进行输入验证；</li>
<li>输出验证，生成XML文档</li>
</ul>
<p>其中包括对XML的合法性检查，作者利用了JAVA中的JDOM类。</p>
<h3 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h3><ol>
<li>第一级优化：避免重复验证</li>
<li>第二级优化：将所有可能存储至一张表当中，以便进行位操作，当然提前是查找表可以一次读入内存。</li>
<li>第三级优化：引入cache,将常用的名字存入集合，其中对于小集合，利用数组即可实现，代价小于哈希表。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;两大基本需求：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读入XML文档进行输入验证；&lt;/li&gt;
&lt;li&gt;输出验证，生成XML文档&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="XML" scheme="http://yoursite.com/tags/XML/"/>
    
      <category term="代码之美" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>再谈Diffie-Hellman算法</title>
    <link href="http://yoursite.com/2014/01/15/little-about-DH/"/>
    <id>http://yoursite.com/2014/01/15/little-about-DH/</id>
    <published>2014-01-14T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在工作中又碰到了DH(Diffie-Hellman)算法，鉴于之前对该算法理解地支离破碎，因此在博文中总结归纳下。  </p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>DH算法用于在不安全的公共通道中协商密钥，安全性体现在：在有限域上计算离散代数非常困难。上两位大牛Whitfield Diffie 和 Martin Hellman的照片：  </p>
<p><img src="/assets/images/DH/DH_master.jpg" alt="图片"></p>
<p>算法描述：<br>假定Alice和Bob期望在一个不安全的网络中协商一个共同的密钥，那么进行如下步骤：</p>
<ul>
<li>两人先说好大素数（质数）p和它的原始根g。</li>
<li>Alice随机产生一个数a，并计算<code>A = p^a mod g</code>, 发送给Bob。</li>
<li>Bob随机产生一个数b，并计算B= pb mod g，发送给Alice。    </li>
</ul>
<p>此时， Alice手握Bob发过来的B，结合自己产生的a开始这样计算：</p>
<p><code>B^a mod p = (p^b mod g)^a mod p = p^ab mod g</code>。  </p>
<p>Bob也拿到了Alice发来的A，同时结合自己的b，也开始计算：</p>
<p> <code>B^a mod p = (p^b mod g)^a mod p = p^ab mod g</code>。</p>
<p>这样Alice和Bob都得到了相同的密钥。     </p>
<h3 id="DH的安全缺陷"><a href="#DH的安全缺陷" class="headerlink" title="DH的安全缺陷"></a>DH的安全缺陷</h3><p>DH不仅支持两点密钥交互，也可以支持多点密钥交互。但是DH算法本身存在安全性缺陷，即没有对交互双方进行身份验证，容易遭受中间人攻击。攻击思路具体如下：    </p>
<ul>
<li>Alice本来想发送A给Bob，被EVE截胡，EVE自己选择一个私有数c，计算出<code>C = p^c mod g</code>，发送给Bob。</li>
<li>Bob本来想发送B给Alice，也被EVE截胡，EVE再把<code>C = p^c mod g</code>发送给Alice。</li>
<li>此时，Alice和EVE计算出共同的密钥<code>K1 = p^ac mod g</code>，Bob和EVE计算出共同的密钥<code>K2 = p^bc mod g</code>。</li>
<li>Alice和Bob都以为是和对方协商好了共享密钥，于是开始发送数据，Alice用K1加密数据后发送给Bob，又被该死的EVE截胡，EVE用K1解密，不仅可以看到Alice想对Bob发送的信息，还可以修改，然后再用K2加密该篡改之后的信息，发给蒙在鼓里的Bob。Bob当然可以用K2解开，但是已经被EVE窥探甚至修改。  </li>
</ul>
<p>因此必须引入身份验证以防范此类攻击，利用RSA数字签名即可达到此目的。</p>
<h3 id="DH在TLS中的应用"><a href="#DH在TLS中的应用" class="headerlink" title="DH在TLS中的应用"></a>DH在TLS中的应用</h3><p>DH算法作为一种密钥协商机制，可以用于TLS协议当中。  </p>
<p>如果在DH交互过程中Alice和Bob始终使用相同的私钥，就会导致后续产生的共享密钥是一样的，如果有嗅探者截获通信双方的所有数据，由于都是同一个密钥加密所得，一旦被破解，后续的通信将全部暴露。</p>
<p>为了保证安全性，必须引入前向保密，即Forward Secrecy。其基本实现思路就是在Alice和Bob在选择各自的私钥是引入随机性，也印证了那句话：要用发展的眼光看问题，不能一成不变。  </p>
<p>事实上FS在诸多加密协议中应用广泛，比如IKEv2和802.11i密钥分发中的4-way握手，无一不引入此方法。</p>
<p>那么问题来了，TLS中哪一个才是最安全的cipher呢？就目前而言，最安全的三个候选者如下：  </p>
<ul>
<li><code>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P521</code></li>
<li><code>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P384</code></li>
<li><code>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P256</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在工作中又碰到了DH(Diffie-Hellman)算法，鉴于之前对该算法理解地支离破碎，因此在博文中总结归纳下。  &lt;/p&gt;
&lt;h3 
    
    </summary>
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="DH" scheme="http://yoursite.com/tags/DH/"/>
    
      <category term="TLS" scheme="http://yoursite.com/tags/TLS/"/>
    
  </entry>
  
  <entry>
    <title>无线安全之前世今生</title>
    <link href="http://yoursite.com/2014/01/10/history-of-wireless-security/"/>
    <id>http://yoursite.com/2014/01/10/history-of-wireless-security/</id>
    <published>2014-01-09T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对wireless security的发展做一个粗略介绍，从open system到WPA、WPA2和802.1X，权当做抛砖引玉~</p>
<p>注：任何一次技术变革不仅仅是技术方案的较量，更多的是市场的博弈。原文链接<a href="http://securityuncorked.com/2008/08/history-of-wireless-security/" target="_blank" rel="external">history of wireless security</a></p>
<hr>
<p>##1、Open and SKA</p>
<p>802.11在发展早期主要采用两类验证方法– Open System Association (OSA) 和Shared Key Authentication (SKA).</p>
<ul>
<li>Open = no authentication</li>
<li>Shared Key = WEP</li>
</ul>
<p>Open systems 相当于没有任何验证手段，任何人可以连接至无线网络。</p>
<p>SKA基于WEP加密，我们会在4个预共享密钥中选择一个作为所有无线站点连接AP的密钥，虽然后来WEP被发现存在安全漏洞。让我们来看看WEP何罪之有？<br>WEP本身有诸多问题，在wired介质当中是一个足够强健的算法，但是并不适合无线介质，下面是WEP的若干罪状：</p>
<ul>
<li>采用基于流的算法</li>
<li>每包重用master key </li>
<li>在AP之间采用相同的组播密钥</li>
<li>缺乏对client端的有效认证机制</li>
<li>易于遭受重放攻击和完整性攻击  </li>
</ul>
<p>##2、 从WEP的改造到WPA的崭露头角  </p>
<p>###2.1、 “i”之初创  </p>
<p>随着WEP越来越多的漏洞被发现，IEEE决定成立802.11i工作组以改进无线安全。作为一个安全网络的过渡期，WPA应运而生，其目的在于开发一个强健的安全网络。<br>802.11i工作组面临诸多困难，其中之一便是如何在仍旧使用现有硬件的基础上对WEP进行安全加密流程进行改造。作为一个过渡性解决方案，WPA在解决WEP现有不足的基础上同时考虑长期的无线安全。  </p>
<p>###2.2、 WPA与TKIP  </p>
<p>Wi-Fi联盟(Wi-Fi Alliance)的目的在于创建一个在主流厂家之间互通的安全平台；而WPA源于‘Wi-Fi Protected Access’其本身不是一个标准甚至不能称之为框架，仅仅是一个由无线厂商为达到相互之间的互通而形成的ad-hoc联合。<br>WPA作为802.11i的一个准标准，既采用了特定的密钥管理，也遵循了802.11i中的验证架构-802.1X。由于当时的硬件不支持AES算法，WPA采用TKIP((Temporal Key Integrity Protocol))作为替代算法。</p>
<p>###2.3、WPA中的密钥建立机制  </p>
<p>WPA采用PMK建立PTKs，即会话密钥，其目的在于保护每个会话。伪随机数函数PSF (pseudo-random function)确保PTKs包含nonces、MAC地址计数、时间以及随机数。密钥建立机制的重新设计目的在于最大程度地降低主密钥被窃取的可能性。见图1。  </p>
<p><img src="/assets/images/wireless_brief_fig_1.png" alt="图片">  </p>
<center>Figure 1. WEP vs WPA</center>  

<p>###2.4、WPA的其他改进点  </p>
<p>WPA在安全性方面的改进之处主要有以下几点:</p>
<ul>
<li>IV扩展至56bit（对于弱密钥可以允许8bit的密钥扩展空间）</li>
<li>采用PTKs（再一次扩展了有效的密钥空间）</li>
<li>指定IV rotation，避免了密钥重用</li>
<li>采用MICHAEL算法进行完整性校验</li>
<li>通过IEEE802.1X进行网络验证</li>
<li>增加了序列号以防止重放攻击</li>
<li>报文头和负载的完整性检查以防止重定向攻击</li>
</ul>
<p>###2.5、WPA小结<br>WPA作为一种安全架构主要包含两类组件：第一类是加密组件TKIP；第二类是验证组件，可以是PSK也可以是RADIUS。除了安全性相比WEP有提升之外，更重要的是保证了向前兼容。</p>
<p>##3、 WPA2一统天下   </p>
<p>2008年WPA的漏洞被发现，即TKIP exploit,该漏洞通过改变验证组件无法修正，唯一的解决方法是用AES替代TKIP。WPA2应运而生，这就要求硬件进行改变。TKIP可以作为WPA2的可选项。<br>802.11i和WPA2指的是同一件事情，这样一来，在现有的硬件上可以用统一的的加密方式-AES，这正是IEEE标准下所谓的强健网络。<br>作为当前无线安全的标准，802.11i/WPA2又像极了当年的WPA准标准，仅在一些细微处有所不同。随着802.11i完成最终的业界应用，现有的硬件将AES加密算法作为内置算法。<br>WPA2相比WPA有如下两大改变：</p>
<ol>
<li>AES加密算法替代WEP被内置进硬件</li>
<li>加强了完整性检查  </li>
</ol>
<p>###3.1、802.11i与802.1x     </p>
<p>802.11i采用802.1x保证密钥的建立与验证。EAPoL虽然本身是基于有线设计的，但是很容易适用于无线。802.1X相比之前的验证方法的最大不同之处在于验证过程发生在station和RADIUS server之间，而不是station和AP之间。由于AP不参与密钥产生，所以session key（由PTK导出）和每包密钥需要和AP共享，这些密钥由一个安全通道TLS传输。  </p>
<p>图2描述了多种通信流，用不同的颜色予以标记。EAPoL通信由黑色标记，而EAP握手由蓝色区分。RADIUS采用绿色，TLS则使用了橙色。从该图可以清晰地看到station、AP以及RADIUS server之间的交互流程。</p>
<p><img src="/assets/images/wireless_brief_fig_2.png" alt="图片">  </p>
<center>Figure 2. 802.1X in Wireless</center>

<p>###3.2、源自RADIUS的TLS隧道    </p>
<p>802.11i利用802.1X不仅建立密钥同时也完成了验证， 相应地，RADIUS服务器也通过该途径向client验证其自身。这条从RADIUS服务器端到客户端的隧道提供了安全通信的机制，从而保证了验证过程中的密钥交互。</p>
<p>###3.3、WPA2的安全性  </p>
<p>WPA2也同样包含两类组件，一是基于AES的加密组件，二是基于PSK或者是RADIUS的验证组件。但并不意味着WPA2就没有漏洞，比如可以通过错误配置PEAP验证组件进行攻击。</p>
<p>##4、 后记</p>
<p>尽管业界对于802.1X仍然有一些争议，但其已经成为主流的安全无线验证机制并被广泛接受。总之，802.1X囊括了安全密钥交换、密钥轮转、主密钥保护以及AES加密等，成为目前一种具有单项优势的技术。</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对wireless security的发展做一个粗略介绍，从open system到WPA、WPA2和802.1X，权当做抛砖引玉~&lt;/p&gt;
&lt;p&gt;注：任何一次技术变革不仅仅是技术方案的较量，更多的是市场的博弈。原文链接&lt;a href=&quot;http://security
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="wireless" scheme="http://yoursite.com/tags/wireless/"/>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下OpenStack配置小记</title>
    <link href="http://yoursite.com/2014/01/08/openstack-deploy-in-ubuntu1204/"/>
    <id>http://yoursite.com/2014/01/08/openstack-deploy-in-ubuntu1204/</id>
    <published>2014-01-07T16:00:00.000Z</published>
    <updated>2017-08-06T11:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文由<a href="http://skypacer210.github.io/" target="_blank" rel="external">skypacer</a>根据<a href="http://docs.openstack.org/trunk/install-guide/install/apt/content/" target="_blank" rel="external">OpenStack Installation Guide for Ubuntu 12.04 (LTS)</a>在自己的环境中实际部署情况整理而成。转载请注明出处！</p>
<p>###1、安装准备  </p>
<h4 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h4><ul>
<li>安装双网卡：通过vsphere client安装两个网卡，一个内网，一个外网。<br>修改文件/etc/network/interfaces如下：    </li>
</ul>
<pre><code>
auto lo
iface lo inet loopback 
# The primary network interface
# Internal network
auto eth0
#iface eth0 inet dhcp
iface eth0 inet static
address 10.151.122.138
netmask 255.255.255.0
gateway 10.151.122.1
dns-nameservers 10.151.122.5 10.151.120.21 10.140.2.48
dns-search wyse.com
# This is an autoconfigured IPv6 interface
iface eth0 inet6 auto

# External network
auto eth1
iface eth1 inet static
address 10.151.120.190
netmask 255.255.255.0
gateway 10.151.120.1
dns-nameservers 10.151.122.5 10.151.120.21 10.140.2.48
dns-search wyse.com  

</code></pre>  

<ul>
<li>修改host<br>修改/etc/hostname文件如下：   <pre><code>  
controller
</code></pre>     

</li>
</ul>
<p>修改/etc/hosts文件如下：  </p>
<pre><code>  
127.0.0.1       localhost
10.151.122.138  controller
10.151.122.139  compute1

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
</code></pre> 


<ul>
<li>重启网络：service networking restart  </li>
<li>测试网络：通过hostname命令检查主机名设置；通过ping检查主机解析  </li>
</ul>
<p>####1.2、安装数据库    </p>
<ul>
<li>apt-get install python-mysqldb mysql-server</li>
<li>修改/etc/mysql/my.cnf：将mysql的绑定地址改为内网IP：1<br>bind-address            = 10.151.122.138  </li>
<li>重启MYSQL：service mysql restart</li>
<li>删除匿名用户：<br><pre><code>  <h1 id="mysql-install-db"><a href="#mysql-install-db" class="headerlink" title="mysql_install_db"></a>mysql_install_db</h1><h1 id="mysql-secure-installation"><a href="#mysql-secure-installation" class="headerlink" title="mysql_secure_installation"></a>mysql_secure_installation</h1></code></pre> }</li>
</ul>
<p>####1.3、安装时间服务器  </p>
<ul>
<li>安装NTP服务器用于同步时间：apt-get install ntp</li>
<li>创建各自密码：暂时不考虑安全性，为了方便暂时保存在.bashrc中的环境变量中</li>
</ul>
<p>###2、Identity services配置</p>
<p><a id="single_res" name="single_res"> </a></p>
<p>单一责任原则，即一个类只能有一种原因去驱动改变，该原则的是同open-closed原则有异曲同工之妙：尽量避免现有代码的修改。当违反了单一原则的时候，一个模块有多种原因需要去修改。更糟的是，多个不同的责任集中于一个模块当中会耦合在一起，使得测试与修改变得非常复杂。  </p>
<p>单一责任原则本质是集中性，便于进行多层抽象，而不仅仅是一个过程上下文，简单地讲类替换为函数将有利于我们在此原则基础上分析算法。  </p>
<p>####2.1、验证机制  </p>
<p>####2.2、定义用户、租户和角色  </p>
<p>由于在/etc/keystone/keystone.conf中定义了admin_token，这是一个keystone和other openstack services的预共享密钥，在创建租户时会用到。  </p>
<ul>
<li>通过设置两个环境变量指定token和identity service运行的路径<br>export OS_SERVICE_TOKEN=ADMIN_TOKEN<br>export OS_SERVICE_ENDPOINT=<a href="http://controller:35357/v2.0" target="_blank" rel="external">http://controller:35357/v2.0</a></li>
<li>创建租户  </li>
</ul>
<p>keystone tenant-create –name=admin –description=”Admin Tenant”  </p>
<pre><code>  

+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
| description |           Admin Tenant           |
|   enabled   |               True               |
|      id     | 5e7178983104482a92433f55b09c6dcd |
|     name    |              admin               |
+-------------+----------------------------------+  
</code></pre> }

keystone tenant-create --name=service --description="Service Tenant"    

<pre><code> 
+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
| description |          Service Tenant          |
|   enabled   |               True               |
|      id     | 2b1ee1230ed34dcf9b73941f9e6b89c1 |
|     name    |             service              |
+-------------+----------------------------------+
</code></pre> }  

-    创建管理员用户  

keystone user-create --name=admin --pass=ADMIN_PASS --email=yangyongbupt168@gmail.com  

<pre><code>  
+----------+----------------------------------+
| Property |              Value               |
+----------+----------------------------------+
|  email   |    yangyongbupt168@gmail.com     |
| enabled  |               True               |
|    id    | d9308be3ba924b94ac051eb8d0750cd6 |
|   name   |              admin               |
+----------+----------------------------------+  
</code></pre> }    

-    创建角色：角色由各种OpenStack服务对应的policy.json文件指定，缺省的策略文件赋予admin角色访问大多数服务的权利。    

<pre><code> 
+----------+----------------------------------+
| Property |              Value               |
+----------+----------------------------------+
|    id    | 372478ee2d2647858d864ce9066acccd |
|   name   |              admin               |
+----------+----------------------------------+  
</code></pre> }    

-    为用户添加角色：用户总是以租户身份登录，角色通过租户被赋予给用户。例如，当用户admin以admin租户的身份登录时，赋予其admin角色。
    keystone user-role-add --user=admin --tenant=admin --role=admin    

####2.3、定义services和API endpoints  

-    为Identity services创建一个服务实体    

keystone service-create --name=keystone --type=identity --description="Keystone Identity Service"    

<pre><code>   
+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
| description |    Keystone Identity Service     |
|      id     | 7d36ad0a2c0f4ec893b1fedc95d5e9de |
|     name    |             keystone             |
|     type    |             identity             |
+-------------+----------------------------------+  
</code></pre> }    

-    利用返回的service ID（随机产生）创建API endpoint，其实就是创建内外网API等URL。

    keystone endpoint-create \
    --service-id=7d36ad0a2c0f4ec893b1fedc95d5e9de \
    --publicurl=http://controller:5000/v2.0 \
    --internalurl=http://controller:5000/v2.0 \
    --adminurl=http://controller:35357/v2.0  

<pre><code> 
+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
|   adminurl  |   http://controller:35357/v2.0   |
|      id     | 42eb21997c244fa480320fa8bd4102dc |
| internalurl |   http://controller:5000/v2.0    |
|  publicurl  |   http://controller:5000/v2.0    |
|    region   |            regionOne             |
|  service_id | 7d36ad0a2c0f4ec893b1fedc95d5e9de |
+-------------+----------------------------------+
</code></pre> }   

####2.4、验证Identity Services安装  

本质上是利用user/token验证绑定user/password的过程，期望通过user/password 查找token。  

-    删除临时环境变量

unset OS_SERVICE_TOKEN OS_SERVICE_ENDPOINT  

-    基于用户的验证：用admin的user/passord请求验证token  

keystone --os-username=admin --os-password=ADMIN_PASS \
    --os-auth-url=http://controller:35357/v2.0 token-get  

<pre><code>

+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Property |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| expires  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 2014-01-10T03:29:38Z                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|    id    | MIIC8QYJKoZIhvcNAQcCoIIC4jCCAt4CAQExCTAHBgUrDgMCGjCCAUcGCSqGSIb3DQEHAaCCATgEggE0eyJhY2Nlc3MiOiB7InRva2VuIjogeyJpc3N1ZWRfYXQiOiAiMjAxNC0wMS0wOVQwMzoyOTozOC4xNTMwNDAiLCAiZXhwaXJlcyI6ICIyMDE0LTAxLTEwVDAzOjI5OjM4WiIsICJpZCI6ICJwbGFjZWhvbGRlciJ9LCAic2VydmljZUNhdGFsb2ciOiBbXSwgInVzZXIiOiB7InVzZXJuYW1lIjogImFkbWluIiwgInJvbGVzX2xpbmtzIjogW10sICJpZCI6ICJkOTMwOGJlM2JhOTI0Yjk0YWMwNTFlYjhkMDc1MGNkNiIsICJyb2xlcyI6IFtdLCAibmFtZSI6ICJhZG1pbiJ9LCAibWV0YWRhdGEiOiB7ImlzX2FkbWluIjogMCwgInJvbGVzIjogW119fX0xggGBMIIBfQIBATBcMFcxCzAJBgNVBAYTAlVTMQ4wDAYDVQQIDAVVbnNldDEOMAwGA1UEBwwFVW5zZXQxDjAMBgNVBAoMBVVuc2V0MRgwFgYDVQQDDA93d3cuZXhhbXBsZS5jb20CAQEwBwYFKw4DAhowDQYJKoZIhvcNAQEBBQAEggEAAS-Fdhv74-kaGYHDuVnJo3ZHhfQ0sdXtdJE68V86gB3TnRMBvDizYaaBlUEDkVLEsOTf-SwO+2fVDnEQ82eARFwXi5RgGUW-rSPX-DU9iJob0ajc4Pn7tRioEzjUByON+8kYge7V5hmowc4e+qM7vvbUcLkTC3eKkF4b4xNg7JSCEMeRCIPSDlqOR3a-S5jODUSdQlfkcZyjocQjcQdaEBW8Rm+bv4TTVYi2PotbqoZQHGvVPg45cjeFnLFSs9XVCkFMx9rUgXmj4+FdV61t6wH0goJ5LriIHKOlKD0dp6V8RX0p1hpmFoD1dI+yDFD68dmmUV5t6gtluyZA5dJNBw== |
| user_id  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           d9308be3ba924b94ac051eb8d0750cd6                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

</code></pre> }   



这是一个包含用户ID的token paired。  

keystone --os-username=admin --os-password=ADMIN_PASS \
    --os-tenant-name=admin --os-auth-url=http://controller:35357/v2.0 token-get  

<pre><code>

+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|  Property |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|  expires  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           2014-01-10T03:41:25Z                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|     id    | MIIEsgYJKoZIhvcNAQcCoIIEozCCBJ8CAQExCTAHBgUrDgMCGjCCAwgGCSqGSIb3DQEHAaCCAvkEggL1eyJhY2Nlc3MiOiB7InRva2VuIjogeyJpc3N1ZWRfYXQiOiAiMjAxNC0wMS0wOVQwMzo0MToyNS45NjI4MzUiLCAiZXhwaXJlcyI6ICIyMDE0LTAxLTEwVDAzOjQxOjI1WiIsICJpZCI6ICJwbGFjZWhvbGRlciIsICJ0ZW5hbnQiOiB7ImRlc2NyaXB0aW9uIjogIkFkbWluIFRlbmFudCIsICJlbmFibGVkIjogdHJ1ZSwgImlkIjogIjVlNzE3ODk4MzEwNDQ4MmE5MjQzM2Y1NWIwOWM2ZGNkIiwgIm5hbWUiOiAiYWRtaW4ifX0sICJzZXJ2aWNlQ2F0YWxvZyI6IFt7ImVuZHBvaW50cyI6IFt7ImFkbWluVVJMIjogImh0dHA6Ly9jb250cm9sbGVyOjM1MzU3L3YyLjAiLCAicmVnaW9uIjogInJlZ2lvbk9uZSIsICJpbnRlcm5hbFVSTCI6ICJodHRwOi8vY29udHJvbGxlcjo1MDAwL3YyLjAiLCAiaWQiOiAiNzMzOWEwZDY1NDBlNGM0MGI4YWE4NGI1NDEzODNlMTYiLCAicHVibGljVVJMIjogImh0dHA6Ly9jb250cm9sbGVyOjUwMDAvdjIuMCJ9XSwgImVuZHBvaW50c19saW5rcyI6IFtdLCAidHlwZSI6ICJpZGVudGl0eSIsICJuYW1lIjogImtleXN0b25lIn1dLCAidXNlciI6IHsidXNlcm5hbWUiOiAiYWRtaW4iLCAicm9sZXNfbGlua3MiOiBbXSwgImlkIjogImQ5MzA4YmUzYmE5MjRiOTRhYzA1MWViOGQwNzUwY2Q2IiwgInJvbGVzIjogW3sibmFtZSI6ICJhZG1pbiJ9XSwgIm5hbWUiOiAiYWRtaW4ifSwgIm1ldGFkYXRhIjogeyJpc19hZG1pbiI6IDAsICJyb2xlcyI6IFsiMzcyNDc4ZWUyZDI2NDc4NThkODY0Y2U5MDY2YWNjY2QiXX19fTGCAYEwggF9AgEBMFwwVzELMAkGA1UEBhMCVVMxDjAMBgNVBAgMBVVuc2V0MQ4wDAYDVQQHDAVVbnNldDEOMAwGA1UECgwFVW5zZXQxGDAWBgNVBAMMD3d3dy5leGFtcGxlLmNvbQIBATAHBgUrDgMCGjANBgkqhkiG9w0BAQEFAASCAQA3-Ce1g6lmH707ibg+NDRTn2xiTds9SkWUvpHNTPSDvbnW5-eoSSE+Ty7EVMb5XFkCZlDYHHKuDRfdG9reFfQq9qVcXzS4R8FAxJF8V9Nfx4z76l1yGyZxRbn566uKPYc2BUlp3ZydeP7eX+k54GCNkPj+dMgCcr4weSCfuIXaVejKVsKaz1fJu7AmypeDa24fTjseJUTzqUNkCLp4+RkVMsb2SaQDgNSSJf890m+TB70zPJN63IasJvH8DnAzZ2G2F2MIw+zBAQ7kTl7lskRKOGVtUIZxxxb8TGWP+Y34VrAHLoUoXsP+fQhIlv-dKfuNt5qoWe0AlnBkrwQl3HK1 |
| tenant_id |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     5e7178983104482a92433f55b09c6dcd                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|  user_id  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     d9308be3ba924b94ac051eb8d0750cd6                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

</code></pre> }   


期望返回一绑定租户的token。  


-    脚本操作：上述手动操作的替代方法  

<pre><code> 
#!/bin/bash

export OS_USERNAME=admin
export OS_PASSWORD=ADMIN_PASS
export OS_TENANT_NAME=admin
export OS_AUTH_URL=http://controller:35357/v2.0  

</code></pre> }   

-    确保admin账户已经被验证

keystone user-list

<pre><code> 
+----------------------------------+-------+---------+---------------------------+
|                id                |  name | enabled |           email           |
+----------------------------------+-------+---------+---------------------------+
| d9308be3ba924b94ac051eb8d0750cd6 | admin |   True  | yangyongbupt168@gmail.com |
+----------------------------------+-------+---------+---------------------------+
</code></pre> 

<p>###3、OpenStack clients安装与配置  </p>
<p>通过命令行客户端进行API调用，可以设置在脚本中自动执行。在OpenStack内部，可以运行cURL命令执行内嵌API请求。OpenStack是一种基于HTTP协议REST风格的API，包括方法、URI、介质类型和响应代码。<br>每个Openstack服务都有自己的命令行客户端。</p>
<p>####3.1、基于python的开源客户端  </p>
<ul>
<li>ceilometer：度量openStack</li>
<li>cinder：创建和管理volume</li>
<li>glance:创建和管理图片</li>
<li>heat：从模板登录和管理stack</li>
<li>keystone:创建管理用户、租户、角色和密钥等</li>
<li>neutron：为客户端server配置网络</li>
<li>nova：管理图片、句柄和flavors</li>
<li>swift：统计Object Storage服务的元数据</li>
<li>充电</li>
</ul>
<p>###4、验证Identity Services安装     </p>
<p>####4.1、安装Image Service  </p>
<ul>
<li>注册Image服务和Identity服务，这样其他的OpenStack服务可以定位到它  </li>
</ul>
<p>keystone service-create –name=glance –type=image \<br>    –description=”Glance Image Service”</p>
<pre><code> 
+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
| description |       Glance Image Service       |
|      id     | 21b15dc9b1d846149883e953af08d906 |
|     name    |              glance              |
|     type    |              image               |
+-------------+----------------------------------+
</code></pre>  

<ul>
<li>利用serveice id创建endpoint</li>
</ul>
<p>keystone endpoint-create –service-id=21b15dc9b1d846149883e953af08d906 –publicurl=<a href="http://controller:9292" target="_blank" rel="external">http://controller:9292</a> –internalurl=<a href="http://controller:9292" target="_blank" rel="external">http://controller:9292</a> \<br>    –adminurl=<a href="http://controller:9292" target="_blank" rel="external">http://controller:9292</a></p>
<pre><code> 
+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
|   adminurl  |      http://controller:9292      |
|      id     | 9cf77dd344514215812b1391dbf2b498 |
| internalurl |      http://controller:9292      |
|  publicurl  |      http://controller:9292      |
|    region   |            regionOne             |
|  service_id | 21b15dc9b1d846149883e953af08d906 |
+-------------+----------------------------------+
</code></pre>  

<p>####4.2、安装Image Service</p>
<p>验证安装：  </p>
<ul>
<li>上传Image</li>
</ul>
<p>root@controller:/home/fyang/project/images# glance image-create –name=”CirrOS 0.3.0” –disk-format=qcow2 –container-format=bare –is-public=true &lt; cirros-0.3.0-x86_64-disk.img   </p>
<p>root@controller:/home/fyang/project/images# glance image-create –name=”CirrOS 0.3.0” –disk-format=qcow2 –container-format=bare –is-public=true &lt; cirros-0.3.0-x86_64-disk.img  </p>
<ul>
<li>显示Image列表  </li>
</ul>
<p>glance image-list</p>
<pre><code> 
+--------------------------------------+--------------+-------------+------------------+---------+--------+
| ID                                   | Name         | Disk Format | Container Format | Size    | Status |
+--------------------------------------+--------------+-------------+------------------+---------+--------+
| 59c63869-ce77-4647-90b5-782d258e3354 | CirrOS 0.3.0 | qcow2       | bare             | 9761280 | active |
| 05f2ae82-0926-4b8a-9d11-dfc99d8ee845 | CirrOS 0.3.1 | qcow2       | bare             | 9761280 | active |
+--------------------------------------+--------------+-------------+------------------+---------+--------+
</code></pre>  

<p>###5、计算控制服务安装与配置  </p>
<p>####5.1、概述  </p>
<p>####5.1、安装Image Service  </p>
<ul>
<li>创建计算服务表：</li>
</ul>
<p>nova-manage db sync  </p>
<pre><code>
    2014-01-09 17:45:46.814 7918 INFO migrate.versioning.api [-] 215 -> 216... 
2014-01-09 17:45:46.837 7918 INFO migrate.versioning.api [-] done
</code></pre>  

<ul>
<li>创建用户</li>
</ul>
<p>keystone user-create –name=nova –pass=NOVA_PASS –email=nova@example.</p>
<pre><code>
+----------+----------------------------------+
| Property |              Value               |
+----------+----------------------------------+
|  email   |          nova@example.           |
| enabled  |               True               |
|    id    | 26e1951aa2264a11800c68cc58dbce59 |
|   name   |               nova               |
+----------+----------------------------------+
</code></pre>  

<ul>
<li>充电</li>
</ul>
<p>root@controller:/home/fyang/project/images# keystone service-create –name=nova –type=compute –description=”Nova Compute service”  </p>
<pre><code>
+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
| description |       Nova Compute service       |
|      id     | 0d67dd130ebc4de2ba8e54ac241e92d0 |
|     name    |               nova               |
|     type    |             compute              |
+-------------+----------------------------------+

</code></pre>  

<ul>
<li>创建endpoint</li>
</ul>
<p>root@controller:/home/fyang/project# keystone endpoint-create –service-id=0d67dd130ebc4de2ba8e54ac241e92d0 –publicurl=<a href="http://controller:8774/v2/%\(tenant_id\)s" target="_blank" rel="external">http://controller:8774/v2/%\(tenant_id\)s</a> –internalurl=<a href="http://controller:8774/v2/%\(tenant_id\)s" target="_blank" rel="external">http://controller:8774/v2/%\(tenant_id\)s</a> –adminurl=<a href="http://controller:8774/v2/%\(tenant_id\)s" target="_blank" rel="external">http://controller:8774/v2/%\(tenant_id\)s</a>  </p>
<pre><code>
+-------------+-----------------------------------------+
|   Property  |                  Value                  |
+-------------+-----------------------------------------+
|   adminurl  | http://controller:8774/v2/%(tenant_id)s |
|      id     |     21f036edca9547e196b5976a4c31f561    |
| internalurl | http://controller:8774/v2/%(tenant_id)s |
|  publicurl  | http://controller:8774/v2/%(tenant_id)s |
|    region   |                regionOne                |
|  service_id |     0d67dd130ebc4de2ba8e54ac241e92d0    |
+-------------+-----------------------------------------+  
</code></pre>  
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文由&lt;a href=&quot;http://skypacer210.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;skypacer&lt;/a&gt;根据&lt;a href=&quot;http://docs.openstack.org/trunk/install-
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="deploy" scheme="http://yoursite.com/tags/deploy/"/>
    
      <category term="openstack" scheme="http://yoursite.com/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>REACTOR设计模式C实现</title>
    <link href="http://yoursite.com/2014/01/02/patterns-in-c-reactor/"/>
    <id>http://yoursite.com/2014/01/02/patterns-in-c-reactor/</id>
    <published>2014-01-01T16:00:00.000Z</published>
    <updated>2017-08-06T11:29:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文由<a href="http://skypacer210.github.io/" target="_blank" rel="external">skypacer</a>译自<a href="http://www.adampetersen.se/Patterns%20in%20C%205,%20REACTOR.pdf" target="_blank" rel="external">Patterns in C REACTOR</a>，原文作者<a href="http://www.adampetersen.se/" target="_blank" rel="external">Adam Petersen</a>。转载请注明出处！</p>
<h2 id="小引"><a href="#小引" class="headerlink" title="##小引"></a>##小引</h2><p>本篇英文原文所发布的站点<a href="http://www.adampetersen.se/" target="_blank" rel="external">Adam Petersen</a>是一个个人网站，本文翻译的是其中的关于设计模式C实现的文章，本章主题是reactor模式。</p>
<p>首次正式翻译文章，水平有限，欢迎指正。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="##目录"></a>##目录</h2><p>1、<a href="#mutil_client">多客户端示例</a><br>2、<a href="#single_res">单一责任原则</a><br>3、<a href="#open_closed">违反Open-Closed原则</a><br>4、<a href="#performance">从性能谈起</a><br>5、<a href="#issue_sum">问题总结</a><br>6、<a href="#reactor_pattern">REACTOR模式</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.1、<a href="#6.1">事件探测</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.2、<a href="#6.2">实现机制</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.3、<a href="#6.3">Reactor注册策略</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.4、<a href="#6.4">Reactor实现</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.5、<a href="#6.5">触发Reactor</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.6、<a href="#6.6">处理注册</a><br>&nbsp;&nbsp;&nbsp;&nbsp;6.7、<a href="#6.7">事件多样性</a><br>7、<a href="#vs">REACTOR vs OBSERVER</a><br>8、<a href="#cons">结论</a><br>9、<a href="#sum">总结</a>            </p>
<h2 id="正文"><a href="#正文" class="headerlink" title="##正文"></a>##正文</h2><p><a id="mutil_client" name="mutil_client"> </a>  </p>
<p>本文将研究一种适用于<em>event-driven</em>应用的模式。Reactor Pattern将应用的不同职责解耦，允许应用由多个潜在的client端分离并分发事件。</p>
<p>###1、多客户端示例</p>
<p>为了简化对大系统的维护，工程师可以单独搜集子系统的诊断信息然后再合并至中心。每个子系统利用TCP/IP连接至诊断服务器，由于TCP/IP是一个面向连接的协议，客户端（不同的子系统）不得不单独向server请求相应的连接。一旦连接建立，client可以随时发送诊断信息。  </p>
<p>为了解决这个问题，最容易想到的方法就是服务器依次扫描客户端的连接请求和诊断信息，如下图所示：      </p>
<p><img src="/assets/images/reactor_figure_1.png" alt="图片">  </p>
<center>Figure 1: eternal loop to scan for different events</center>

<p>尽管这是一个极其简化的例子，这里仍然存在不少潜在的问题。首先是该方法将应用逻辑、网络代码、事件分发代码这几个毫不相干的逻辑捆绑在一起，会带来严重的维护、测试和可扩展问题，这样的设计违反了基本的设计原则。  </p>
<p><a id="mutil_client" name="mutil_client"> </a>    </p>
<p>###2、单一责任原则</p>
<p><a id="single_res" name="single_res"> </a></p>
<p>单一责任原则，即一个类只能有一种原因去驱动改变，该原则的是同open-closed原则有异曲同工之妙：尽量避免现有代码的修改。当违反了单一原则的时候，一个模块有多种原因需要去修改。更糟的是，多个不同的责任集中于一个模块当中会耦合在一起，使得测试与修改变得非常复杂。  </p>
<p>单一责任原则本质是集中性，便于进行多层抽象，而不仅仅是一个过程上下文，简单地讲类替换为函数将有利于我们在此原则基础上分析算法。  </p>
<p>###3、违反Open-Closed原则</p>
<p><a id="open_closed" name="open_closed"> </a>  </p>
<p>如果违反了Open-Closed原则，上述例子的模块将变得难以维护，或者该代码在设计之初就没打算扩展性。不幸的是，该中设计已经违反了Open-Closed原则，若不改变现有代码，新的功能将无法加入。总而言之，这种设计使得修改代码变得代价高昂。  </p>
<p>###4、从性能谈起  </p>
<p><a id="performance" name="performance"> </a>  </p>
<p>这种方案的糟糕之处还在于整个系统的性能变得很差，当线性扫描所有事件时，尽快采用了超时机制，然而很多时间被白白浪费了。  </p>
<p>一个潜在的性能问题就是并发失败的处理，一种解决方案是引入多线程，诊断服务器轮询事件，但是此时的轮询代价已经只剩下处理连接请求，一旦请求建立，分配相应的线程处理该连接上的所有消息处理。  </p>
<p>然后多线程方案无法从根本上解决这种设计的问题：违反了单一责任原则和Open-Closed原则。尽管扫描代码和诊断消息处理从主循环中移除，添加一个新的服务端口仍需修改现有代码。  </p>
<p>从设计的角度看，线程不能改变任何事情，事实上，即使考虑到性能，这种改进导致上下文切换和同步，反而比单线程方法更糟。</p>
<p>###5、问题总结  </p>
<p><a id="issue_sum" name="issue_sum"> </a>  </p>
<p>总结以上的经验，我们发现上述设计方南的失败之处归结于它们以三种责任为解决前提。问题即违反了Open-Closed原则，导致难于修改现有代码。  </p>
<p>理想的解决方案应该是易于扩展、封装和多种责任解耦，并能够同时服务多个客户端，即使不引入多线程。Reactor模式通过在事件处理中封装应用逻辑和在事件分发中隔离代码很好的解决了这些问题。  </p>
<p>###6、REACTOR模式  </p>
<p><a id="reactor_pattern" name="reactor_pattern"> </a>  </p>
<p>Reactor模式定义：“reactor架构使得事件驱动型的不同应用实现分离，并将来自一个或多个客户端的服务请求分发至一个应用中”。  </p>
<p><img src="/assets/images/reactor_figure_2.png" alt="图片"></p>
<center>Figure 2: Structure of the REACTOR pattern</center>   

<p>其中包含的参与者如下：  </p>
<ul>
<li><strong>EventHandler</strong>：一个EventHandler定义了一个接口，该接口由处理事件的模块实现，每个EventHandler有自己的Handle。  </li>
<li><strong>Handle</strong>：<strong>Handle</strong> 本质是reactor模式在OS上实现的具体句柄，例如，<strong>handle</strong>  包含了像文件、socket和timer等系统资源。</li>
<li><strong>DiagnosticsServer</strong> and <strong>DiagnosticsClient</strong>: 这是两种具体的事件handler，每个独立封装一个责任，为了能够接受事件通知，这些具体的事件handlers必须在 <strong>Reactor</strong> 中进行注册。</li>
<li><strong>Reactor</strong>：<strong>Reactor</strong> 维护 <strong>EventHandler</strong> 的注册，并取出相应的 <strong>Handles</strong>. <strong>Reactor</strong> 等待已经注册 <strong>handles</strong> 中的事件，当 <strong>Handle</strong> 通知事件发生时，触发相应的 <strong>EventHandler</strong> 。</li>
</ul>
<p>####6.1、事件探测  </p>
<p><a id="6.1" name="6.1"> </a>  </p>
<p>在一些文献中关于 <strong>reactor</strong> 的描述中，定义了一个工具，即 <strong>synchronous Event Demultiplexer </strong>， 该分离器由 <strong>reactor</strong> 调用等待已经注册的 <strong>Handles</strong> 的事件。 </p>
<p>该事件分离器一般由操作系统提供，比如 <em>poll()</em> ，<em>select()</em> 和 <em>WaitForMutipleObjects()</em> 。</p>
<p>####6.2、实现机制  </p>
<p><a id="6.2" name="6.2"> </a>    </p>
<p><strong>EventHandler</strong> 和 <strong>Reactor</strong> 之间的合作关系类似OBSERVER模式中的observer和它的对象。    </p>
<p>为了将Reactor和它的事件处理器解耦，同时Reactor仍能够通知到他们，每个具体的事件处理器必须关联一个唯一的instance。这里的C实现中，采用void <em>作为通用类型以描述 <em>*EventHandler</em></em> 接口。  </p>
<ul>
<li>事件处理接口：EventHandler.h  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">14 #ifndef EVENT_HANDLER_H</div><div class="line">15 #define EVENT_HANDLER_H</div><div class="line">16 </div><div class="line">17 #include &quot;Handle.h&quot;</div><div class="line">18 </div><div class="line">19 /* All interaction from Reactor to an event handler goes </div><div class="line">20 through function pointers with the following signatures: */</div><div class="line">21 typedef Handle (*getHandleFunc)(void *instance);</div><div class="line">22 typedef void (*handleEventFunc)(void *instance);</div><div class="line">23 </div><div class="line">24 typedef struct &#123;</div><div class="line">25 .       void *instance;</div><div class="line">26 .       getHandleFunc getHandle;</div><div class="line">27 .       handleEventFunc handleEvent;</div><div class="line">28 &#125; EventHandler;</div><div class="line">29 </div><div class="line">30 #endif</div></pre></td></tr></table></figure>
<ul>
<li>Reactor注册接口：ractor.h  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> 14 #ifndef REACTOR_H</div><div class="line"> 15 #define REACTOR_H</div><div class="line"> 16 </div><div class="line"> 17 #include &quot;EventHandler.h&quot;</div><div class="line"> 18 </div><div class="line"> 19 void Register(EventHandler* handler);</div><div class="line"> 20 void Unregister(EventHandler* handler);</div><div class="line"> 21 </div><div class="line"> 22 #endif</div><div class="line">```  </div><div class="line"></div><div class="line">-	具体的事件处理器：DiagnosticsServer.c</div></pre></td></tr></table></figure>
<p> 14 /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br> 15 <em> A simulation of a diagnostics server.<br> 16 </em><br> 17 <em> A client that wants to log a diagnostic connects to this server using TCP/IP.<br> 18 </em> The server gets notified about a connecting client through the Reactor.<br> 19 <em> Upon such a notification, the server creates a client representation.<br> 20 <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>/<br> 21<br> 22 #include “base.h”<br> 23 #include “DiagnosticsServer.h”<br> 24 #include “DiagnosticsClient.h”<br> 25 #include “EventHandler.h”<br> 26 #include “ServerEventNotifier.h”<br> 27 #include “Reactor.h”<br> 28<br> 29 #include “Error.h”<br> 30 #include “TcpServer.h”<br> 31<br> 32 #define MAX_NO_OF_CLIENTS 10<br> 33<br> 34 struct DiagnosticsServer {<br> 35 .       Handle listeningSocket;<br> 36 .       EventHandler eventHandler;<br> 37<br> 38 .       /<em> All connected clients able to send diagnostics messages. </em>/<br> 39 .       DiagnosticsClientPtr clients[MAX_NO_OF_CLIENTS];<br> 40 };<br> 41<br> 42 /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br> 43 <em> Function declarations.<br> 44 <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br> 45<br> 46 static void deleteAllClients(DiagnosticsServerPtr server);<br> 47<br> 48 static int matchControlledClientByPointer(const DiagnosticsServerPtr server, const DiagnosticsClientPtr clientToMatch);<br> 49<br> 50 static int findFreeClientSlot(const DiagnosticsServerPtr server);<br> 51<br> 52 static int findMatchingClientSlot(const DiagnosticsServerPtr server, const DiagnosticsClientPtr client);<br> 53<br> 54 static Handle getServerSocket(void</em> instance);<br> 55<br> 56 static void handleConnectRequest(void<em> instance);<br> 57<br> 58 static void onClientClosed(void</em> server, void<em> closedClient);<br> 59<br> 60 /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br> 61 </em> Implementation of the EventHandler interface.<br> 62 <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br> 63<br> 64 static Handle getServerSocket(void<em> instance)<br> 65 {<br> 66    const DiagnosticsServerPtr server = instance;<br> 67    return server-&gt;listeningSocket;<br> 68 }<br> 69<br> 70 static void handleConnectRequest(void</em> instance)<br> 71 {<br> 72 .       DiagnosticsServerPtr server = instance;<br> 73<br> 74 .       const int freeSlot = findFreeClientSlot(server);<br> 75<br> 76 .       if(0 &lt;= freeSlot) {<br> 77 .       .       /<em> Define a callback for events requiring the actions of the server (for example<br> 78 .       .          a closed connection). </em>/<br> 79 .       .       ServerEventNotifier eventNotifier = {0};<br> 80 .       .       eventNotifier.server = server;<br> 81 .       .       eventNotifier.onClientClosed = onClientClosed;<br> 82<br> 83 .       .       server-&gt;clients[freeSlot] = createClient(server-&gt;listeningSocket, &amp;eventNotifier);<br> 84<br> 85 .       .       ne_debug(REACTOR_DEBUG, “Server: Incoming connect request accepted\n”);<br> 86 .       }<br> 87 .       else {<br> 88 .       .       ne_debug(REACTOR_DEBUG, “Server: Not space for more clients\n”);<br> 89 .       }<br> 90 }<br> 91<br> 92 /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br> 93 <em> Implementation of the ServerEventNotifier interface.<br> 94 <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br> 95<br> 96 /**<br> 97 </em> This function is invoked as a callback from the client representation<br> 98 <em> in case it detects a disconnect on TCP level.<br> 99 </em>/<br>100 static void onClientClosed(void<em> server,<br>101 .       .       void</em> closedClient)<br>102 {<br>103 .       DiagnosticsServerPtr serverInstance = server;<br>104 .       DiagnosticsClientPtr clientInstance = closedClient;<br>105<br>106 .       const int clientSlot = findMatchingClientSlot(serverInstance, clientInstance);<br>107<br>108 .       if(0 &gt; clientSlot) {<br>109 .       .       ne_debug(REACTOR_DEBUG, “Phantom client detected\n”);<br>110 .       .       return;<br>111 .       }<br>112<br>113 .       destroyClient(clientInstance);<br>114<br>115 .       serverInstance-&gt;clients[clientSlot] = NULL;<br>116 }<br>117<br>118 /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>119 <em> Implementation of the ADT functions of the server.<br>120 <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br>121<br>122 /**<br>123 </em> Creates a server listening for connect requests on the given port.<br>124 <em> The server registers itself at the Reactor upon creation.<br>125 </em>/<br>126 DiagnosticsServerPtr createServer(unsigned int tcpPort)<br>127 {<br>128 .       DiagnosticsServerPtr newServer = malloc(sizeof <em>newServer);<br>129<br>130 .       if(NULL != newServer) {<br>131 .       .       int i = 0;<br>132<br>133 .       .       for(i = 0; i &lt; MAX_NO_OF_CLIENTS; ++i) {<br>134 .       .       .       newServer-&gt;clients[i] = NULL;<br>135 .       .       }<br>136<br>137 .       .       newServer-&gt;listeningSocket = createServerSocket(tcpPort);<br>138 .       .       if (newServer-&gt;listeningSocket &lt; 0) {<br>139 .       .       .       ne_debug(REACTOR_DEBUG, “fail create sock=%d.\n”, newServer-&gt;listeningSocket);<br>140 .       .       .       return NULL;<br>141 .       .       }<br>142<br>143 .       .       /</em> Successfully created -&gt; register the listening socket. <em>/<br>144 .       .       newServer-&gt;eventHandler.instance = newServer;<br>145 .       .       newServer-&gt;eventHandler.getHandle = getServerSocket;<br>146 .       .       newServer-&gt;eventHandler.handleEvent = handleConnectRequest;<br>147<br>148 .       .       Register(&amp;newServer-&gt;eventHandler);<br>149 .       .       ne_debug(REACTOR_DEBUG, “register event sock=%d.\n”, newServer-&gt;listeningSocket);<br>150 .       }<br>151<br>152 .       return newServer;<br>153 }<br>154<br>155 /**<br>156 </em> Unregisters at the Reactor and deletes all connected clients<br>157 <em> before the server itself is disposed.<br>158 </em> After completion of this function, the server-handle is invalid.<br>159 <em>/<br>160 void destroyServer(DiagnosticsServerPtr server)<br>161 {<br>162 .       deleteAllClients(server);<br>163<br>164 .       /</em> Before deleting the server we have to unregister at the Reactor. <em>/<br>165 .       Unregister(&amp;server-&gt;eventHandler);<br>166<br>167 .       disposeServerSocket(server-&gt;listeningSocket);<br>168 .       free(server);<br>169 }<br>170<br>171 /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>172 </em> Definition of the local utility functions.<br>173 <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br>174<br>175 static void deleteAllClients(DiagnosticsServerPtr server)<br>176 {<br>177 .       int i = 0;<br>178<br>179 .       for(i = 0; i &lt; MAX_NO_OF_CLIENTS; ++i) {<br>180 .       .       if(NULL != server-&gt;clients[i]) {<br>181 .       .       .       destroyClient(server-&gt;clients[i]);<br>182 .       .       }<br>183 .       }<br>184 }<br>185<br>186 /<em>*<br>187 </em> Returns the index where a client matching the given pointer is found.<br>188 <em> Returns -1 if no match was found.<br>189 </em>/<br>190 static int matchControlledClientByPointer(const DiagnosticsServerPtr server,<br>191 .       .       const DiagnosticsClientPtr clientToMatch)<br>192 {<br>193 .       int clientSlot = -1;<br>194 .       int slotFound = 0;<br>195 .       int i = 0;<br>196<br>197 .       for(i = 0; (i &lt; MAX_NO_OF_CLIENTS) &amp;&amp; (0 == slotFound); ++i) {<br>198<br>199 .       .       if(clientToMatch == server-&gt;clients[i]) {<br>200 .       .       .       clientSlot = i;<br>201 .       .       .       slotFound = 1;<br>202 .       .       }<br>203 .       }<br>204<br>205 .       return clientSlot;<br>206 }<br>207<br>208 static int findFreeClientSlot(const DiagnosticsServerPtr server)<br>209 {<br>210 .       return matchControlledClientByPointer(server, NULL);<br>211 }<br>212<br>213 static int findMatchingClientSlot(const DiagnosticsServerPtr server,<br>214 .       .       const DiagnosticsClientPtr client)<br>215 {<br>216 .       return matchControlledClientByPointer(server, client);<br>217 }<br>                                                                                                                                                                                                                                                                                                         <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line"></div><div class="line">####6.3、Reactor注册策略</div><div class="line"></div><div class="line">&lt;a id=&apos;6.3&apos; name=&apos;6.3&apos;&gt; &lt;/a&gt;  </div><div class="line">  </div><div class="line">当实现具体的事件处理器时定义抽象数据结构，这样做的好处是封装具体的注册处理细节，这样就隐藏了具体的信息，client甚至无需了解如何同reactor交互。  </div><div class="line"></div><div class="line">Reactor的另外一个好处体现在server内部，比如说对handle的封装通过getServerSocket获得，这样我们为reactor提供一个方式获取handle；同时，reactor对事件处理器进行访问控制：只有注册的事件处理器方可被调用相应的handle及其相关资源。  </div><div class="line"></div><div class="line"></div><div class="line">####6.4、Reactor实现  </div><div class="line"></div><div class="line">&lt;a id=&apos;6.4&apos; name=&apos;6.4&apos;&gt; &lt;/a&gt;  </div><div class="line"></div><div class="line">Reactor的实现依赖于具体的同步事件分发器，如果OS提供了多种同步事件分发器，比如select()和poll()，Reactor就需要针对这些分发器实现多个reactor实例，并由链接器根据问题选择，即所谓的链接多态。  </div><div class="line"></div><div class="line">每种Reactor的实现必须确定该应用下所需要的reactor实例。在多数场景中，应用只需一个reactor实例，即single reactor。如果应用需要多个reactor实例，则可以对reactor本身进行抽象。  </div><div class="line"></div><div class="line">为了独立于具体的分离机制，Reactor必须维护一个已注册具体的事件处理器集合。简单地做法就是采用数组，适用于最大的客户端数目已知的情形。  </div><div class="line"></div><div class="line"></div><div class="line">基于Poll()实现的Reactor：PollReactor.c</div></pre></td></tr></table></figure></p>
<p>19 #include “base.h”<br> 20 #include “Reactor.h”<br> 21 #include “ReactorEventLoop.h”<br> 22<br> 23 #include “Error.h”<br> 24<br> 25 #include <sys poll.h=""><br> 26 #define POLLRDNORM      0x0040          /<em> non-OOB/URG data available </em>/<br> 27<br> 28 #include <assert.h><br> 29 #include <stddef.h><br> 30 #include <stdio.h><br> 31<br> 32 #define MAX_NO_OF_HANDLES 32<br> 33<br> 34 /<em> POSIX requires <poll.h> to define INFTIM.<br> 35    However, in my environment it doesn’t -&gt; follow the recommendations by Mr. Stevens.<br> 36 </poll.h></em>/<br> 37 #ifndef INFTIM<br> 38 #define INFTIM -1<br> 39 #endif<br> 40<br> 41 /<em> Bind an event handler to the struct used to interface poll(). </em>/<br> 42 typedef struct<br> 43 {<br> 44    int isUsed;<br> 45    EventHandler handler;<br> 46    struct pollfd fd;<br> 47 } HandlerRegistration;<br> 48<br> 49 static HandlerRegistration registeredHandlers[MAX_NO_OF_HANDLES];<br> 50<br> 51 /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br> 52 <em> Function declarations.<br> 53 <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br> 54<br> 55 /</em> Add a copy of the given handler to the first free position in registeredHandlers. <em>/<br> 56 static int addToRegistry(EventHandler</em> handler);<br> 57<br> 58 /<em> Identify the event handler in the registeredHandlers and remove it. </em>/<br> 59 static int removeFromRegistry(EventHandler<em> handler);<br> 60<br> 61 /</em> Add a copy of all registered handlers to the given array. <em>/<br> 62 static size_t buildPollArray(struct pollfd</em> fds);<br> 63<br> 64 /<em> Identify the event handler corresponding to the given descriptor in the registeredHandlers. </em>/<br> 65 static EventHandler<em> findHandler(int fd);<br> 66<br> 67 /</em> Detect all signalled handles and invoke their corresponding event handlers. <em>/<br> 68 static void dispatchSignalledHandles(const struct pollfd</em> fds, size_t noOfHandles);<br> 69<br> 70 /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br> 71 <em> Implementation of the Reactor interface used for registrations.<br> 72 <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>/<br> 73<br> 74 void Register(EventHandler<em> handler)<br> 75 {<br> 76 .       assert(NULL != handler);<br> 77<br> 78 .       if(!addToRegistry(handler)) {<br> 79 .       .       /</em> NOTE: In production code, this error should be delegated to the client instead. <em>/<br> 80 .       .       ne_debug(REACTOR_DEBUG, “No more registrations possible\n”);<br> 81 .       .       return;<br> 82 .       }<br> 83 }<br> 84<br> 85 void Unregister(EventHandler</em> handler)<br> 86 {<br> 87 .       assert(NULL != handler);<br> 88<br> 89 .       if(!removeFromRegistry(handler)) {<br> 90 .       .       /<em> NOTE: In production code, this error should be delegated to the client instead. </em>/<br> 91 .       .       ne_debug(REACTOR_DEBUG,”Event handler not registered\n”);<br> 92 .       .       return;<br> 93 .       }<br> 94 }<br> 95<br> 96 /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br> 97 <em> Implementation of the reactive event loop<br> 98 </em> (interface separated in ReactorEventLoop.h).<br> 99 <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br>100<br>101 void HandleEvents(void)<br>102 {<br>103 .       /<em> Build the array required to interact with poll().</em>/<br>104 .       struct pollfd fds[MAX_NO_OF_HANDLES] = {0};<br>105<br>106 .       const size_t noOfHandles = buildPollArray(fds);<br>107<br>108 .       /<em> Inoke the synchronous event demultiplexer.</em>/<br>109 .       if(0 &lt; poll(fds, noOfHandles, INFTIM)){<br>110 //.     if(0 &lt; poll(fds, noOfHandles, 5000)){<br>111 .       .       /<em> Identify all signalled handles and invoke the event handler associated with each one. </em>/<br>112 .       .       dispatchSignalledHandles(fds, noOfHandles);<br>113 .       }<br>114 .       else{<br>115 .       .       ne_debug(REACTOR_DEBUG, “Poll failure\n”);<br>116 .       .       return;<br>117 .       }<br>118 }<br>119<br>120 /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>121 <em> Definition of the local utility functions.<br>122 <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br>123<br>124 /**<br>125 </em> Add a copy of the given handler to the first free position in registeredHandlers.<br>126 <em>/<br>127 static int addToRegistry(EventHandler</em> handler)<br>128 {<br>129 .       /<em> Identify the first free position. </em>/<br>130 .       int isRegistered = 0;<br>131 .       int i = 0;<br>132<br>133 .       for(i = 0; (i &lt; MAX_NO_OF_HANDLES) &amp;&amp; (0 == isRegistered); ++i) {<br>134 .       .       if(0 == registeredHandlers[i].isUsed) {<br>135 .       .       .       /<em> A free position found. </em>/<br>136 .       .       .       HandlerRegistration<em> freeEntry = &amp;registeredHandlers[i];<br>137<br>138 .       .       .       /</em> Create a binding between the handle provided by the client and the events of interest. <em>/<br>139 .       .       .       freeEntry-&gt;handler = </em>handler;<br>140 .       .       .       freeEntry-&gt;fd.fd = handler-&gt;getHandle(handler-&gt;instance);<br>141 .       .       .       freeEntry-&gt;fd.events = POLLRDNORM;<br>142<br>143 .       .       .       isRegistered = freeEntry-&gt;isUsed = 1;<br>144<br>145 .       .       .       ne_debug(REACTOR_DEBUG, “Reactor: Added handle with ID=%d\n”, freeEntry-&gt;fd.fd);<br>146 .       .       }<br>147 .       }<br>148<br>149 .       return isRegistered;<br>150 }<br>151<br>152 /<strong><br>153 <em> Identify the event handler in the registeredHandlers and remove it.<br>154 </em>/<br>155 static int removeFromRegistry(EventHandler<em> handler)<br>156 {<br>157 .       /</em> Identify the event handler in the registeredHandlers and remove it. <em>/<br>158 .       int i = 0;<br>159 .       int nodeRemoved = 0;<br>160<br>161 .       for(i = 0; (i &lt; MAX_NO_OF_HANDLES) &amp;&amp; (0 == nodeRemoved); ++i) {<br>162 .       .       if(registeredHandlers[i].isUsed &amp;&amp; (registeredHandlers[i].handler.instance == handler-&gt;instance)) {<br>163 .       .       .       /</em> The given event handler is found -&gt; mark it as unused and terminate the loop. */<br>164 .       .       .       registeredHandlers[i].isUsed = 0;<br>165 .       .       .       nodeRemoved = 1;<br>166<br>167 .       .       .       ne_debug(REACTOR_DEBUG, “Reactor: Removed event handler with ID=%d\n”, registeredHandlers[i].fd.fd);<br>168 .       .       }<br>169 .       }<br>170<br>171 .       return nodeRemoved;<br>172 }<br>173<br>174 /</strong><br>175 <em> Add a copy of all registered handlers to the given array.<br>176 </em>/<br>177 static size_t buildPollArray(struct pollfd<em> fds)<br>178 {<br>179 .       /</em> Add all registered handlers to the given array. <em>/<br>180 .       int i = 0;<br>181 .       size_t noOfCopiedHandles = 0;<br>182<br>183 .       for(i = 0; i &lt; MAX_NO_OF_HANDLES; ++i) {<br>184 .       .       if(registeredHandlers[i].isUsed) {<br>185 .       .       .       fds[noOfCopiedHandles] = registeredHandlers[i].fd;<br>186 .       .       .       ++noOfCopiedHandles;<br>187 .       .       }<br>188 .       }<br>189<br>190 .       return noOfCopiedHandles;<br>191 }<br>192<br>193 /**<br>194 </em> Identify the event handler corresponding to the given descriptor in the registeredHandlers.<br>195 <em>/<br>196 static EventHandler</em> findHandler(int fd)<br>197 {<br>198 .       EventHandler<em> matchingHandler = NULL;<br>199<br>200 .       /</em> Identify the corresponding concrete event handler in the registeredHandles. <em>/<br>201 .       int i = 0;<br>202<br>203 .       for(i = 0; (i &lt; MAX_NO_OF_HANDLES) &amp;&amp; (NULL == matchingHandler); ++i) {<br>204 .       .       if(registeredHandlers[i].isUsed &amp;&amp; (registeredHandlers[i].fd.fd == fd)) {<br>205 .       .       .       matchingHandler = &amp;registeredHandlers[i].handler;<br>206 .       .       }<br>207 .       }<br>208<br>209 .       return matchingHandler;<br>210 }<br>211<br>212 /**<br>213 </em> Loop through all handles. Upon detection of a handle signalled by poll(), its<br>214 <em> corresponding event handler is fetched and invoked.<br>215 </em>/<br>216 static void dispatchSignalledHandles(const struct pollfd<em> fds, size_t noOfHandles)<br>217 {<br>218 .       size_t i = 0;<br>219<br>220 .       for(i = 0; i &lt; noOfHandles; ++i) {<br>221 .       .       /</em> Detect all signalled handles. <em>/<br>222 .       .       if((POLLRDNORM | POLLERR) &amp; fds[i].revents) {<br>223 .       .       .       /</em> This handle is signalled -&gt; find and invoke its corresponding event handler. <em>/<br>224 .       .       .       EventHandler</em> signalledHandler = findHandler(fds[i].fd);<br>225<br>226 .       .       .       if(NULL != signalledHandler){<br>227 .       .       .       .       signalledHandler-&gt;handleEvent(signalledHandler-&gt;instance);<br>228 .       .       .       }<br>229 .       .       }<br>230 .       }<br>231 }<br>232 </stdio.h></stddef.h></assert.h></sys></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">####6.5、触发Reactor  </div><div class="line"></div><div class="line">&lt;a id=&apos;6.5&apos; name=&apos;6.5&apos;&gt; &lt;/a&gt;  </div><div class="line"></div><div class="line">反应事件轮询是Reactor的核心，其职责在于根据具体的事件处理器控制已注册事件的分离和分发。事件循环典型由main()函数调用。  </div><div class="line"></div><div class="line">驱动reactor的客户端代码如下：  </div><div class="line"></div><div class="line">```  </div><div class="line"></div><div class="line"> 13 #include &quot;base.h&quot;</div><div class="line"> 14 #include &quot;DiagnosticsServer.h&quot;</div><div class="line"> 15 #include &quot;ReactorEventLoop.h&quot;</div><div class="line"> 16 </div><div class="line"> 17 #include &quot;Error.h&quot;</div><div class="line"> 18 </div><div class="line"> 19 void reactor_test(void)</div><div class="line"> 20 &#123;</div><div class="line"> 21 .       /* </div><div class="line"> 22 .        * Create a server and enter an eternal event loop, watching </div><div class="line"> 23 .        * the Reactor do the rest. </div><div class="line"> 24 .        */</div><div class="line"> 25 </div><div class="line"> 26 .       const unsigned int serverPort = 0xC001;</div><div class="line"> 27 .       DiagnosticsServerPtr server = createServer(serverPort);</div><div class="line"> 28 .       if(NULL == server) &#123;</div><div class="line"> 29 .       .       ne_debug(REACTOR_DEBUG, &quot;Failed to create the server\n&quot;);</div><div class="line"> 30 .       .       return;</div><div class="line"> 31 .       &#125;</div><div class="line"> 32 </div><div class="line"> 33 .       /* Enter the eternal reactive event loop. */</div><div class="line"> 34 .       for(;;)&#123;</div><div class="line"> 35 .       .       HandleEvents();</div><div class="line"> 36 .       &#125;</div><div class="line"> 37 &#125;</div></pre></td></tr></table></figure>
<p>为了整体设计，需要单独为HandleEvents()创建一个文件实现，PollReactor.c，其中每个元素都将已注册事件的句柄和用于同poll()交互的结构绑定在一起。另外一种替代方案是维护两个不同的链表以确保二者的一致性。UNIX实现采用select()，定义为“一个以UNIX I/O句柄值为索引的数组，范围为0至FD_SETSIZE-1”。  </p>
<p>在本实现中，通过将poll结构和注册组合在一起，由于采用数组用于同poll()交互，因此该数组必须在每次事件轮询进入的时刻建立。  </p>
<p>####6.6、处理注册  </p>
<p><a id="6.6" name="6.6"> </a>  </p>
<p>在本文的reactor实现中，server通过创建一个新的client来响应通知，这样一来，必须注册方可再次激活。  </p>
<p>一种解决方案是维护一个单独的数组用于同同步事件分离器进行交互, 该数组在事件循环中不能被修改。  </p>
<p>而句柄的实现则依赖平台，句柄ID有可能被重用；在拷贝中的一个信号句柄有可能属于一个未注册的事件句柄，但是由于注册重用了句柄ID，新的事件处理器可能被错误触发。我们可以加入哨兵数据以标识是否重用来解决该问题。  </p>
<p>####6.7、事件多样性  </p>
<p><a id="6.7" name="6.7"> </a>  </p>
<p>实例代码仅仅考虑了一种类型的事件（read事件），其类型是hardcoded。Reactor本身并未受类型限制，能够很好的支持多种类型。  </p>
<p>两种通用的事件通知分发机制：    </p>
<ul>
<li>Single-method interface：所有的事件由单个函数通知事件处理器，函数中只需传入事件类型即可(enum)，其不足之处在于加入了额外的控制逻辑，难于维护。  </li>
<li>Multi-method interface：事件处理器为每种支持的事件声明各自的函数（比如会所handleRead, handleWrite, handleTimeout）。一旦Reactor获取已发生事件的类型，它立即触发对应的事件处理函数，这样避免了通过指针重新创建事件的额外开销。  </li>
</ul>
<p>###7、REACTOR vs OBSERVER  </p>
<p><a id="vs" name="vs"> </a>  </p>
<p>尽管用于实现二者的机制相关，但是仍存在差异，主要的不同点在于通知机制。在OBSERVER实现中，当一个Subject改变其状态时，它的所有依赖者（observers)都被通知。而在REACTOR实现中，通知的关系式一对一，即一个已探测到的事件导致Reactor通知其对应的实例（EventHandler）。  </p>
<p>另外，一个典型的OBSERVER模式下的subject是低内聚的，除了服务其核心目的，一个subject也会负责管理和通知observers。相反，一个Reactor则仅仅分发已经注册的处理器。</p>
<p>###8、结论  </p>
<p><a id="cons" name="cons"> </a>  </p>
<p>应用REACTOR模式的主要结论如下：  </p>
<ul>
<li>遵循single-responsibility原则的好处：采用REACTOR模式，每种责任被封装并相互之间解耦，导致高内聚，因此简化了后续维护。比如在事件探测中平台相关的代码可以从应用中解耦，极大的方便了单元测试。  </li>
<li>遵循open-closed原则的好处：新的责任只需创建新的事件处理器，无需影响现有代码。  </li>
<li>统一了事件处理：尽管REACTOR模式集中于句柄，但其可以扩展至其他任务。Reactor加入timer支持（平台相关，比如基于信号或者线程），当同步事件分离器触发后可以设定一个超时，以避免重入问题和竞争条件。  </li>
<li>提供了一种并行读的方案：采用REACTOR方案可以有效避免并行读事件处理中的阻塞现象，其本质是一个非抢占式的多任务模型，每个具体的事件处理器必须确保其不能执行可能导致其余事件处理器饥饿的操作。  </li>
<li>类型安全的折中：由于所有的事件处理器抽象为void *，当由void指针转化为具体的事件处理指针时，编译器并没有相应的机制处理转化错误。同样的问题在OBSERVER模式中也存在，解决方法都是一致的：为不同类型的事件处理器定义单独的通知函数，利用EventHandler绑定事件处理器和其他函数。  </li>
</ul>
<p>###9、总结  </p>
<p><a id="sum" name="sum"> </a>  </p>
<p>Reactor模式通过对不同责任的解耦和不同模块的封装简化了事件驱动型应用的设计。关于该模式更多的讨论可以参考面向对象的软件模式卷2。      </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文由&lt;a href=&quot;http://skypacer210.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;skypacer&lt;/a&gt;译自&lt;a href=&quot;http://www.adampetersen.se/Patterns%20in
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="design pattern" scheme="http://yoursite.com/tags/design-pattern/"/>
    
      <category term="reactor" scheme="http://yoursite.com/tags/reactor/"/>
    
  </entry>
  
  <entry>
    <title>基于ARM平台的AES硬件加速实现</title>
    <link href="http://yoursite.com/2013/12/22/aes-acceleration-in-arm/"/>
    <id>http://yoursite.com/2013/12/22/aes-acceleration-in-arm/</id>
    <published>2013-12-21T16:00:00.000Z</published>
    <updated>2017-08-06T11:23:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、硬件加密引擎特点"><a href="#1、硬件加密引擎特点" class="headerlink" title="1、硬件加密引擎特点"></a>1、硬件加密引擎特点</h2><p>硬件加速引擎的目的在于减少加解密中软件的干预，从而提高性能.该硬件加密引擎共有四个引擎，每次运行一个，支持的加密算法有：  </p>
<ul>
<li>DES(Only ECB and CBC modes) </li>
<li>3DES(ECB/CBC EDE and EEE modes)</li>
<li>AES(128/192/256):  其中AES-CBC支持IV feedback，即加密完之后密文的最后16个字节拷贝至引擎的内部SRAM中的IV位置</li>
</ul>
<p>对AES而言，首先将报文、配置信息以及密钥和初始化向量放入一连串的TDMA描述符当中，并配置chain模式，最后启动TDMA，即可连续加密。  IV是由用户配置的，后续的IV由硬件自己填充，CTR模式可以通过软件实现。<br>中断发生，会将对于位置位，通知软件取数。</p>
<p>支持的验证算法为SHA或者MD5。</p>
<p>在硬件加速实现中，CPU和加速引擎精密协作但具体分工又不尽相同。  </p>
<p>对CPU而言，主要完成三件事：</p>
<ul>
<li>直接拷贝报文至加速器的本地SRAM中（没有采用DMA的情况下）；  </li>
<li>准备一个描述符，声明所需要的操作，目前描述符在主存中分配和配置<code>struct sa_accel_sram</code>，并映射至硬件当中对应的镜像位置（偏移为<code>SRAM_CONFIG</code>, <code>SRAM_KEY</code>, <code>SRAM_DATA_IN</code>等）。</li>
<li>通过Sheeva CPU core，激活加速器。    </li>
</ul>
<p>而加速引擎的职责包括计算、与CPU交互和数据搬运，具体来说，包括CESA和TDMA两个子引擎，其中CESA负责对数据进行操作，主要流程如下：    </p>
<ol>
<li>读取描述符  </li>
<li>启动引擎 </li>
<li>开始处理报文块，一次一个</li>
<li>等待完成</li>
<li>从引擎读取数据</li>
<li>存储数据值本地SRAM    </li>
</ol>
<p>而TDMA只是负责在主存和SRAM之间拷贝数据。</p>
<h2 id="2、CESA配置流程"><a href="#2、CESA配置流程" class="headerlink" title="2、CESA配置流程"></a>2、CESA配置流程</h2><h3 id="2-1、引入加密引擎"><a href="#2-1、引入加密引擎" class="headerlink" title="2.1、引入加密引擎"></a>2.1、引入加密引擎</h3><p><strong>Access</strong></p>
<p>CPU和SEAS交替控制，但在一个时间点上只能有一个作为HOST，TDMA当中有owner位，指示出当前的HOST是TDMA设备还是CPU。  </p>
<p><strong>Control</strong></p>
<p>若干特殊的命令控制器，比如SHA-1/MD5相关的命令寄存器：    </p>
<p>#define SHA1_MD5_CTRL_REG 0x0003DD18 /    *Set when hash complete; Clear when any write to the auth engines*/   </p>
<p>#define SHA1_MD5_TERM_MASK 0x1 &lt;&lt; 31) /    *bit31*/</p>
<p><strong>输入</strong>  </p>
<ol>
<li>输入数据长度为64bit或者128bit </li>
<li>输入带验证数据长度为512bit  </li>
<li>写数据寄存器，加载输入数据(只有DES支持多任务)</li>
<li>写密钥寄存器和IV寄存器</li>
</ol>
<p><strong>输出</strong></p>
<ol>
<li>加密引擎返回数据长度也为64bit或者128bit</li>
<li>验证引擎返回相应的签名长度.</li>
<li>通过指定的数据寄存器访问输出数据  </li>
</ol>
<p><strong>操作原则</strong></p>
<ol>
<li>写入加密参数</li>
<li>写入数据，激活引擎</li>
<li>在指定的命令寄存器上设置终止位</li>
<li>使能中断通知CPU操作完毕</li>
<li>CPU从寄存器读取结果  </li>
</ol>
<h3 id="2-2、88AP510安全加密引擎"><a href="#2-2、88AP510安全加密引擎" class="headerlink" title="2.2、88AP510安全加密引擎"></a>2.2、88AP510安全加密引擎</h3><p><strong>地址映射</strong>   </p>
<p>* phys virt size<br>* c8000000 fdb00000 1M Cryptographic SRAM<br>* e0000000 @runtime 128M PCIe-0 Memory space<br>* e8000000 @runtime 128M PCIe-1 Memory space<br>* f1000000 fde00000 8M on-chip south-bridge registers<br>* f1800000 fe600000 8M on-chip north-bridge registers<br>* f2000000 fee00000 1M PCIe-0 I/O space<br>* f2100000 fef00000 1M PCIe-1 I/O space</p>
<p>#define DOVE_CRYPT_PHYS_BASE. . (DOVE_SB_REGS_PHYS_BASE | 0x30000) /    * Cryptographic Engine */</p>
<p><strong>寄存器配置</strong></p>
<p>实例： 修改DOVE寄存器   </p>
<p>575 . /<em> enable isolators </em>/<br>576 . reg = MV_REG_READ(PMU_ISO_CTRL_REG);<br>577 . reg &amp;= ~PMU_ISO_VIDEO_MASK;<br>578 . MV_REG_WRITE(PMU_ISO_CTRL_REG, reg);</p>
<p><strong>加密流程</strong></p>
<ul>
<li>检查 <code>aes_term</code> 是否为1，类似轮询操作；</li>
<li>配置 <code>AES_CTRL_REG</code>: 密钥长度和数据大小字节序；</li>
<li>写入密钥寄存器，总共8个，如果key不变，则无需配置；     </li>
<li>每次写入128bit的数据块: 配置AES ENC Data In/out register； 当这些寄存器填写完毕（填写顺序无所谓），加密开始；如果小于128，自动补0。   </li>
<li>轮询AES命令寄存器或者等待中断：在轮询模式下如果为1，说明结果已经准备好； 在中断模式下每次中断发生，结束位从0变为1，当中断发生后，主机向中断使能寄存器的Zint2写入0以重启它，写入1则无影响。  </li>
<li>获取AES结果：结果同样位于AES IO寄存器当中；引擎不会对字节序做任何修改。</li>
</ul>
<p><strong>解密流程</strong></p>
<p>当加密操作完成时，key发生了变化，必须根据最后的加密key生成key schedule；具体如下：  </p>
<ul>
<li>当用一个指定的key解密数据时候，主机首先加载key至解密引擎，然后设置AES解密命令寄存器为1，产生key schedule。</li>
<li>当从解密引擎中读取一个key的时候，主机必须等待AES命令寄存器的key schedule位为1，方可读取key寄存器。  </li>
</ul>
<p>其中解密密钥生成步骤：  </p>
<ol>
<li>写入AES解密key n 寄存器；</li>
<li>设置解密控制寄存器的aesDecMakekey位为1；</li>
<li>轮询直到该位设置为1；</li>
<li>从对应的解密key寄存器中读取key；</li>
<li>清空AES解密控制寄存器。</li>
</ol>
<p>主机可能会在内存中保存解密key，这样key计算可以在下次忽略（采用相同的key）:  </p>
<ol>
<li>轮询解密寄存器的终止位（类似加密过程）；  </li>
<li>为解密寄存器设置解密模式和大小端；  </li>
<li>写入生成的key；  </li>
<li>写入解密数据；   </li>
<li>轮询解密寄存器或者是等待中断发生；  </li>
<li>读取AES结果；  </li>
<li>读取key(主机必须加载一个raw key)。</li>
</ol>
<h2 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h2><h3 id="3-1、设计原理"><a href="#3-1、设计原理" class="headerlink" title="3.1、设计原理"></a>3.1、设计原理</h3><p>启用CESA，本质上是数据在DRAM和SRAM之间的拷贝，如果采用DMA，需要将DRAM和SRAM中数据的虚拟地址转化为对应的物理地址。<br>由于CESA只能处理在CESA SRAM中的报文，最大支持2KB，因此在包含其他信息的前提下（SA描述符、key、IV），实际处理的数据最大是1.75KB。  </p>
<ul>
<li>对于每个报文，至少需要1个SA描述符和4个TDMA描述符，如果数据在物理内存中有分片，则会需要更多的TDMA描述符。</li>
<li>驱动利用预定义的SA和TDMA描述符池以期获得最好的性能，池的大小可以匹配请求的size大小。  </li>
</ul>
<h3 id="3-2、基本架构"><a href="#3-2、基本架构" class="headerlink" title="3.2、基本架构"></a>3.2、基本架构</h3><p><strong>1、应用请求分发方式</strong></p>
<p>对于来自上层的应用请求（AES加解密）可以采用以下两种同步回调模式和异步回调模式。  </p>
<p>对于同步回调模式而言，同步操作较为简单，但是当请求被提交时程序会阻塞；调用同步回调函数（实现数据由软件传至硬件）即可，一旦硬件处理完毕，即可返回，流程如下：</p>
<ol>
<li>准备硬件请求；</li>
<li>发送至硬件，等待完成；</li>
<li>如果请求成功完成，用处理后的数据代替原先的数据；</li>
<li>如果该数据需要验证，需要在MAC缓冲区存储一份MAC值。</li>
</ol>
<p>而在异步回调模式下，异步请求会被加入硬件队列，同时返回，当硬件完成请求时，硬件调用另外一个处理程序返回，并送入上层协议栈，通常情况下效率更高，除了同步回调函数，必须注册另外一个回调函数（通知回调函数）以方便硬件完成操作之后调用，该回调通知函数在上层实现，主要将结果传至上层协议栈。  </p>
<ol>
<li>准备硬件请求，包括所有数据和参数，实现通知回调函数；</li>
<li>根据返回值操作，如果正确则用处理后的数据替换原始数据；获取MAC值；清空本地内存。</li>
<li>如果失败则释放内存；</li>
<li>如果有必要，准备一个包含原始数据的指针；</li>
<li>发生请求值硬件；</li>
<li>返回状态代码；</li>
<li>当硬件完成操作后，调用通知回调函数</li>
</ol>
<p>目前采用的是同步方式。</p>
<p><strong>2、中间层</strong></p>
<p>在硬件接口和上层接口层之间加入一个中间层，以此隔离上层对于底层调用的依赖，可以基于纯软件实现AES加解密，也可以基于硬件实现。  </p>
<p><strong>3、流程控制</strong>  </p>
<p>采用中断方式接收数据并进行处理。中断是硬件处理数据之后的动作，因此，触发中断需要有两级：  </p>
<ul>
<li>使能中断，此时可以写对应中断掩码  </li>
<li>写入数据，此时开始硬件处理  </li>
</ul>
<p>具体的流程如下：   </p>
<ul>
<li>建立一个进程专门处理中断，通过读取中断寄存器判断是否有中断，如果中断上来就处理收发。  </li>
<li>设置中断寄存器；  </li>
<li>本地中断寄存器和掩码寄存器，就包括了CESA单元的，可以在pic.c中为CESA定义中断向量。     </li>
</ul>
<p><strong>4、DMA</strong></p>
<p>在该平台的硬件引擎中，专门实现了DMA，称之为TDMA。TDMA的基本特点如下：</p>
<ul>
<li>独立的TDMA引擎，无需CPU参与可以在DDR内存和内部SRAM之间搬移大规模数据, 通过TDMA从主存中拷贝报文至安全加速引擎的本地SRAM，最大支持2KB。</li>
<li>一次最大支持2KB，可以运行于chain mode，该模式下为每个缓冲区分配一个唯一的描述符。</li>
<li>一旦TDMA激活，禁止任何软件读访问本地SRAM；</li>
<li>保存与安全加速引擎相关的加密参数值，保存在主存当中，但是必须映射至引擎的SRAM当中；  </li>
<li>在安全加速器的SRAM中准备描述符，开始加速引擎需要的操作和参数。</li>
</ul>
<p>TDMA最主要的寄存器是TMDA描述符，由四个32位寄存器组成：  </p>
<ul>
<li>Byte Count(0x800): 传输的数据字节数，最大支持64KB-1,随着数据从源地址向目的地址的拷贝递减，为0时，意味着TDMA传输完成或者终止;Own位表示CPU或者TMDA拥有该描述符;  </li>
<li>Source Address(0x810)：TDMA源地址 必须为内部SRAM地址 可以直接将内部SRAM的固定偏移地址写入;</li>
<li>Destination Address(0x820)：TDMA目的地址 必须为内部SRAM地址 提供了一种思路，遇到需要配置硬件地址的时候，可以定义一个固定偏移，这样软硬件填写方便;</li>
<li>下一个描述符指针(0x830)：为了支持chain模式，必须是16字节对齐（bit[3:0]=0）。</li>
</ul>
<p><strong>5、TDMA与加密引擎协调工作</strong></p>
<p>TDMA作为一种硬件内置的DMA方式，与其他硬件加速引擎配合工作，较为显著的提高了吞吐率，基本流程如下：  </p>
<p>首先设置CESA配置寄存器（0xE08）的waitforTDMA和ActiveTDMA，当TMDA和CESA协同工作的时候，CESA能独立操作DRAM，CESA有能力激活TDMA，决定其状态并提供单独的完成中断；其中软件则需要步骤（五步）：  </p>
<ul>
<li>在DRAM中配置TDMA描述符chain；</li>
<li>初始化TDMA配置寄存器；</li>
<li>在DRAM中或者SRAM中初始化CESA描述符和参数；</li>
<li>初始化CESA配置寄存器；</li>
<li>软件激活硬件加速。</li>
</ul>
<p>TDMA的基本功能和软件流程综述如下：  </p>
<ul>
<li>利用TDMA从主存DRAM中拷贝报文至CESA的本地SRAM中，对于大的报文，可以进行分片。</li>
<li>存储CESA所需的加密参数；</li>
<li>为CESA的本地SRAM准备一个描述符（MV_CESA_DESC），设定需要的操作和参数，描述符总共8个双字长；</li>
<li>通过配置CESA描述符指针寄存器（0xE04），将SRAM中MV_CESA_DESC数据域地址写入选定的session中（通过计算偏移得到）；</li>
<li>通过配置命令寄存器（0xE00）合适的位激活该session；</li>
<li>等待硬件完成，在轮询模式或者中断模式下的判断标志为寄存器（0xE0C）第0位，若为1则说明已经actived；</li>
<li>利用TDMA将完成的报文拷贝回主存。</li>
</ul>
<p>其中CESA中的SRAM内存映射如下：  </p>
<p>/*<br> * CESA SRAM Memory Map: *<br> * +————————+ &lt;= sc-&gt;sc_sram_base + CESA_SRAM_SIZE<br> * |                        |<br> * |          DATA          |<br> * |                        |<br> * +————————+ &lt;= sc-&gt;sc_sram_base + CESA_DATA(0)<br> * | struct cesa_sa_data    |<br> * +————————+<br> * | struct cesa_sa_hdesc |<br> * +————————+ &lt;= sc-&gt;sc_sram_base<br> */</p>
<p>其中<code>CESA_SRAM_SIZE=2048</code>， <code>CESA_DATA(0)=sizeof（struct cesa_sa_hdesc）</code>，字节序则利用宏直接转化。  </p>
<p>对于分片报文，可以暂时不支持，以简化设计 CESA 的SDK支持最大报文为64 * 1024，而一次处理1600大小，因此需要分片。</p>
<p>SRAM地址可以直接返回一个全局变量：<code>MV_U32 cesaCryptEngBase = 0</code>;</p>
<p>对于SA配置，可以定义数据结构<code>sa_config</code>和相应的配置函数。</p>
<h3 id="4、调试小记"><a href="#4、调试小记" class="headerlink" title="4、调试小记"></a>4、调试小记</h3><h3 id="4-1、调试基本原则"><a href="#4-1、调试基本原则" class="headerlink" title="4.1、调试基本原则"></a>4.1、调试基本原则</h3><p>在开发前期，为了尽快试错以及避免代码注释混乱，采用switch语句定义不同的dec_key方法，并用全局变量用GUI配置，则无需重新编译即可完成正确方案的选择。而在面对时而正确时而错误的加解密情况，加入打印语句：  </p>
<ul>
<li>首先排除硬件返回超时的错误；</li>
<li>排除CESA SRAM没有初始化的错误；</li>
<li>排除状态机的锁处理问题；</li>
<li>定位至状态机的处理，很可能在处理开始之前没有正确赋给初值。</li>
</ul>
<p>基于以上分析思路，解决了数据乱码问题，定位过程如下：  </p>
<p><strong>1、数据拷贝流程分析</strong>  </p>
<p>分解TDMA和CESA的交互过程，逐步调试，至比如数据从主存至TDMA，是否拷贝正确； 数据处理完之后是否拷贝至主存?</p>
<ul>
<li>从cache到主存；</li>
<li>DMA读： 从主存至设备；</li>
<li>DMA写： 从设备至主存；</li>
<li>主存至cache。  </li>
</ul>
<p><strong>2、Cache相关</strong>   </p>
<p>这里涉及两个问题：clean cache和Invalide cache:  </p>
<ul>
<li>clean cache意味着将cache中的数据强制写入主存, 即设备访问到了最新的内容，保证了设备访问CPU的数据正确性。    </li>
<li>invalide cache用来确保设备完成时，CPU可以从主存中读取到最新的内容，即保证了CPU访问设备的数据正确性。</li>
</ul>
<p><strong>3、DMA相关</strong>  </p>
<p>DMA要考虑页表连续性和CPU-cache。  </p>
<p>现象：  </p>
<ul>
<li>有错包出现，且大小无规律；</li>
<li>现象二：memory trap，无规律。  </li>
</ul>
<p>采用软件对比方法，对比几个方面，包括DMA-out/HW caculate,分析出错误点。硬件计算错误的原因（配置错误、密钥IV错误、源目的地址错误），排除了前二者，只能是传入了错误的物理地址给硬件。在进行虚实地址转化的时候，由于转化后的物理地址可能跨页，因此必须分页拷贝，即计算出距离页边界的偏移，判断是否跨页，如果跨了先拷贝当前页数据，在拷贝下一页数据。其中DMA和CPU-cache是两个不同的两个概念：  </p>
<ul>
<li>DMA指的是一种硬件设备，能够无须使用CPU指令实现对内存的拷贝；后者是主存和CPU之间的关系；</li>
<li>DMA在进行数据拷贝的时候，或许用到CPU-cache的参与，或许根本就不用。</li>
</ul>
<p><strong>4、随机问题定位</strong></p>
<p>在实际的调试中在单个进程中调用时没有问题，在多个进程调用的时候出现问题，因此可以确定可能是进程并发的问题。经过调试发现，中断会在休眠之前发生，因此在需要禁止中断。    </p>
<p>另外一个随机问题是在释放版本中发现的，硬件加速引擎偶尔出现超时，但是在开发版本中从不会超时，控制结构体中的一个描述状态的字段不太正常，后者相对前者做了编译优化，导致发生不可预期的错误，因此需要在其定义出加入volitile关键字，问题得以解决。  </p>
<h2 id="5、参考文献"><a href="#5、参考文献" class="headerlink" title="5、参考文献"></a>5、参考文献</h2><ol>
<li><a href="http://igoro.com/archive/gallery-of-processor-cache-effects/" title="http://igoro.com/archive/gallery-of-processor-cache-effects/" target="_blank" rel="external">Gallery of Processor Cache Effects</a></li>
<li><a href="http://stackoverflow.com/questions/1855896/memory-alignment-on-modern-processors" title="http://stackoverflow.com/questions/1855896/memory-alignment-on-modern-processors" target="_blank" rel="external">Memory alignment on modern processors?</a></li>
<li><a href="http://stackoverflow.com/questions/4605030/will-the-cache-line-aligned-memory-allocation-pay-off" title="http://stackoverflow.com/questions/4605030/will-the-cache-line-aligned-memory-allocation-pay-off" target="_blank" rel="external">Will the cache line aligned memory allocation pay off?</a></li>
<li><a href="http://stackoverflow.com/questions/9809140/how-correctly-wake-up-process-inside-interrupt-handlers" title="http://stackoverflow.com/questions/9809140/how-correctly-wake-up-process-inside-interrupt-handlers" target="_blank" rel="external">How correctly wake up process inside interrupt handlers</a></li>
<li><a href="http://stackoverflow.com/questions/11012406/race-condition-between-wait-event-and-wake-up?rq=1" title="http://stackoverflow.com/questions/11012406/race-condition-between-wait-event-and-wake-up?rq=1" target="_blank" rel="external">race condition between wait_event and wake_up</a></li>
<li><a href="http://stackoverflow.com/questions/6570419/linux-kernel-interrupt-handler-mutex-protection?rq=1" title="http://stackoverflow.com/questions/6570419/linux-kernel-interrupt-handler-mutex-protection?rq=1" target="_blank" rel="external">Linux kernel interrupt handler mutex protection?</a></li>
<li><a href="http://www.noise.physx.u-szeged.hu/DigitalMeasurements/DSP/Sharc/Sharc/chap06.pdf" title="http://www.noise.physx.u-szeged.hu/DigitalMeasurements/DSP/Sharc/Sharc/chap06.pdf" target="_blank" rel="external">DSP DMA</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、硬件加密引擎特点&quot;&gt;&lt;a href=&quot;#1、硬件加密引擎特点&quot; class=&quot;headerlink&quot; title=&quot;1、硬件加密引擎特点&quot;&gt;&lt;/a&gt;1、硬件加密引擎特点&lt;/h2&gt;&lt;p&gt;硬件加速引擎的目的在于减少加解密中软件的干预，从而提高性能.该硬件加密引擎共
    
    </summary>
    
      <category term="technology" scheme="http://yoursite.com/categories/technology/"/>
    
    
      <category term="ARM" scheme="http://yoursite.com/tags/ARM/"/>
    
      <category term="AES" scheme="http://yoursite.com/tags/AES/"/>
    
      <category term="Acceleration" scheme="http://yoursite.com/tags/Acceleration/"/>
    
  </entry>
  
</feed>
