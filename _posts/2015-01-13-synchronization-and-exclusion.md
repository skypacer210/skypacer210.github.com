---
layout: post
title: "Synchronization and Exclusion"
categories:
- technology
tags:
- Spinlock
- Process
- Synchronization
- Exclusion


---

## 进程之间为什么需要同步

在顺序程序设计中，由于代码指令都是顺序执行，重复执行会得到相同的结果，即程序与计算一一对应。  
并发程序意味着一个程序未执行完，而另外一个程序已经开始执行，这就是所谓的并发性。并发性从宏观上反映了一个时间段内有几个进程都处于运行态但运行尚未结束的状态。从微观上看，任一时刻仅有一个进程的一个操作在处理器上运行。反过来看，并发其实就是处理器在几个进程之间的多路复用器，是对有限物理资源的强制进行多用户共享，消除计算机部件之间的互等，提供系统资源的利用率。  
由于交互的并发进程共享某些资源，一个进程的执行可能会影响其他进程的执行结果，即交互的进程之间**相互制约**。因此，必须对进程的交互过程进行控制，引入了各种同步机制。  

## 互斥与同步的关系  

### 互斥
互斥又称为竞争，并发的引入使得原本没有竞争关系的进程在访问共享资源时发生了冲突，进程之间存在**间接制约关系**。在这种关系下，一个进程获得资源，另一个进程不得不阻塞等待，因此可能会导致两个严重问题：死锁与饥饿。防止不公平，或者饿死某些低优先级的进程，是调度系统必须考虑的问题。    
### 同步  
进程同步是指为完成共同任务的并发进程基于某个条件来协调其活动，因为需要在某些位置上排定执行的**先后次序**而等待、传递信号或则消息所产生的协作制约关系。这种有先后次序的协作是进程之间的直接制约关系。          
同步是为了几个具备一些依赖性的任务一起协同工作，通信则是为了同步的手段，可以基于共享内存，也可以基于消息传递。进行之间的协作可以是比知道对方名字的协作，比如通过共享内存进行松散式协作；或者进程双方知道对方名字，通过消息机制进行紧密协作。      
竞争关系从某种意义上可以看出是同步，因为存在竞争关系的进程需要互斥的访问资源，也遵循**互斥的访问次序**。


## 实现同步的方式

实现同步的方式有多种，可以基于软件，也可以基于硬件。以自旋锁为例简述其实现原理。  
Spinlock作为一种临界区保护机制，在单处理器和多处理器下的实现不尽相同：  
*  对于单处理器系统，实现互斥的最简单办法就是在进程进入临界区之前关闭中断，在进程退出临界区时开中断。因为进程的上下文切换都是由中断引起的，这样进程的执行就会被打断，因此关掉中断可以保证进行互斥的进入临界区。但不适宜作为通用的互斥机制，关中断事件过程会导致系统性能和效率下降，而且在多处理器中不适用，因为在一个处理器上关闭中断，并不能防止进程在其他处理器上执行同样的临界段代码。  
*  对于多处理器系统，可以基于xchag指令和Test and Set Lock (TSL) instruction: TSL指令这两个指令实现spinlock，因为二者都是原子操作，一个处理器在处理的时候，其余处理器只有等到处理完毕才可获取访问权，实现了对临界区的互斥访问。

XCHGB的实现：  
<pre><code>
       .globl. xchgb
 xchgb:
       movl.   4(%esp), %edx   //edx = *((int32 *) (esp + 4));将最后一个参数赋值给ESP
       movl.   8(%esp), %eax   //eax = *((int32 *) (esp + 8));将第一个参数赋值给寄存器eax
       lock                    //锁住总线
       xchgb.  %al, (%edx)     //交换寄存器edx和寄存器al的值
       ret
</code></pre>

spinlock的实现：  
<pre><code>  
bool lock = false;
bool keyi = true;

spin_lock()
{   
    
    do {
        xchgb(&keyi, lock); //xchg保证原子性操作，中间不会有中断进入
    } while (keyi);
}

spin_unlock()
{
    xchgb(&keyi, lock);
}

</code></pre>